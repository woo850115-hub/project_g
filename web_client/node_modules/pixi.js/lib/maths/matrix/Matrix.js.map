{"version":3,"file":"Matrix.js","sources":["../../../src/maths/matrix/Matrix.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-use-before-define */\nimport { PI_2 } from '../misc/const';\nimport { Point } from '../point/Point';\n\nimport type { PointData } from '../point/PointData';\n\n/**\n * The data structure that contains the position, scale, pivot, skew and rotation of an object.\n * This is used by the {@link Matrix} class to decompose the matrix into its components.\n * @category maths\n * @advanced\n */\nexport interface TransformableObject\n{\n    /** The position of the object */\n    position: PointData;\n    /** The scale of the object */\n    scale: PointData;\n    /** The pivot of the object */\n    pivot: PointData;\n    /** The skew of the object */\n    skew: PointData;\n    /** The rotation of the object */\n    rotation: number;\n}\n\n/**\n * A fast matrix for 2D transformations.\n * Represents a 3x3 transformation matrix:\n *\n * ```js\n * | a  c  tx |\n * | b  d  ty |\n * | 0  0  1  |\n * ```\n * @example\n * ```ts\n * // Create identity matrix\n * const matrix = new Matrix();\n *\n * // Create matrix with custom values\n * const transform = new Matrix(2, 0, 0, 2, 100, 100); // Scale 2x, translate 100,100\n *\n * // Transform a point\n * const point = { x: 10, y: 20 };\n * const transformed = transform.apply(point);\n *\n * // Chain transformations\n * matrix\n *     .translate(100, 50)\n *     .rotate(Math.PI / 4)\n *     .scale(2, 2);\n * ```\n * @remarks\n * - Used for transform hierarchies\n * - Supports scale, rotation, position\n * - Can be concatenated with append/prepend\n * - Efficient for batched transformations\n * @category maths\n * @standard\n */\nexport class Matrix\n{\n    /**\n     * Scale on the x axis.\n     * @default 1\n     */\n    public a: number;\n\n    /**\n     * Shear on the y axis.\n     * @default 0\n     */\n    public b: number;\n\n    /**\n     * Shear on the x axis.\n     * @default 0\n     */\n    public c: number;\n\n    /**\n     * Scale on the y axis.\n     * @default 1\n     */\n    public d: number;\n\n    /**\n     * Translation on the x axis.\n     * @default 0\n     */\n    public tx: number;\n\n    /**\n     * Translation on the y axis.\n     * @default 0\n     */\n    public ty: number;\n\n    /**\n     * Array representation of the matrix.\n     * Only populated when `toArray()` is called.\n     * @default null\n     * @see {@link Matrix.toArray} For filling this array\n     */\n    public array: Float32Array | null = null;\n\n    /**\n     * @param a - x scale\n     * @param b - y skew\n     * @param c - x skew\n     * @param d - y scale\n     * @param tx - x translation\n     * @param ty - y translation\n     */\n    constructor(a = 1, b = 0, c = 0, d = 1, tx = 0, ty = 0)\n    {\n        this.a = a;\n        this.b = b;\n        this.c = c;\n        this.d = d;\n        this.tx = tx;\n        this.ty = ty;\n    }\n\n    /**\n     * Creates a Matrix object based on the given array.\n     * Populates matrix components from a flat array in column-major order.\n     *\n     * > [!NOTE] Array mapping order:\n     * > ```\n     * > array[0] = a  (x scale)\n     * > array[1] = b  (y skew)\n     * > array[2] = tx (x translation)\n     * > array[3] = c  (x skew)\n     * > array[4] = d  (y scale)\n     * > array[5] = ty (y translation)\n     * > ```\n     * @example\n     * ```ts\n     * // Create matrix from array\n     * const matrix = new Matrix();\n     * matrix.fromArray([\n     *     2, 0,  100,  // a, b, tx\n     *     0, 2,  100   // c, d, ty\n     * ]);\n     *\n     * // Create matrix from typed array\n     * const float32Array = new Float32Array([\n     *     1, 0, 0,     // Scale x1, no skew\n     *     0, 1, 0      // No skew, scale x1\n     * ]);\n     * matrix.fromArray(float32Array);\n     * ```\n     * @param array - The array to populate the matrix from\n     * @see {@link Matrix.toArray} For converting matrix to array\n     * @see {@link Matrix.set} For setting values directly\n     */\n    public fromArray(array: number[]): void\n    {\n        this.a = array[0];\n        this.b = array[1];\n        this.c = array[3];\n        this.d = array[4];\n        this.tx = array[2];\n        this.ty = array[5];\n    }\n\n    /**\n     * Sets the matrix properties directly.\n     * All matrix components can be set in one call.\n     * @example\n     * ```ts\n     * // Set to identity matrix\n     * matrix.set(1, 0, 0, 1, 0, 0);\n     *\n     * // Set to scale matrix\n     * matrix.set(2, 0, 0, 2, 0, 0); // Scale 2x\n     *\n     * // Set to translation matrix\n     * matrix.set(1, 0, 0, 1, 100, 50); // Move 100,50\n     * ```\n     * @param a - Scale on x axis\n     * @param b - Shear on y axis\n     * @param c - Shear on x axis\n     * @param d - Scale on y axis\n     * @param tx - Translation on x axis\n     * @param ty - Translation on y axis\n     * @returns This matrix. Good for chaining method calls.\n     * @see {@link Matrix.identity} For resetting to identity\n     * @see {@link Matrix.fromArray} For setting from array\n     */\n    public set(a: number, b: number, c: number, d: number, tx: number, ty: number): this\n    {\n        this.a = a;\n        this.b = b;\n        this.c = c;\n        this.d = d;\n        this.tx = tx;\n        this.ty = ty;\n\n        return this;\n    }\n\n    /**\n     * Creates an array from the current Matrix object.\n     *\n     * > [!NOTE] The array format is:\n     * > ```\n     * > Non-transposed:\n     * > [a, c, tx,\n     * > b, d, ty,\n     * > 0, 0, 1]\n     * >\n     * > Transposed:\n     * > [a, b, 0,\n     * > c, d, 0,\n     * > tx,ty,1]\n     * > ```\n     * @example\n     * ```ts\n     * // Basic array conversion\n     * const matrix = new Matrix(2, 0, 0, 2, 100, 100);\n     * const array = matrix.toArray();\n     *\n     * // Using existing array\n     * const float32Array = new Float32Array(9);\n     * matrix.toArray(false, float32Array);\n     *\n     * // Get transposed array\n     * const transposed = matrix.toArray(true);\n     * ```\n     * @param transpose - Whether to transpose the matrix\n     * @param out - Optional Float32Array to store the result\n     * @returns The array containing the matrix values\n     * @see {@link Matrix.fromArray} For creating matrix from array\n     * @see {@link Matrix.array} For cached array storage\n     */\n    public toArray(transpose?: boolean, out?: Float32Array): Float32Array\n    {\n        if (!this.array)\n        {\n            this.array = new Float32Array(9);\n        }\n\n        const array = out || this.array;\n\n        if (transpose)\n        {\n            array[0] = this.a;\n            array[1] = this.b;\n            array[2] = 0;\n            array[3] = this.c;\n            array[4] = this.d;\n            array[5] = 0;\n            array[6] = this.tx;\n            array[7] = this.ty;\n            array[8] = 1;\n        }\n        else\n        {\n            array[0] = this.a;\n            array[1] = this.c;\n            array[2] = this.tx;\n            array[3] = this.b;\n            array[4] = this.d;\n            array[5] = this.ty;\n            array[6] = 0;\n            array[7] = 0;\n            array[8] = 1;\n        }\n\n        return array;\n    }\n\n    /**\n     * Get a new position with the current transformation applied.\n     *\n     * Can be used to go from a child's coordinate space to the world coordinate space. (e.g. rendering)\n     * @example\n     * ```ts\n     * // Basic point transformation\n     * const matrix = new Matrix().translate(100, 50).rotate(Math.PI / 4);\n     * const point = new Point(10, 20);\n     * const transformed = matrix.apply(point);\n     *\n     * // Reuse existing point\n     * const output = new Point();\n     * matrix.apply(point, output);\n     * ```\n     * @param pos - The origin point to transform\n     * @param newPos - Optional point to store the result\n     * @returns The transformed point\n     * @see {@link Matrix.applyInverse} For inverse transformation\n     * @see {@link Point} For point operations\n     */\n    public apply<P extends PointData = Point>(pos: PointData, newPos?: P): P\n    {\n        newPos = (newPos || new Point()) as P;\n\n        const x = pos.x;\n        const y = pos.y;\n\n        newPos.x = (this.a * x) + (this.c * y) + this.tx;\n        newPos.y = (this.b * x) + (this.d * y) + this.ty;\n\n        return newPos;\n    }\n\n    /**\n     * Get a new position with the inverse of the current transformation applied.\n     *\n     * Can be used to go from the world coordinate space to a child's coordinate space. (e.g. input)\n     * @example\n     * ```ts\n     * // Basic inverse transformation\n     * const matrix = new Matrix().translate(100, 50).rotate(Math.PI / 4);\n     * const worldPoint = new Point(150, 100);\n     * const localPoint = matrix.applyInverse(worldPoint);\n     *\n     * // Reuse existing point\n     * const output = new Point();\n     * matrix.applyInverse(worldPoint, output);\n     *\n     * // Convert mouse position to local space\n     * const mousePoint = new Point(mouseX, mouseY);\n     * const localMouse = matrix.applyInverse(mousePoint);\n     * ```\n     * @param pos - The origin point to inverse-transform\n     * @param newPos - Optional point to store the result\n     * @returns The inverse-transformed point\n     * @see {@link Matrix.apply} For forward transformation\n     * @see {@link Matrix.invert} For getting inverse matrix\n     */\n    public applyInverse<P extends PointData = Point>(pos: PointData, newPos?: P): P\n    {\n        newPos = (newPos || new Point()) as P;\n\n        const a = this.a;\n        const b = this.b;\n        const c = this.c;\n        const d = this.d;\n        const tx = this.tx;\n        const ty = this.ty;\n\n        const id = 1 / ((a * d) + (c * -b));\n\n        const x = pos.x;\n        const y = pos.y;\n\n        newPos.x = (d * id * x) + (-c * id * y) + (((ty * c) - (tx * d)) * id);\n        newPos.y = (a * id * y) + (-b * id * x) + (((-ty * a) + (tx * b)) * id);\n\n        return newPos;\n    }\n\n    /**\n     * Translates the matrix on the x and y axes.\n     * Adds to the position values while preserving scale, rotation and skew.\n     * @example\n     * ```ts\n     * // Basic translation\n     * const matrix = new Matrix();\n     * matrix.translate(100, 50); // Move right 100, down 50\n     *\n     * // Chain with other transformations\n     * matrix\n     *     .scale(2, 2)\n     *     .translate(100, 0)\n     *     .rotate(Math.PI / 4);\n     * ```\n     * @param x - How much to translate on the x axis\n     * @param y - How much to translate on the y axis\n     * @returns This matrix. Good for chaining method calls.\n     * @see {@link Matrix.set} For setting position directly\n     * @see {@link Matrix.setTransform} For complete transform setup\n     */\n    public translate(x: number, y: number): this\n    {\n        this.tx += x;\n        this.ty += y;\n\n        return this;\n    }\n\n    /**\n     * Applies a scale transformation to the matrix.\n     * Multiplies the scale values with existing matrix components.\n     * @example\n     * ```ts\n     * // Basic scaling\n     * const matrix = new Matrix();\n     * matrix.scale(2, 3); // Scale 2x horizontally, 3x vertically\n     *\n     * // Chain with other transformations\n     * matrix\n     *     .translate(100, 100)\n     *     .scale(2, 2)     // Scales after translation\n     *     .rotate(Math.PI / 4);\n     * ```\n     * @param x - The amount to scale horizontally\n     * @param y - The amount to scale vertically\n     * @returns This matrix. Good for chaining method calls.\n     * @see {@link Matrix.setTransform} For setting scale directly\n     * @see {@link Matrix.append} For combining transformations\n     */\n    public scale(x: number, y: number): this\n    {\n        this.a *= x;\n        this.d *= y;\n        this.c *= x;\n        this.b *= y;\n        this.tx *= x;\n        this.ty *= y;\n\n        return this;\n    }\n\n    /**\n     * Applies a rotation transformation to the matrix.\n     *\n     * Rotates around the origin (0,0) by the given angle in radians.\n     * @example\n     * ```ts\n     * // Basic rotation\n     * const matrix = new Matrix();\n     * matrix.rotate(Math.PI / 4); // Rotate 45 degrees\n     *\n     * // Chain with other transformations\n     * matrix\n     *     .translate(100, 100) // Move to rotation center\n     *     .rotate(Math.PI)     // Rotate 180 degrees\n     *     .scale(2, 2);        // Scale after rotation\n     *\n     * // Common angles\n     * matrix.rotate(Math.PI / 2);  // 90 degrees\n     * matrix.rotate(Math.PI);      // 180 degrees\n     * matrix.rotate(Math.PI * 2);  // 360 degrees\n     * ```\n     * @remarks\n     * - Rotates around origin point (0,0)\n     * - Affects position if translation was set\n     * - Uses counter-clockwise rotation\n     * - Order of operations matters when chaining\n     * @param angle - The angle in radians\n     * @returns This matrix. Good for chaining method calls.\n     * @see {@link Matrix.setTransform} For setting rotation directly\n     * @see {@link Matrix.append} For combining transformations\n     */\n    public rotate(angle: number): this\n    {\n        const cos = Math.cos(angle);\n        const sin = Math.sin(angle);\n\n        const a1 = this.a;\n        const c1 = this.c;\n        const tx1 = this.tx;\n\n        this.a = (a1 * cos) - (this.b * sin);\n        this.b = (a1 * sin) + (this.b * cos);\n        this.c = (c1 * cos) - (this.d * sin);\n        this.d = (c1 * sin) + (this.d * cos);\n        this.tx = (tx1 * cos) - (this.ty * sin);\n        this.ty = (tx1 * sin) + (this.ty * cos);\n\n        return this;\n    }\n\n    /**\n     * Appends the given Matrix to this Matrix.\n     * Combines two matrices by multiplying them together: this = this * matrix\n     * @example\n     * ```ts\n     * // Basic matrix combination\n     * const matrix = new Matrix();\n     * const other = new Matrix().translate(100, 0).rotate(Math.PI / 4);\n     * matrix.append(other);\n     * ```\n     * @remarks\n     * - Order matters: A.append(B) !== B.append(A)\n     * - Modifies current matrix\n     * - Preserves transformation order\n     * - Commonly used for combining transforms\n     * @param matrix - The matrix to append\n     * @returns This matrix. Good for chaining method calls.\n     * @see {@link Matrix.prepend} For prepending transformations\n     * @see {@link Matrix.appendFrom} For appending two external matrices\n     */\n    public append(matrix: Matrix): this\n    {\n        const a1 = this.a;\n        const b1 = this.b;\n        const c1 = this.c;\n        const d1 = this.d;\n\n        this.a = (matrix.a * a1) + (matrix.b * c1);\n        this.b = (matrix.a * b1) + (matrix.b * d1);\n        this.c = (matrix.c * a1) + (matrix.d * c1);\n        this.d = (matrix.c * b1) + (matrix.d * d1);\n\n        this.tx = (matrix.tx * a1) + (matrix.ty * c1) + this.tx;\n        this.ty = (matrix.tx * b1) + (matrix.ty * d1) + this.ty;\n\n        return this;\n    }\n\n    /**\n     * Appends two matrices and sets the result to this matrix.\n     * Performs matrix multiplication: this = A * B\n     * @example\n     * ```ts\n     * // Basic matrix multiplication\n     * const result = new Matrix();\n     * const matrixA = new Matrix().scale(2, 2);\n     * const matrixB = new Matrix().rotate(Math.PI / 4);\n     * result.appendFrom(matrixA, matrixB);\n     * ```\n     * @remarks\n     * - Order matters: A * B !== B * A\n     * - Creates a new transformation from two others\n     * - More efficient than append() for multiple operations\n     * - Does not modify input matrices\n     * @param a - The first matrix to multiply\n     * @param b - The second matrix to multiply\n     * @returns This matrix. Good for chaining method calls.\n     * @see {@link Matrix.append} For single matrix combination\n     * @see {@link Matrix.prepend} For reverse order multiplication\n     */\n    public appendFrom(a: Matrix, b: Matrix): this\n    {\n        const a1 = a.a;\n        const b1 = a.b;\n        const c1 = a.c;\n        const d1 = a.d;\n        const tx = a.tx;\n        const ty = a.ty;\n\n        const a2 = b.a;\n        const b2 = b.b;\n        const c2 = b.c;\n        const d2 = b.d;\n\n        this.a = (a1 * a2) + (b1 * c2);\n        this.b = (a1 * b2) + (b1 * d2);\n        this.c = (c1 * a2) + (d1 * c2);\n        this.d = (c1 * b2) + (d1 * d2);\n        this.tx = (tx * a2) + (ty * c2) + b.tx;\n        this.ty = (tx * b2) + (ty * d2) + b.ty;\n\n        return this;\n    }\n\n    /**\n     * Sets the matrix based on all the available properties.\n     * Combines position, scale, rotation, skew and pivot in a single operation.\n     * @example\n     * ```ts\n     * // Basic transform setup\n     * const matrix = new Matrix();\n     * matrix.setTransform(\n     *     100, 100,    // position\n     *     0, 0,        // pivot\n     *     2, 2,        // scale\n     *     Math.PI / 4, // rotation (45 degrees)\n     *     0, 0         // skew\n     * );\n     * ```\n     * @remarks\n     * - Updates all matrix components at once\n     * - More efficient than separate transform calls\n     * - Uses radians for rotation and skew\n     * - Pivot affects rotation center\n     * @param x - Position on the x axis\n     * @param y - Position on the y axis\n     * @param pivotX - Pivot on the x axis\n     * @param pivotY - Pivot on the y axis\n     * @param scaleX - Scale on the x axis\n     * @param scaleY - Scale on the y axis\n     * @param rotation - Rotation in radians\n     * @param skewX - Skew on the x axis\n     * @param skewY - Skew on the y axis\n     * @returns This matrix. Good for chaining method calls.\n     * @see {@link Matrix.decompose} For extracting transform properties\n     * @see {@link TransformableObject} For transform data structure\n     */\n    public setTransform(x: number, y: number, pivotX: number, pivotY: number, scaleX: number,\n        scaleY: number, rotation: number, skewX: number, skewY: number): this\n    {\n        this.a = Math.cos(rotation + skewY) * scaleX;\n        this.b = Math.sin(rotation + skewY) * scaleX;\n        this.c = -Math.sin(rotation - skewX) * scaleY;\n        this.d = Math.cos(rotation - skewX) * scaleY;\n\n        this.tx = x - ((pivotX * this.a) + (pivotY * this.c));\n        this.ty = y - ((pivotX * this.b) + (pivotY * this.d));\n\n        return this;\n    }\n\n    /**\n     * Prepends the given Matrix to this Matrix.\n     * Combines two matrices by multiplying them together: this = matrix * this\n     * @example\n     * ```ts\n     * // Basic matrix prepend\n     * const matrix = new Matrix().scale(2, 2);\n     * const other = new Matrix().translate(100, 0);\n     * matrix.prepend(other); // Translation happens before scaling\n     * ```\n     * @remarks\n     * - Order matters: A.prepend(B) !== B.prepend(A)\n     * - Modifies current matrix\n     * - Reverses transformation order compared to append()\n     * @param matrix - The matrix to prepend\n     * @returns This matrix. Good for chaining method calls.\n     * @see {@link Matrix.append} For appending transformations\n     * @see {@link Matrix.appendFrom} For combining external matrices\n     */\n    public prepend(matrix: Matrix): this\n    {\n        const tx1 = this.tx;\n\n        if (matrix.a !== 1 || matrix.b !== 0 || matrix.c !== 0 || matrix.d !== 1)\n        {\n            const a1 = this.a;\n            const c1 = this.c;\n\n            this.a = (a1 * matrix.a) + (this.b * matrix.c);\n            this.b = (a1 * matrix.b) + (this.b * matrix.d);\n            this.c = (c1 * matrix.a) + (this.d * matrix.c);\n            this.d = (c1 * matrix.b) + (this.d * matrix.d);\n        }\n\n        this.tx = (tx1 * matrix.a) + (this.ty * matrix.c) + matrix.tx;\n        this.ty = (tx1 * matrix.b) + (this.ty * matrix.d) + matrix.ty;\n\n        return this;\n    }\n\n    /**\n     * Decomposes the matrix into its individual transform components.\n     * Extracts position, scale, rotation and skew values from the matrix.\n     * @example\n     * ```ts\n     * // Basic decomposition\n     * const matrix = new Matrix()\n     *     .translate(100, 100)\n     *     .rotate(Math.PI / 4)\n     *     .scale(2, 2);\n     *\n     * const transform = {\n     *     position: new Point(),\n     *     scale: new Point(),\n     *     pivot: new Point(),\n     *     skew: new Point(),\n     *     rotation: 0\n     * };\n     *\n     * matrix.decompose(transform);\n     * console.log(transform.position); // Point(100, 100)\n     * console.log(transform.rotation); // ~0.785 (PI/4)\n     * console.log(transform.scale); // Point(2, 2)\n     * ```\n     * @remarks\n     * - Handles combined transformations\n     * - Accounts for pivot points\n     * - Chooses between rotation/skew based on transform type\n     * - Uses radians for rotation and skew\n     * @param transform - The transform object to store the decomposed values\n     * @returns The transform with the newly applied properties\n     * @see {@link Matrix.setTransform} For composing from components\n     * @see {@link TransformableObject} For transform structure\n     */\n    public decompose(transform: TransformableObject): TransformableObject\n    {\n        // sort out rotation / skew..\n        const a = this.a;\n        const b = this.b;\n        const c = this.c;\n        const d = this.d;\n        const pivot = transform.pivot;\n\n        const skewX = -Math.atan2(-c, d);\n        const skewY = Math.atan2(b, a);\n\n        const delta = Math.abs(skewX + skewY);\n\n        if (delta < 0.00001 || Math.abs(PI_2 - delta) < 0.00001)\n        {\n            transform.rotation = skewY;\n            transform.skew.x = transform.skew.y = 0;\n        }\n        else\n        {\n            transform.rotation = 0;\n            transform.skew.x = skewX;\n            transform.skew.y = skewY;\n        }\n\n        // next set scale\n        transform.scale.x = Math.sqrt((a * a) + (b * b));\n        transform.scale.y = Math.sqrt((c * c) + (d * d));\n\n        // next set position\n        transform.position.x = this.tx + ((pivot.x * a) + (pivot.y * c));\n        transform.position.y = this.ty + ((pivot.x * b) + (pivot.y * d));\n\n        return transform;\n    }\n\n    /**\n     * Inverts this matrix.\n     * Creates the matrix that when multiplied with this matrix results in an identity matrix.\n     * @example\n     * ```ts\n     * // Basic matrix inversion\n     * const matrix = new Matrix()\n     *     .translate(100, 50)\n     *     .scale(2, 2);\n     *\n     * matrix.invert(); // Now transforms in opposite direction\n     *\n     * // Verify inversion\n     * const point = new Point(50, 50);\n     * const transformed = matrix.apply(point);\n     * const original = matrix.invert().apply(transformed);\n     * // original â‰ˆ point\n     * ```\n     * @remarks\n     * - Modifies the current matrix\n     * - Useful for reversing transformations\n     * - Cannot invert matrices with zero determinant\n     * @returns This matrix. Good for chaining method calls.\n     * @see {@link Matrix.identity} For resetting to identity\n     * @see {@link Matrix.applyInverse} For inverse transformations\n     */\n    public invert(): this\n    {\n        const a1 = this.a;\n        const b1 = this.b;\n        const c1 = this.c;\n        const d1 = this.d;\n        const tx1 = this.tx;\n        const n = (a1 * d1) - (b1 * c1);\n\n        this.a = d1 / n;\n        this.b = -b1 / n;\n        this.c = -c1 / n;\n        this.d = a1 / n;\n        this.tx = ((c1 * this.ty) - (d1 * tx1)) / n;\n        this.ty = -((a1 * this.ty) - (b1 * tx1)) / n;\n\n        return this;\n    }\n\n    /**\n     * Checks if this matrix is an identity matrix.\n     *\n     * An identity matrix has no transformations applied (default state).\n     * @example\n     * ```ts\n     * // Check if matrix is identity\n     * const matrix = new Matrix();\n     * console.log(matrix.isIdentity()); // true\n     *\n     * // Check after transformations\n     * matrix.translate(100, 0);\n     * console.log(matrix.isIdentity()); // false\n     *\n     * // Reset and verify\n     * matrix.identity();\n     * console.log(matrix.isIdentity()); // true\n     * ```\n     * @remarks\n     * - Verifies a = 1, d = 1 (no scale)\n     * - Verifies b = 0, c = 0 (no skew)\n     * - Verifies tx = 0, ty = 0 (no translation)\n     * @returns True if matrix has no transformations\n     * @see {@link Matrix.identity} For resetting to identity\n     * @see {@link Matrix.IDENTITY} For constant identity matrix\n     */\n    public isIdentity(): boolean\n    {\n        return this.a === 1 && this.b === 0 && this.c === 0 && this.d === 1 && this.tx === 0 && this.ty === 0;\n    }\n\n    /**\n     * Resets this Matrix to an identity (default) matrix.\n     * Sets all components to their default values: scale=1, no skew, no translation.\n     * @example\n     * ```ts\n     * // Reset transformed matrix\n     * const matrix = new Matrix()\n     *     .scale(2, 2)\n     *     .rotate(Math.PI / 4);\n     * matrix.identity(); // Back to default state\n     *\n     * // Chain after reset\n     * matrix\n     *     .identity()\n     *     .translate(100, 100)\n     *     .scale(2, 2);\n     *\n     * // Compare with identity constant\n     * const isDefault = matrix.equals(Matrix.IDENTITY);\n     * ```\n     * @remarks\n     * - Sets a=1, d=1 (default scale)\n     * - Sets b=0, c=0 (no skew)\n     * - Sets tx=0, ty=0 (no translation)\n     * @returns This matrix. Good for chaining method calls.\n     * @see {@link Matrix.IDENTITY} For constant identity matrix\n     * @see {@link Matrix.isIdentity} For checking identity state\n     */\n    public identity(): this\n    {\n        this.a = 1;\n        this.b = 0;\n        this.c = 0;\n        this.d = 1;\n        this.tx = 0;\n        this.ty = 0;\n\n        return this;\n    }\n\n    /**\n     * Creates a new Matrix object with the same values as this one.\n     * @returns A copy of this matrix. Good for chaining method calls.\n     */\n    public clone(): Matrix\n    {\n        const matrix = new Matrix();\n\n        matrix.a = this.a;\n        matrix.b = this.b;\n        matrix.c = this.c;\n        matrix.d = this.d;\n        matrix.tx = this.tx;\n        matrix.ty = this.ty;\n\n        return matrix;\n    }\n\n    /**\n     * Creates a new Matrix object with the same values as this one.\n     * @param matrix\n     * @example\n     * ```ts\n     * // Basic matrix cloning\n     * const matrix = new Matrix()\n     *     .translate(100, 100)\n     *     .rotate(Math.PI / 4);\n     * const copy = matrix.clone();\n     *\n     * // Clone and modify\n     * const modified = matrix.clone()\n     *     .scale(2, 2);\n     *\n     * // Compare matrices\n     * console.log(matrix.equals(copy));     // true\n     * console.log(matrix.equals(modified)); // false\n     * ```\n     * @returns A copy of this matrix. Good for chaining method calls.\n     * @see {@link Matrix.copyTo} For copying to existing matrix\n     * @see {@link Matrix.copyFrom} For copying from another matrix\n     */\n    public copyTo(matrix: Matrix): Matrix\n    {\n        matrix.a = this.a;\n        matrix.b = this.b;\n        matrix.c = this.c;\n        matrix.d = this.d;\n        matrix.tx = this.tx;\n        matrix.ty = this.ty;\n\n        return matrix;\n    }\n\n    /**\n     * Changes the values of the matrix to be the same as the ones in given matrix.\n     * @example\n     * ```ts\n     * // Basic matrix copying\n     * const source = new Matrix()\n     *     .translate(100, 100)\n     *     .rotate(Math.PI / 4);\n     * const target = new Matrix();\n     * target.copyFrom(source);\n     * ```\n     * @param matrix - The matrix to copy from\n     * @returns This matrix. Good for chaining method calls.\n     * @see {@link Matrix.clone} For creating new matrix copy\n     * @see {@link Matrix.copyTo} For copying to another matrix\n     */\n    public copyFrom(matrix: Matrix): this\n    {\n        this.a = matrix.a;\n        this.b = matrix.b;\n        this.c = matrix.c;\n        this.d = matrix.d;\n        this.tx = matrix.tx;\n        this.ty = matrix.ty;\n\n        return this;\n    }\n\n    /**\n     * Checks if this matrix equals another matrix.\n     * Compares all components for exact equality.\n     * @example\n     * ```ts\n     * // Basic equality check\n     * const m1 = new Matrix();\n     * const m2 = new Matrix();\n     * console.log(m1.equals(m2)); // true\n     *\n     * // Compare transformed matrices\n     * const transform = new Matrix()\n     *     .translate(100, 100)\n     * const clone = new Matrix()\n     *     .scale(2, 2);\n     * console.log(transform.equals(clone)); // false\n     * ```\n     * @param matrix - The matrix to compare to\n     * @returns True if matrices are identical\n     * @see {@link Matrix.copyFrom} For copying matrix values\n     * @see {@link Matrix.isIdentity} For identity comparison\n     */\n    public equals(matrix: Matrix)\n    {\n        return matrix.a === this.a && matrix.b === this.b\n            && matrix.c === this.c && matrix.d === this.d\n            && matrix.tx === this.tx && matrix.ty === this.ty;\n    }\n\n    // #if _DEBUG\n    public toString(): string\n    {\n        return `[pixi.js:Matrix a=${this.a} b=${this.b} c=${this.c} d=${this.d} tx=${this.tx} ty=${this.ty}]`;\n    }\n    // #endif\n\n    /**\n     * A default (identity) matrix with no transformations applied.\n     *\n     * > [!IMPORTANT] This is a shared read-only object. Create a new Matrix if you need to modify it.\n     * @example\n     * ```ts\n     * // Get identity matrix reference\n     * const identity = Matrix.IDENTITY;\n     * console.log(identity.isIdentity()); // true\n     *\n     * // Compare with identity\n     * const matrix = new Matrix();\n     * console.log(matrix.equals(Matrix.IDENTITY)); // true\n     *\n     * // Create new matrix instead of modifying IDENTITY\n     * const transform = new Matrix()\n     *     .copyFrom(Matrix.IDENTITY)\n     *     .translate(100, 100);\n     * ```\n     * @readonly\n     * @returns A read-only identity matrix\n     * @see {@link Matrix.shared} For temporary calculations\n     * @see {@link Matrix.identity} For resetting matrices\n     */\n    static get IDENTITY(): Readonly<Matrix>\n    {\n        return identityMatrix.identity();\n    }\n\n    /**\n     * A static Matrix that can be used to avoid creating new objects.\n     * Will always ensure the matrix is reset to identity when requested.\n     *\n     * > [!IMPORTANT] This matrix is shared and temporary. Do not store references to it.\n     * @example\n     * ```ts\n     * // Use for temporary calculations\n     * const tempMatrix = Matrix.shared;\n     * tempMatrix.translate(100, 100).rotate(Math.PI / 4);\n     * const point = tempMatrix.apply({ x: 10, y: 20 });\n     *\n     * // Will be reset to identity on next access\n     * const fresh = Matrix.shared; // Back to identity\n     * ```\n     * @remarks\n     * - Always returns identity matrix\n     * - Safe to modify temporarily\n     * - Not safe to store references\n     * - Useful for one-off calculations\n     * @readonly\n     * @returns A fresh identity matrix for temporary use\n     * @see {@link Matrix.IDENTITY} For immutable identity matrix\n     * @see {@link Matrix.identity} For resetting matrices\n     */\n    static get shared(): Matrix\n    {\n        return tempMatrix.identity();\n    }\n}\n\nconst tempMatrix = new Matrix();\nconst identityMatrix = new Matrix();\n"],"names":["Point","PI_2"],"mappings":"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"}
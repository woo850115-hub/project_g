{"version":3,"file":"ColorDodgeBlend.mjs","sources":["../../src/advanced-blend-modes/ColorDodgeBlend.ts"],"sourcesContent":["/* eslint-disable max-len */\n\nimport { ExtensionType } from '../extensions/Extensions';\nimport { BlendModeFilter } from '../filters/blend-modes/BlendModeFilter';\n\nimport type { ExtensionMetadata } from '../extensions/Extensions';\n\n/**\n * The final color is the result of dividing the bottom color by the inverse of the top color.\n * A black foreground leads to no change.\n * A foreground with the inverse color of the backdrop leads to a fully lit color.\n * This blend mode is similar to screen, but the foreground need only be as light as the inverse of the backdrop to create a fully lit color.\n *\n * Available as `container.blendMode = 'color-dodge'` after importing `pixi.js/advanced-blend-modes`.\n * @example\n * import 'pixi.js/advanced-blend-modes';\n * import { Sprite } from 'pixi.js';\n *\n * const sprite = Sprite.from('something.png');\n * sprite.blendMode = 'color-dodge'\n * @category filters\n * @noInheritDoc\n */\nexport class ColorDodgeBlend extends BlendModeFilter\n{\n    /** @ignore */\n    public static extension: ExtensionMetadata = {\n        name: 'color-dodge',\n        type: ExtensionType.BlendMode\n    };\n\n    constructor()\n    {\n        super({\n            gl: {\n                functions: `\n                float colorDodge(float base, float blend)\n                {\n                    return base / (1.0 - blend);\n                }\n\n                vec3 blendColorDodge(vec3 base, vec3 blend, float opacity)\n                {\n                    vec3 blended = vec3(\n                        colorDodge(base.r, blend.r),\n                        colorDodge(base.g, blend.g),\n                        colorDodge(base.b, blend.b)\n                    );\n\n                    return (blended * opacity + base * (1.0 - opacity));\n                }\n                `,\n                main: `\n                finalColor = vec4(blendColorDodge(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;\n                `\n            },\n            gpu: {\n                functions: `\n                fn colorDodge(base: f32, blend: f32) -> f32\n                {\n                    return base / (1.0 - blend);\n                }\n\n                fn blendColorDodge(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>\n                {\n                    let blended = vec3<f32>(\n                        colorDodge(base.r, blend.r),\n                        colorDodge(base.g, blend.g),\n                        colorDodge(base.b, blend.b)\n                    );\n\n                    return (blended * opacity + base * (1.0 - opacity));\n                }\n                `,\n                main: `\n                    out = vec4<f32>(blendColorDodge(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;\n                `,\n            }\n        });\n    }\n}\n"],"names":[],"mappings":";;;;AAuBO,MAAM,wBAAwB,eAAA,CACrC;AAAA,EAOI,WAAA,GACA;AACI,IAAA,KAAA,CAAM;AAAA,MACF,EAAA,EAAI;AAAA,QACA,SAAA,EAAW;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA,gBAAA,CAAA;AAAA,QAiBX,IAAA,EAAM;AAAA;AAAA,gBAAA;AAAA,OAGV;AAAA,MACA,GAAA,EAAK;AAAA,QACD,SAAA,EAAW;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA,gBAAA,CAAA;AAAA,QAiBX,IAAA,EAAM;AAAA;AAAA,gBAAA;AAAA;AAGV,KACH,CAAA;AAAA,EACL;AACJ;AAAA;AAzDa,eAAA,CAGK,SAAA,GAA+B;AAAA,EACzC,IAAA,EAAM,aAAA;AAAA,EACN,MAAM,aAAA,CAAc;AACxB,CAAA;;;;"}
{"version":3,"file":"loadKTX2.mjs","sources":["../../../src/compressed-textures/ktx2/loadKTX2.ts"],"sourcesContent":["import { LoaderParserPriority } from '../../assets/loader/parsers/LoaderParser';\nimport { createTexture } from '../../assets/loader/parsers/textures/utils/createTexture';\nimport { checkExtension } from '../../assets/utils/checkExtension';\nimport { ExtensionType } from '../../extensions/Extensions';\nimport { CompressedSource } from '../../rendering/renderers/shared/texture/sources/CompressedSource';\nimport { getSupportedTextureFormats } from '../../rendering/renderers/shared/texture/utils/getSupportedTextureFormats';\nimport { loadKTX2onWorker } from './worker/loadKTX2onWorker';\n\nimport type { Loader } from '../../assets/loader/Loader';\nimport type { LoaderParser } from '../../assets/loader/parsers/LoaderParser';\nimport type { ResolvedAsset } from '../../assets/types';\nimport type { TextureSourceOptions } from '../../rendering/renderers/shared/texture/sources/TextureSource';\nimport type { Texture } from '../../rendering/renderers/shared/texture/Texture';\n\n/**\n * Loader parser for KTX2 textures.\n * This parser loads KTX2 textures using a web worker for transcoding.\n * It supports both single and multiple textures.\n * @category assets\n * @advanced\n */\nexport const loadKTX2 = {\n    extension: {\n        type: ExtensionType.LoadParser,\n        priority: LoaderParserPriority.High,\n        name: 'loadKTX2',\n    },\n\n    /** used for deprecation purposes */\n    name: 'loadKTX2',\n    id: 'ktx2',\n\n    test(url: string): boolean\n    {\n        return checkExtension(url, '.ktx2');\n    },\n\n    async load(url: string, _asset: ResolvedAsset, loader: Loader): Promise<Texture | Texture[]>\n    {\n        const supportedTextures = await getSupportedTextureFormats();\n\n        const textureOptions = await loadKTX2onWorker(url, supportedTextures);\n\n        const compressedTextureSource = new CompressedSource(textureOptions);\n\n        return createTexture(compressedTextureSource, loader, url);\n    },\n\n    async unload(texture: Texture | Texture[]): Promise<void>\n    {\n        if (Array.isArray(texture))\n        {\n            texture.forEach((t) => t.destroy(true));\n        }\n        else\n        {\n            texture.destroy(true);\n        }\n    }\n\n} satisfies LoaderParser<Texture | Texture[], TextureSourceOptions>;\n\n"],"names":[],"mappings":";;;;;;;;;AAqBO,MAAM,QAAA,GAAW;AAAA,EACpB,SAAA,EAAW;AAAA,IACP,MAAM,aAAA,CAAc,UAAA;AAAA,IACpB,UAAU,oBAAA,CAAqB,IAAA;AAAA,IAC/B,IAAA,EAAM;AAAA,GACV;AAAA;AAAA,EAGA,IAAA,EAAM,UAAA;AAAA,EACN,EAAA,EAAI,MAAA;AAAA,EAEJ,KAAK,GAAA,EACL;AACI,IAAA,OAAO,cAAA,CAAe,KAAK,OAAO,CAAA;AAAA,EACtC,CAAA;AAAA,EAEA,MAAM,IAAA,CAAK,GAAA,EAAa,MAAA,EAAuB,MAAA,EAC/C;AACI,IAAA,MAAM,iBAAA,GAAoB,MAAM,0BAAA,EAA2B;AAE3D,IAAA,MAAM,cAAA,GAAiB,MAAM,gBAAA,CAAiB,GAAA,EAAK,iBAAiB,CAAA;AAEpE,IAAA,MAAM,uBAAA,GAA0B,IAAI,gBAAA,CAAiB,cAAc,CAAA;AAEnE,IAAA,OAAO,aAAA,CAAc,uBAAA,EAAyB,MAAA,EAAQ,GAAG,CAAA;AAAA,EAC7D,CAAA;AAAA,EAEA,MAAM,OAAO,OAAA,EACb;AACI,IAAA,IAAI,KAAA,CAAM,OAAA,CAAQ,OAAO,CAAA,EACzB;AACI,MAAA,OAAA,CAAQ,QAAQ,CAAC,CAAA,KAAM,CAAA,CAAE,OAAA,CAAQ,IAAI,CAAC,CAAA;AAAA,IAC1C,CAAA,MAEA;AACI,MAAA,OAAA,CAAQ,QAAQ,IAAI,CAAA;AAAA,IACxB;AAAA,EACJ;AAEJ;;;;"}
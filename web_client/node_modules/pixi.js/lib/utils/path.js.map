{"version":3,"file":"path.js","sources":["../../src/utils/path.ts"],"sourcesContent":["import { DOMAdapter } from '../environment/adapter';\n\nfunction assertPath(path: string)\n{\n    if (typeof path !== 'string')\n    {\n        throw new TypeError(`Path must be a string. Received ${JSON.stringify(path)}`);\n    }\n}\n\nfunction removeUrlParams(url: string): string\n{\n    const re = url.split('?')[0];\n\n    return re.split('#')[0];\n}\n\nfunction escapeRegExp(string: string)\n{\n    return string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'); // $& means the whole matched string\n}\n\nfunction replaceAll(str: string, find: string, replace: string)\n{\n    return str.replace(new RegExp(escapeRegExp(find), 'g'), replace);\n}\n\n// Resolves . and .. elements in a path with directory names\nfunction normalizeStringPosix(path: string, allowAboveRoot: boolean)\n{\n    let res = '';\n    let lastSegmentLength = 0;\n    let lastSlash = -1;\n    let dots = 0;\n    let code = -1;\n\n    for (let i = 0; i <= path.length; ++i)\n    {\n        if (i < path.length)\n        {\n            code = path.charCodeAt(i);\n        }\n        else if (code === 47)\n        {\n            break;\n        }\n        else\n        {\n            code = 47;\n        }\n        if (code === 47)\n        {\n            if (lastSlash === i - 1 || dots === 1)\n            {\n                // NOOP\n            }\n            else if (lastSlash !== i - 1 && dots === 2)\n            {\n                if (\n                    res.length < 2\n                    || lastSegmentLength !== 2\n                    || res.charCodeAt(res.length - 1) !== 46\n                    || res.charCodeAt(res.length - 2) !== 46\n                )\n                {\n                    if (res.length > 2)\n                    {\n                        const lastSlashIndex = res.lastIndexOf('/');\n\n                        if (lastSlashIndex !== res.length - 1)\n                        {\n                            if (lastSlashIndex === -1)\n                            {\n                                res = '';\n                                lastSegmentLength = 0;\n                            }\n                            else\n                            {\n                                res = res.slice(0, lastSlashIndex);\n                                lastSegmentLength = res.length - 1 - res.lastIndexOf('/');\n                            }\n                            lastSlash = i;\n                            dots = 0;\n                            continue;\n                        }\n                    }\n                    else if (res.length === 2 || res.length === 1)\n                    {\n                        res = '';\n                        lastSegmentLength = 0;\n                        lastSlash = i;\n                        dots = 0;\n                        continue;\n                    }\n                }\n                if (allowAboveRoot)\n                {\n                    if (res.length > 0)\n                    { res += '/..'; }\n                    else\n                    { res = '..'; }\n                    lastSegmentLength = 2;\n                }\n            }\n            else\n            {\n                if (res.length > 0)\n                {\n                    res += `/${path.slice(lastSlash + 1, i)}`;\n                }\n                else\n                {\n                    res = path.slice(lastSlash + 1, i);\n                }\n                lastSegmentLength = i - lastSlash - 1;\n            }\n            lastSlash = i;\n            dots = 0;\n        }\n        else if (code === 46 && dots !== -1)\n        {\n            ++dots;\n        }\n        else\n        {\n            dots = -1;\n        }\n    }\n\n    return res;\n}\n\n/**\n * Path utilities for working with URLs and file paths in a cross-platform way.\n * All paths that are passed in will become normalized to have posix separators.\n * ```js\n * import { path } from 'pixi.js';\n *\n * path.normalize('http://www.example.com/foo/bar/../baz'); // http://www.example.com/foo/baz\n * ```\n * @category utils\n * @advanced\n */\nexport interface Path\n{\n    /**\n     * Converts a path to posix format.\n     * @param path - The path to convert to posix\n     */\n    toPosix: (path: string) => string;\n    /**\n     * Checks if the path is a URL e.g. http://, https://\n     * @param path - The path to check\n     */\n    isUrl: (path: string) => boolean;\n    /**\n     * Checks if the path is a data URL\n     * @param path - The path to check\n     */\n    isDataUrl: (path: string) => boolean;\n    /**\n     * Checks if the path is a blob URL\n     * @param path - The path to check\n     */\n    isBlobUrl: (path: string) => boolean;\n    /**\n     * Checks if the path has a protocol e.g. http://, https://, file:///, data:, blob:, C:/\n     * This will return true for windows file paths\n     * @param path - The path to check\n     */\n    hasProtocol: (path: string) => boolean;\n    /**\n     * Returns the protocol of the path e.g. http://, https://, file:///, data:, blob:, C:/\n     * @param path - The path to get the protocol from\n     */\n    getProtocol: (path: string) => string;\n    /**\n     * Converts URL to an absolute path.\n     * When loading from a Web Worker, we must use absolute paths.\n     * If the URL is already absolute we return it as is\n     * If it's not, we convert it\n     * @param url - The URL to test\n     * @param baseUrl - The base URL to use\n     * @param rootUrl - The root URL to use\n     */\n    toAbsolute: (url: string, baseUrl?: string, rootUrl?: string) => string;\n    /**\n     * Normalizes the given path, resolving '..' and '.' segments\n     * @param path - The path to normalize\n     */\n    normalize: (path: string) => string;\n    /**\n     * Determines if path is an absolute path.\n     * Absolute paths can be urls, data urls, or paths on disk\n     * @param path - The path to test\n     */\n    isAbsolute: (path: string) => boolean;\n    /**\n     * Joins all given path segments together using the platform-specific separator as a delimiter,\n     * then normalizes the resulting path\n     * @param paths - The segments of the path to join\n     */\n    join: (...paths: string[]) => string;\n    /**\n     * Returns the directory name of a path\n     * @param path - The path to parse\n     */\n    dirname: (path: string) => string;\n    /**\n     * Returns the root of the path e.g. /, C:/, file:///, http://domain.com/\n     * @param path - The path to parse\n     */\n    rootname: (path: string) => string;\n    /**\n     * Returns the last portion of a path\n     * @param path - The path to test\n     * @param ext - Optional extension to remove\n     */\n    basename: (path: string, ext?: string) => string;\n    /**\n     * Returns the extension of the path, from the last occurrence of the . (period) character to end of string in the last\n     * portion of the path. If there is no . in the last portion of the path, or if there are no . characters other than\n     * the first character of the basename of path, an empty string is returned.\n     * @param path - The path to parse\n     */\n    extname: (path: string) => string;\n    /**\n     * Parses a path into an object containing the 'root', `dir`, `base`, `ext`, and `name` properties.\n     * @param path - The path to parse\n     */\n    parse: (path: string) => { root?: string, dir?: string, base?: string, ext?: string, name?: string };\n    sep: string,\n    delimiter: string,\n    joinExtensions: string[],\n}\n\n/**\n * Path utilities for working with URLs and file paths in a cross-platform way.\n * All paths that are passed in will become normalized to have posix separators.\n * @example\n * ```ts\n * import { path } from 'pixi.js';\n *\n * // Basic path normalization\n * path.normalize('http://www.example.com/foo/bar/../baz');\n * // -> 'http://www.example.com/foo/baz'\n *\n * // Working with file paths\n * path.join('assets', 'images', 'sprite.png');\n * // -> 'assets/images/sprite.png'\n *\n * // URL handling\n * path.toAbsolute('images/texture.png', 'http://example.com/assets/');\n * // -> 'http://example.com/assets/images/texture.png'\n * ```\n * @remarks\n * - Normalizes to POSIX separators (forward slashes)\n * - Handles URLs, data URLs, and file paths\n * - Supports path composition and decomposition\n * - Common in asset loading and URL management\n * @category utils\n * @standard\n * @see {@link Path} For full API reference\n * @see {@link DOMAdapter} For platform-specific path handling\n */\nexport const path: Path = {\n    /**\n     * Converts a path to posix format.\n     * @param path - The path to convert to posix\n     * @example\n     * ```ts\n     * // Convert a Windows path to POSIX format\n     * path.toPosix('C:\\\\Users\\\\User\\\\Documents\\\\file.txt');\n     * // -> 'C:/Users/User/Documents/file.txt'\n     * ```\n     */\n    toPosix(path: string) { return replaceAll(path, '\\\\', '/'); },\n    /**\n     * Checks if the path is a URL e.g. http://, https://\n     * @param path - The path to check\n     * @example\n     * ```ts\n     * // Check if a path is a URL\n     * path.isUrl('http://www.example.com');\n     * // -> true\n     * path.isUrl('C:/Users/User/Documents/file.txt');\n     * // -> false\n     * ```\n     */\n    isUrl(path: string) { return (/^https?:/).test(this.toPosix(path)); },\n    /**\n     * Checks if the path is a data URL\n     * @param path - The path to check\n     * @example\n     * ```ts\n     * // Check if a path is a data URL\n     * path.isDataUrl('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUA...');\n     * // -> true\n     * ```\n     */\n    isDataUrl(path: string)\n    {\n        // eslint-disable-next-line max-len\n        return (/^data:([a-z]+\\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!$&',()*+;=\\-._~:@\\/?%\\s<>]*?)$/i)\n            .test(path);\n    },\n    /**\n     * Checks if the path is a blob URL\n     * @param path - The path to check\n     * @example\n     * ```ts\n     * // Check if a path is a blob URL\n     * path.isBlobUrl('blob:http://www.example.com/12345678-1234-1234-1234-123456789012');\n     * // -> true\n     * ```\n     */\n    isBlobUrl(path: string)\n    {\n        // Not necessary to have an exact regex to match the blob URLs\n        return path.startsWith('blob:');\n    },\n    /**\n     * Checks if the path has a protocol e.g. http://, https://, file:///, data:, blob:, C:/\n     * This will return true for windows file paths\n     * @param path - The path to check\n     * @example\n     * ```ts\n     * // Check if a path has a protocol\n     * path.hasProtocol('http://www.example.com');\n     * // -> true\n     * path.hasProtocol('C:/Users/User/Documents/file.txt');\n     * // -> true\n     * ```\n     */\n    hasProtocol(path: string) { return (/^[^/:]+:/).test(this.toPosix(path)); },\n    /**\n     * Returns the protocol of the path e.g. http://, https://, file:///, data:, blob:, C:/\n     * @param path - The path to get the protocol from\n     * @example\n     * ```ts\n     * // Get the protocol from a URL\n     * path.getProtocol('http://www.example.com/path/to/resource');\n     * // -> 'http://'\n     * // Get the protocol from a file path\n     * path.getProtocol('C:/Users/User/Documents/file.txt');\n     * // -> 'C:/'\n     * ```\n     */\n    getProtocol(path: string)\n    {\n        assertPath(path);\n        path = this.toPosix(path);\n\n        const matchFile = (/^file:\\/\\/\\//).exec(path);\n\n        if (matchFile)\n        {\n            return matchFile[0];\n        }\n\n        const matchProtocol = (/^[^/:]+:\\/{0,2}/).exec(path);\n\n        if (matchProtocol)\n        {\n            return matchProtocol[0];\n        }\n\n        return '';\n    },\n\n    /**\n     * Converts URL to an absolute path.\n     * When loading from a Web Worker, we must use absolute paths.\n     * If the URL is already absolute we return it as is\n     * If it's not, we convert it\n     * @param url - The URL to test\n     * @param customBaseUrl - The base URL to use\n     * @param customRootUrl - The root URL to use\n     * @example\n     * ```ts\n     * // Convert a relative URL to an absolute path\n     * path.toAbsolute('images/texture.png', 'http://example.com/assets/');\n     * // -> 'http://example.com/assets/images/texture.png'\n     * ```\n     */\n    toAbsolute(url: string, customBaseUrl?: string, customRootUrl?: string)\n    {\n        assertPath(url);\n\n        if (this.isDataUrl(url) || this.isBlobUrl(url)) return url;\n\n        const baseUrl = removeUrlParams(this.toPosix(customBaseUrl ?? DOMAdapter.get().getBaseUrl()));\n        const rootUrl = removeUrlParams(this.toPosix(customRootUrl ?? this.rootname(baseUrl)));\n\n        url = this.toPosix(url);\n\n        // root relative url\n        if (url.startsWith('/'))\n        {\n            return path.join(rootUrl, url.slice(1));\n        }\n\n        const absolutePath = this.isAbsolute(url) ? url : this.join(baseUrl, url);\n\n        return absolutePath;\n    },\n\n    /**\n     * Normalizes the given path, resolving '..' and '.' segments\n     * @param path - The path to normalize\n     * @example\n     * ```ts\n     * // Normalize a path with relative segments\n     * path.normalize('http://www.example.com/foo/bar/../baz');\n     * // -> 'http://www.example.com/foo/baz'\n     * // Normalize a file path with relative segments\n     * path.normalize('C:\\\\Users\\\\User\\\\Documents\\\\..\\\\file.txt');\n     * // -> 'C:/Users/User/file.txt'\n     * ```\n     */\n    normalize(path: string)\n    {\n        assertPath(path);\n\n        if (path.length === 0) return '.';\n        if (this.isDataUrl(path) || this.isBlobUrl(path)) return path;\n\n        path = this.toPosix(path);\n\n        let protocol = '';\n        const isAbsolute = path.startsWith('/');\n\n        if (this.hasProtocol(path))\n        {\n            protocol = this.rootname(path);\n            path = path.slice(protocol.length);\n        }\n\n        const trailingSeparator = path.endsWith('/');\n\n        // Normalize the path\n        path = normalizeStringPosix(path, false);\n\n        if (path.length > 0 && trailingSeparator) path += '/';\n        if (isAbsolute) return `/${path}`;\n\n        return protocol + path;\n    },\n\n    /**\n     * Determines if path is an absolute path.\n     * Absolute paths can be urls, data urls, or paths on disk\n     * @param path - The path to test\n     * @example\n     * ```ts\n     * // Check if a path is absolute\n     * path.isAbsolute('http://www.example.com/foo/bar');\n     * // -> true\n     * path.isAbsolute('C:/Users/User/Documents/file.txt');\n     * // -> true\n     * ```\n     */\n    isAbsolute(path: string)\n    {\n        assertPath(path);\n        path = this.toPosix(path);\n\n        if (this.hasProtocol(path)) return true;\n\n        return path.startsWith('/');\n    },\n\n    /**\n     * Joins all given path segments together using the platform-specific separator as a delimiter,\n     * then normalizes the resulting path\n     * @param segments - The segments of the path to join\n     * @example\n     * ```ts\n     * // Join multiple path segments\n     * path.join('assets', 'images', 'sprite.png');\n     * // -> 'assets/images/sprite.png'\n     * // Join with relative segments\n     * path.join('assets', 'images', '../textures', 'sprite.png');\n     * // -> 'assets/textures/sprite.png'\n     * ```\n     */\n    join(...segments: string[])\n    {\n        if (segments.length === 0)\n        { return '.'; }\n        let joined;\n\n        for (let i = 0; i < segments.length; ++i)\n        {\n            const arg = segments[i];\n\n            assertPath(arg);\n            if (arg.length > 0)\n            {\n                if (joined === undefined) joined = arg;\n                else\n                {\n                    const prevArg = segments[i - 1] ?? '';\n\n                    if (this.joinExtensions.includes(this.extname(prevArg).toLowerCase()))\n                    {\n                        joined += `/../${arg}`;\n                    }\n                    else\n                    {\n                        joined += `/${arg}`;\n                    }\n                }\n            }\n        }\n        if (joined === undefined) { return '.'; }\n\n        return this.normalize(joined);\n    },\n\n    /**\n     * Returns the directory name of a path\n     * @param path - The path to parse\n     * @example\n     * ```ts\n     * // Get the directory name of a path\n     * path.dirname('http://www.example.com/foo/bar/baz.png');\n     * // -> 'http://www.example.com/foo/bar'\n     * // Get the directory name of a file path\n     * path.dirname('C:/Users/User/Documents/file.txt');\n     * // -> 'C:/Users/User/Documents'\n     * ```\n     */\n    dirname(path: string)\n    {\n        assertPath(path);\n        if (path.length === 0) return '.';\n        path = this.toPosix(path);\n        let code = path.charCodeAt(0);\n        const hasRoot = code === 47;\n        let end = -1;\n        let matchedSlash = true;\n\n        const proto = this.getProtocol(path);\n        const origpath = path;\n\n        path = path.slice(proto.length);\n\n        for (let i = path.length - 1; i >= 1; --i)\n        {\n            code = path.charCodeAt(i);\n            if (code === 47)\n            {\n                if (!matchedSlash)\n                {\n                    end = i;\n                    break;\n                }\n            }\n            else\n            {\n                // We saw the first non-path separator\n                matchedSlash = false;\n            }\n        }\n\n        // if end is -1 and its a url then we need to add the path back\n        // eslint-disable-next-line no-nested-ternary\n        if (end === -1) return hasRoot ? '/' : this.isUrl(origpath) ? proto + path : proto;\n        if (hasRoot && end === 1) return '//';\n\n        return proto + path.slice(0, end);\n    },\n\n    /**\n     * Returns the root of the path e.g. /, C:/, file:///, http://domain.com/\n     * @param path - The path to parse\n     * @example\n     * ```ts\n     * // Get the root of a URL\n     * path.rootname('http://www.example.com/foo/bar/baz.png');\n     * // -> 'http://www.example.com/'\n     * // Get the root of a file path\n     * path.rootname('C:/Users/User/Documents/file.txt');\n     * // -> 'C:/'\n     * ```\n     */\n    rootname(path: string)\n    {\n        assertPath(path);\n        path = this.toPosix(path);\n\n        let root = '';\n\n        if (path.startsWith('/')) root = '/';\n        else\n        {\n            root = this.getProtocol(path);\n        }\n\n        if (this.isUrl(path))\n        {\n            // need to find the first path separator\n            const index = path.indexOf('/', root.length);\n\n            if (index !== -1)\n            {\n                root = path.slice(0, index);\n            }\n            else root = path;\n\n            if (!root.endsWith('/')) root += '/';\n        }\n\n        return root;\n    },\n\n    /**\n     * Returns the last portion of a path\n     * @param path - The path to test\n     * @param ext - Optional extension to remove\n     * @example\n     * ```ts\n     * // Get the basename of a URL\n     * path.basename('http://www.example.com/foo/bar/baz.png');\n     * // -> 'baz.png'\n     * // Get the basename of a file path\n     * path.basename('C:/Users/User/Documents/file.txt');\n     * // -> 'file.txt'\n     * ```\n     */\n    basename(path: string, ext?: string)\n    {\n        assertPath(path);\n        if (ext) assertPath(ext);\n\n        path = removeUrlParams(this.toPosix(path));\n\n        let start = 0;\n        let end = -1;\n        let matchedSlash = true;\n        let i: number;\n\n        if (ext !== undefined && ext.length > 0 && ext.length <= path.length)\n        {\n            if (ext.length === path.length && ext === path) return '';\n            let extIdx = ext.length - 1;\n            let firstNonSlashEnd = -1;\n\n            for (i = path.length - 1; i >= 0; --i)\n            {\n                const code = path.charCodeAt(i);\n\n                if (code === 47)\n                {\n                    // If we reached a path separator that was not part of a set of path\n                    // separators at the end of the string, stop now\n                    if (!matchedSlash)\n                    {\n                        start = i + 1;\n                        break;\n                    }\n                }\n                else\n                {\n                    if (firstNonSlashEnd === -1)\n                    {\n                        // We saw the first non-path separator, remember this index in case\n                        // we need it if the extension ends up not matching\n                        matchedSlash = false;\n                        firstNonSlashEnd = i + 1;\n                    }\n                    if (extIdx >= 0)\n                    {\n                        // Try to match the explicit extension\n                        if (code === ext.charCodeAt(extIdx))\n                        {\n                            if (--extIdx === -1)\n                            {\n                                // We matched the extension, so mark this as the end of our path\n                                // component\n                                end = i;\n                            }\n                        }\n                        else\n                        {\n                            // Extension does not match, so our result is the entire path\n                            // component\n                            extIdx = -1;\n                            end = firstNonSlashEnd;\n                        }\n                    }\n                }\n            }\n\n            if (start === end) end = firstNonSlashEnd; else if (end === -1) end = path.length;\n\n            return path.slice(start, end);\n        }\n        for (i = path.length - 1; i >= 0; --i)\n        {\n            if (path.charCodeAt(i) === 47)\n            {\n                // If we reached a path separator that was not part of a set of path\n                // separators at the end of the string, stop now\n                if (!matchedSlash)\n                {\n                    start = i + 1;\n                    break;\n                }\n            }\n            else if (end === -1)\n            {\n                // We saw the first non-path separator, mark this as the end of our\n                // path component\n                matchedSlash = false;\n                end = i + 1;\n            }\n        }\n\n        if (end === -1) return '';\n\n        return path.slice(start, end);\n    },\n\n    /**\n     * Returns the extension of the path, from the last occurrence of the . (period) character to end of string in the last\n     * portion of the path. If there is no . in the last portion of the path, or if there are no . characters other than\n     * the first character of the basename of path, an empty string is returned.\n     * @param path - The path to parse\n     * @example\n     * ```ts\n     * // Get the extension of a URL\n     * path.extname('http://www.example.com/foo/bar/baz.png');\n     * // -> '.png'\n     * // Get the extension of a file path\n     * path.extname('C:/Users/User/Documents/file.txt');\n     * // -> '.txt'\n     * ```\n     */\n    extname(path: string)\n    {\n        assertPath(path);\n        path = removeUrlParams(this.toPosix(path));\n\n        let startDot = -1;\n        let startPart = 0;\n        let end = -1;\n        let matchedSlash = true;\n        // Track the state of characters (if any) we see before our first dot and\n        // after any path separator we find\n        let preDotState = 0;\n\n        for (let i = path.length - 1; i >= 0; --i)\n        {\n            const code = path.charCodeAt(i);\n\n            if (code === 47)\n            {\n                // If we reached a path separator that was not part of a set of path\n                // separators at the end of the string, stop now\n                if (!matchedSlash)\n                {\n                    startPart = i + 1;\n                    break;\n                }\n                continue;\n            }\n            if (end === -1)\n            {\n                // We saw the first non-path separator, mark this as the end of our\n                // extension\n                matchedSlash = false;\n                end = i + 1;\n            }\n            if (code === 46)\n            {\n                // If this is our first dot, mark it as the start of our extension\n                if (startDot === -1) startDot = i;\n                else if (preDotState !== 1) preDotState = 1;\n            }\n            else if (startDot !== -1)\n            {\n                // We saw a non-dot and non-path separator before our dot, so we should\n                // have a good chance at having a non-empty extension\n                preDotState = -1;\n            }\n        }\n\n        if (\n            startDot === -1 || end === -1\n            // We saw a non-dot character immediately before the dot\n            || preDotState === 0\n            // The (right-most) trimmed path component is exactly '..'\n            // eslint-disable-next-line no-mixed-operators/no-mixed-operators\n            || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1\n        )\n        {\n            return '';\n        }\n\n        return path.slice(startDot, end);\n    },\n\n    /**\n     * Parses a path into an object containing the 'root', `dir`, `base`, `ext`, and `name` properties.\n     * @param path - The path to parse\n     * @example\n     * ```ts\n     * // Parse a URL\n     * const parsed = path.parse('http://www.example.com/foo/bar/baz.png');\n     * // -> {\n     * //   root: 'http://www.example.com/',\n     * //   dir: 'http://www.example.com/foo/bar',\n     * //   base: 'baz.png',\n     * //   ext: '.png',\n     * //   name: 'baz'\n     * // }\n     * // Parse a file path\n     * const parsedFile = path.parse('C:/Users/User/Documents/file.txt');\n     * // -> {\n     * //   root: 'C:/',\n     * //   dir: 'C:/Users/User/Documents',\n     * //   base: 'file.txt',\n     * //   ext: '.txt',\n     * //   name: 'file'\n     * // }\n     * ```\n     */\n    parse(path: string)\n    {\n        assertPath(path);\n\n        const ret = { root: '', dir: '', base: '', ext: '', name: '' };\n\n        if (path.length === 0) return ret;\n        path = removeUrlParams(this.toPosix(path));\n\n        let code = path.charCodeAt(0);\n        const isAbsolute = this.isAbsolute(path);\n        let start: number;\n        const protocol = '';\n\n        ret.root = this.rootname(path);\n\n        if (isAbsolute || this.hasProtocol(path))\n        {\n            start = 1;\n        }\n        else\n        {\n            start = 0;\n        }\n        let startDot = -1;\n        let startPart = 0;\n        let end = -1;\n        let matchedSlash = true;\n        let i = path.length - 1;\n\n        // Track the state of characters (if any) we see before our first dot and\n        // after any path separator we find\n        let preDotState = 0;\n\n        // Get non-dir info\n        for (; i >= start; --i)\n        {\n            code = path.charCodeAt(i);\n            if (code === 47)\n            {\n                // If we reached a path separator that was not part of a set of path\n                // separators at the end of the string, stop now\n                if (!matchedSlash)\n                {\n                    startPart = i + 1;\n                    break;\n                }\n                continue;\n            }\n            if (end === -1)\n            {\n                // We saw the first non-path separator, mark this as the end of our\n                // extension\n                matchedSlash = false;\n                end = i + 1;\n            }\n            if (code === 46)\n            {\n                // If this is our first dot, mark it as the start of our extension\n                if (startDot === -1) startDot = i;\n                else if (preDotState !== 1) preDotState = 1;\n            }\n            else if (startDot !== -1)\n            {\n                // We saw a non-dot and non-path separator before our dot, so we should\n                // have a good chance at having a non-empty extension\n                preDotState = -1;\n            }\n        }\n\n        if (\n            startDot === -1 || end === -1\n            // We saw a non-dot character immediately before the dot\n            || preDotState === 0\n            // The (right-most) trimmed path component is exactly '..'\n            // eslint-disable-next-line no-mixed-operators/no-mixed-operators\n            || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1\n        )\n        {\n            if (end !== -1)\n            {\n                if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);\n                else ret.base = ret.name = path.slice(startPart, end);\n            }\n        }\n        else\n        {\n            if (startPart === 0 && isAbsolute)\n            {\n                ret.name = path.slice(1, startDot);\n                ret.base = path.slice(1, end);\n            }\n            else\n            {\n                ret.name = path.slice(startPart, startDot);\n                ret.base = path.slice(startPart, end);\n            }\n            ret.ext = path.slice(startDot, end);\n        }\n\n        ret.dir = this.dirname(path);\n        if (protocol) ret.dir = protocol + ret.dir;\n\n        return ret;\n    },\n\n    sep: '/',\n    delimiter: ':',\n    joinExtensions: ['.html'],\n} as Path;\n"],"names":["path","DOMAdapter"],"mappings":"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"}
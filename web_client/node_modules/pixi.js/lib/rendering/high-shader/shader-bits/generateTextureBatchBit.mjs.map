{"version":3,"file":"generateTextureBatchBit.mjs","sources":["../../../../src/rendering/high-shader/shader-bits/generateTextureBatchBit.ts"],"sourcesContent":["import type { HighShaderBit } from '../compiler/types';\n\nconst textureBatchBitGpuCache: Record<number, HighShaderBit> = {};\n\n/**\n *\n * @param maxTextures - the max textures the shader can use.\n * @returns a shader bit that will allow the shader to sample multiple textures AND round pixels.\n */\nfunction generateBindingSrc(maxTextures: number): string\n{\n    const src = [];\n\n    if (maxTextures === 1)\n    {\n        src.push('@group(1) @binding(0) var textureSource1: texture_2d<f32>;');\n        src.push('@group(1) @binding(1) var textureSampler1: sampler;');\n    }\n    else\n    {\n        let bindingIndex = 0;\n\n        for (let i = 0; i < maxTextures; i++)\n        {\n            src.push(`@group(1) @binding(${bindingIndex++}) var textureSource${i + 1}: texture_2d<f32>;`);\n            src.push(`@group(1) @binding(${bindingIndex++}) var textureSampler${i + 1}: sampler;`);\n        }\n    }\n\n    return src.join('\\n');\n}\n\nfunction generateSampleSrc(maxTextures: number): string\n{\n    const src = [];\n\n    if (maxTextures === 1)\n    {\n        src.push('outColor = textureSampleGrad(textureSource1, textureSampler1, vUV, uvDx, uvDy);');\n    }\n    else\n    {\n        src.push('switch vTextureId {');\n\n        for (let i = 0; i < maxTextures; i++)\n        {\n            if (i === maxTextures - 1)\n            {\n                src.push(`  default:{`);\n            }\n            else\n            {\n                src.push(`  case ${i}:{`);\n            }\n            src.push(`      outColor = textureSampleGrad(textureSource${i + 1}, textureSampler${i + 1}, vUV, uvDx, uvDy);`);\n            src.push(`      break;}`);\n        }\n\n        src.push(`}`);\n    }\n\n    return src.join('\\n');\n}\n\n/**\n * @param maxTextures\n * @internal\n */\nexport function generateTextureBatchBit(maxTextures: number): HighShaderBit\n{\n    if (!textureBatchBitGpuCache[maxTextures])\n    {\n        textureBatchBitGpuCache[maxTextures] = {\n            name: 'texture-batch-bit',\n            vertex: {\n                header: `\n                @in aTextureIdAndRound: vec2<u32>;\n                @out @interpolate(flat) vTextureId : u32;\n            `,\n                main: `\n                vTextureId = aTextureIdAndRound.y;\n            `,\n                end: `\n                if(aTextureIdAndRound.x == 1)\n                {\n                    vPosition = vec4<f32>(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n                }\n            `\n            },\n            fragment: {\n                header: `\n                @in @interpolate(flat) vTextureId: u32;\n\n                ${generateBindingSrc(maxTextures)}\n            `,\n                main: `\n                var uvDx = dpdx(vUV);\n                var uvDy = dpdy(vUV);\n\n                ${generateSampleSrc(maxTextures)}\n            `\n            }\n        };\n    }\n\n    return textureBatchBitGpuCache[maxTextures];\n}\n\nconst textureBatchBitGlCache: Record<number, HighShaderBit> = {};\n\n/**\n *\n * @param maxTextures - the max textures the shader can use.\n * @returns a shader bit that will allow the shader to sample multiple textures AND round pixels.\n */\nfunction generateSampleGlSrc(maxTextures: number): string\n{\n    const src = [];\n\n    for (let i = 0; i < maxTextures; i++)\n    {\n        if (i > 0)\n        {\n            src.push('else');\n        }\n\n        if (i < maxTextures - 1)\n        {\n            src.push(`if(vTextureId < ${i}.5)`);\n        }\n\n        src.push('{');\n        src.push(`\\toutColor = texture(uTextures[${i}], vUV);`);\n        src.push('}');\n    }\n\n    return src.join('\\n');\n}\n\n/**\n * @param maxTextures\n * @internal\n */\nexport function generateTextureBatchBitGl(maxTextures: number): HighShaderBit\n{\n    if (!textureBatchBitGlCache[maxTextures])\n    {\n        textureBatchBitGlCache[maxTextures] = {\n            name: 'texture-batch-bit',\n            vertex: {\n                header: `\n                in vec2 aTextureIdAndRound;\n                out float vTextureId;\n\n            `,\n                main: `\n                vTextureId = aTextureIdAndRound.y;\n            `,\n                end: `\n                if(aTextureIdAndRound.x == 1.)\n                {\n                    gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n                }\n            `\n            },\n            fragment: {\n                header: `\n                in float vTextureId;\n\n                uniform sampler2D uTextures[${maxTextures}];\n\n            `,\n                main: `\n\n                ${generateSampleGlSrc(maxTextures)}\n            `\n            }\n        };\n    }\n\n    return textureBatchBitGlCache[maxTextures];\n}\n"],"names":[],"mappings":"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"}
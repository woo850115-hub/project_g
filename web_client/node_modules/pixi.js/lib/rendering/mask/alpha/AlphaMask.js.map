{"version":3,"file":"AlphaMask.js","sources":["../../../../src/rendering/mask/alpha/AlphaMask.ts"],"sourcesContent":["import { ExtensionType } from '../../../extensions/Extensions';\nimport { Sprite } from '../../../scene/sprite/Sprite';\nimport { addMaskBounds } from '../utils/addMaskBounds';\nimport { addMaskLocalBounds } from '../utils/addMaskLocalBounds';\n\nimport type { ExtensionMetadata } from '../../../extensions/Extensions';\nimport type { Point } from '../../../maths/point/Point';\nimport type { Bounds } from '../../../scene/container/bounds/Bounds';\nimport type { Container } from '../../../scene/container/Container';\nimport type { Effect } from '../../../scene/container/Effect';\nimport type { PoolItem } from '../../../utils/pool/Pool';\n\n/**\n * AlphaMask is an effect that applies a mask to a container using the alpha channel of a sprite.\n * It can be used to create complex masking effects by using a sprite as the mask.\n * The mask can be inverted, and it can render the mask to a texture if the mask is not a sprite.\n * @category rendering\n * @advanced\n */\nexport class AlphaMask implements Effect, PoolItem\n{\n    public static extension: ExtensionMetadata = ExtensionType.MaskEffect;\n\n    public priority = 0;\n    public mask: Container;\n    public inverse: boolean = false;\n    public pipe = 'alphaMask';\n    public renderMaskToTexture: boolean;\n\n    constructor(options?: {mask: Container})\n    {\n        if (options?.mask)\n        {\n            this.init(options.mask);\n        }\n    }\n\n    public init(mask: Container): void\n    {\n        this.mask = mask;\n\n        // TODO - might want to change this to adjust on the fly\n        // user may add children to the sprite..\n        this.renderMaskToTexture = !(mask instanceof Sprite);\n\n        this.mask.renderable = this.renderMaskToTexture;\n        this.mask.includeInBuild = !this.renderMaskToTexture;\n\n        this.mask.measurable = false;\n    }\n\n    public reset()\n    {\n        if (this.mask === null) return;\n        this.mask.measurable = true;\n        this.mask = null;\n    }\n\n    public addBounds(bounds: Bounds, skipUpdateTransform?: boolean): void\n    {\n        if (!this.inverse)\n        {\n            addMaskBounds(this.mask, bounds, skipUpdateTransform);\n        }\n    }\n\n    public addLocalBounds(bounds: Bounds, localRoot: Container): void\n    {\n        addMaskLocalBounds(this.mask, bounds, localRoot);\n    }\n\n    public containsPoint(point: Point, hitTestFn: (container: Container, point: Point) => boolean): boolean\n    {\n        const mask = this.mask as any;\n\n        // if the point is in the mask, yay!\n        return hitTestFn(mask, point);\n    }\n\n    public destroy(): void\n    {\n        this.reset();\n    }\n\n    public static test(mask: any): boolean\n    {\n        return mask instanceof Sprite;\n    }\n}\n"],"names":["Sprite","addMaskBounds","addMaskLocalBounds","ExtensionType"],"mappings":";;;;;;;;AAmBO,MAAM,SAAA,CACb;AAAA,EASI,YAAY,OAAA,EACZ;AAPA,IAAA,IAAA,CAAO,QAAA,GAAW,CAAA;AAElB,IAAA,IAAA,CAAO,OAAA,GAAmB,KAAA;AAC1B,IAAA,IAAA,CAAO,IAAA,GAAO,WAAA;AAKV,IAAA,IAAI,SAAS,IAAA,EACb;AACI,MAAA,IAAA,CAAK,IAAA,CAAK,QAAQ,IAAI,CAAA;AAAA,IAC1B;AAAA,EACJ;AAAA,EAEO,KAAK,IAAA,EACZ;AACI,IAAA,IAAA,CAAK,IAAA,GAAO,IAAA;AAIZ,IAAA,IAAA,CAAK,mBAAA,GAAsB,EAAE,IAAA,YAAgBA,aAAA,CAAA;AAE7C,IAAA,IAAA,CAAK,IAAA,CAAK,aAAa,IAAA,CAAK,mBAAA;AAC5B,IAAA,IAAA,CAAK,IAAA,CAAK,cAAA,GAAiB,CAAC,IAAA,CAAK,mBAAA;AAEjC,IAAA,IAAA,CAAK,KAAK,UAAA,GAAa,KAAA;AAAA,EAC3B;AAAA,EAEO,KAAA,GACP;AACI,IAAA,IAAI,IAAA,CAAK,SAAS,IAAA,EAAM;AACxB,IAAA,IAAA,CAAK,KAAK,UAAA,GAAa,IAAA;AACvB,IAAA,IAAA,CAAK,IAAA,GAAO,IAAA;AAAA,EAChB;AAAA,EAEO,SAAA,CAAU,QAAgB,mBAAA,EACjC;AACI,IAAA,IAAI,CAAC,KAAK,OAAA,EACV;AACI,MAAAC,2BAAA,CAAc,IAAA,CAAK,IAAA,EAAM,MAAA,EAAQ,mBAAmB,CAAA;AAAA,IACxD;AAAA,EACJ;AAAA,EAEO,cAAA,CAAe,QAAgB,SAAA,EACtC;AACI,IAAAC,qCAAA,CAAmB,IAAA,CAAK,IAAA,EAAM,MAAA,EAAQ,SAAS,CAAA;AAAA,EACnD;AAAA,EAEO,aAAA,CAAc,OAAc,SAAA,EACnC;AACI,IAAA,MAAM,OAAO,IAAA,CAAK,IAAA;AAGlB,IAAA,OAAO,SAAA,CAAU,MAAM,KAAK,CAAA;AAAA,EAChC;AAAA,EAEO,OAAA,GACP;AACI,IAAA,IAAA,CAAK,KAAA,EAAM;AAAA,EACf;AAAA,EAEA,OAAc,KAAK,IAAA,EACnB;AACI,IAAA,OAAO,IAAA,YAAgBF,aAAA;AAAA,EAC3B;AACJ;AArEa,SAAA,CAEK,YAA+BG,wBAAA,CAAc,UAAA;;;;"}
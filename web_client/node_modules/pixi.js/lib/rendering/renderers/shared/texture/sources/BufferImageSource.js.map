{"version":3,"file":"BufferImageSource.js","sources":["../../../../../../src/rendering/renderers/shared/texture/sources/BufferImageSource.ts"],"sourcesContent":["import { ExtensionType } from '../../../../../extensions/Extensions';\nimport { TextureSource } from './TextureSource';\n\nimport type { ExtensionMetadata } from '../../../../../extensions/Extensions';\nimport type { TypedArray } from '../../buffer/Buffer';\nimport type { TextureSourceOptions } from './TextureSource';\n\n/**\n * Options for creating a BufferImageSource.\n * @category rendering\n * @advanced\n */\nexport interface BufferSourceOptions extends TextureSourceOptions<TypedArray | ArrayBuffer>\n{\n    width: number;\n    height: number;\n}\n\n/**\n * A texture source that uses a TypedArray or ArrayBuffer as its resource.\n * It automatically determines the format based on the type of TypedArray provided.\n * @category rendering\n * @advanced\n */\nexport class BufferImageSource extends TextureSource<TypedArray | ArrayBuffer>\n{\n    public static extension: ExtensionMetadata = ExtensionType.TextureSource;\n\n    public uploadMethodId = 'buffer';\n\n    constructor(options: BufferSourceOptions)\n    {\n        const buffer = options.resource || new Float32Array(options.width * options.height * 4);\n        let format = options.format;\n\n        if (!format)\n        {\n            if (buffer instanceof Float32Array)\n            {\n                format = 'rgba32float';\n            }\n            else if (buffer instanceof Int32Array)\n            {\n                format = 'rgba32uint';\n            }\n            else if (buffer instanceof Uint32Array)\n            {\n                format = 'rgba32uint';\n            }\n            else if (buffer instanceof Int16Array)\n            {\n                format = 'rgba16uint';\n            }\n            else if (buffer instanceof Uint16Array)\n            {\n                format = 'rgba16uint';\n            }\n            else if (buffer instanceof Int8Array)\n            {\n                format = 'bgra8unorm';\n            }\n            else\n            {\n                format = 'bgra8unorm';\n            }\n        }\n\n        super({\n            ...options,\n            resource: buffer,\n            format,\n        });\n    }\n\n    public static test(resource: any): resource is TypedArray | ArrayBuffer\n    {\n        return resource instanceof Int8Array\n        || resource instanceof Uint8Array\n        || resource instanceof Uint8ClampedArray\n        || resource instanceof Int16Array\n        || resource instanceof Uint16Array\n        || resource instanceof Int32Array\n        || resource instanceof Uint32Array\n        || resource instanceof Float32Array;\n    }\n}\n"],"names":["TextureSource","ExtensionType"],"mappings":";;;;;;AAwBO,MAAM,0BAA0BA,2BAAA,CACvC;AAAA,EAKI,YAAY,OAAA,EACZ;AACI,IAAA,MAAM,MAAA,GAAS,QAAQ,QAAA,IAAY,IAAI,aAAa,OAAA,CAAQ,KAAA,GAAQ,OAAA,CAAQ,MAAA,GAAS,CAAC,CAAA;AACtF,IAAA,IAAI,SAAS,OAAA,CAAQ,MAAA;AAErB,IAAA,IAAI,CAAC,MAAA,EACL;AACI,MAAA,IAAI,kBAAkB,YAAA,EACtB;AACI,QAAA,MAAA,GAAS,aAAA;AAAA,MACb,CAAA,MAAA,IACS,kBAAkB,UAAA,EAC3B;AACI,QAAA,MAAA,GAAS,YAAA;AAAA,MACb,CAAA,MAAA,IACS,kBAAkB,WAAA,EAC3B;AACI,QAAA,MAAA,GAAS,YAAA;AAAA,MACb,CAAA,MAAA,IACS,kBAAkB,UAAA,EAC3B;AACI,QAAA,MAAA,GAAS,YAAA;AAAA,MACb,CAAA,MAAA,IACS,kBAAkB,WAAA,EAC3B;AACI,QAAA,MAAA,GAAS,YAAA;AAAA,MACb,CAAA,MAAA,IACS,kBAAkB,SAAA,EAC3B;AACI,QAAA,MAAA,GAAS,YAAA;AAAA,MACb,CAAA,MAEA;AACI,QAAA,MAAA,GAAS,YAAA;AAAA,MACb;AAAA,IACJ;AAEA,IAAA,KAAA,CAAM;AAAA,MACF,GAAG,OAAA;AAAA,MACH,QAAA,EAAU,MAAA;AAAA,MACV;AAAA,KACH,CAAA;AA3CL,IAAA,IAAA,CAAO,cAAA,GAAiB,QAAA;AAAA,EA4CxB;AAAA,EAEA,OAAc,KAAK,QAAA,EACnB;AACI,IAAA,OAAO,QAAA,YAAoB,SAAA,IACxB,QAAA,YAAoB,UAAA,IACpB,oBAAoB,iBAAA,IACpB,QAAA,YAAoB,UAAA,IACpB,QAAA,YAAoB,WAAA,IACpB,QAAA,YAAoB,UAAA,IACpB,QAAA,YAAoB,eACpB,QAAA,YAAoB,YAAA;AAAA,EAC3B;AACJ;AA7Da,iBAAA,CAEK,YAA+BC,wBAAA,CAAc,aAAA;;;;"}
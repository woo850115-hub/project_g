{"version":3,"file":"TextureSource.mjs","sources":["../../../../../../src/rendering/renderers/shared/texture/sources/TextureSource.ts"],"sourcesContent":["import EventEmitter from 'eventemitter3';\nimport { isPow2 } from '../../../../../maths/misc/pow2';\nimport { definedProps } from '../../../../../scene/container/utils/definedProps';\nimport { uid } from '../../../../../utils/data/uid';\nimport { type GPUDataOwner } from '../../../../renderers/types';\nimport { type GlTexture } from '../../../gl/texture/GlTexture';\nimport { type GPUTextureGpuData } from '../../../gpu/texture/GpuTextureSystem';\nimport { type GCable, type GCData } from '../../GCSystem';\nimport { TextureStyle } from '../TextureStyle';\n\nimport type { BindResource } from '../../../gpu/shader/BindResource';\nimport type {\n    ALPHA_MODES,\n    SCALE_MODE,\n    TEXTURE_DIMENSIONS,\n    TEXTURE_FORMATS,\n    TEXTURE_VIEW_DIMENSIONS,\n    WRAP_MODE,\n} from '../const';\nimport type { TextureStyleOptions } from '../TextureStyle';\nimport type { TextureResourceOrOptions } from '../utils/textureFrom';\n\n/**\n * options for creating a new TextureSource\n * @category rendering\n * @advanced\n */\nexport interface TextureSourceOptions<T extends Record<string, any> = any> extends TextureStyleOptions\n{\n    /**\n     * the resource that will be uploaded to the GPU. This is where we get our pixels from\n     * eg an ImageBimt / Canvas / Video etc\n     */\n    resource?: T;\n    /** the pixel width of this texture source. This is the REAL pure number, not accounting resolution */\n    width?: number;\n    /** the pixel height of this texture source. This is the REAL pure number, not accounting resolution */\n    height?: number;\n    /** the resolution of the texture. */\n    resolution?: number;\n    /** the format that the texture data has */\n    format?: TEXTURE_FORMATS;\n    /**\n     * Used by internal textures\n     * @ignore\n     */\n    sampleCount?: number;\n    /**\n     * Only really affects RenderTextures.\n     * Should we use antialiasing for this texture. It will look better, but may impact performance as a\n     * Blit operation will be required to resolve the texture.\n     */\n    antialias?: boolean;\n    /** how many dimensions does this texture have? currently v8 only supports 2d */\n    dimensions?: TEXTURE_DIMENSIONS;\n    /**\n     * How this texture is viewed/sampled by shaders.\n     *\n     * This aligns with WebGPU's `GPUTextureViewDescriptor.dimension`. For example, cube maps are typically stored as a\n     * 2D texture with 6 array layers (`dimensions: '2d'`) but viewed as `viewDimension: 'cube'`.\n     */\n    viewDimension?: TEXTURE_VIEW_DIMENSIONS;\n    /**\n     * The number of array layers for this texture source.\n     *\n     * This maps to WebGPU's `GPUTextureDescriptor.size.depthOrArrayLayers` and is used for array-backed textures\n     * such as cube maps (6 layers).\n     * @default 1\n     * @advanced\n     */\n    arrayLayerCount?: number;\n    /** The number of mip levels to generate for this texture. this is  overridden if autoGenerateMipmaps is true */\n    mipLevelCount?: number;\n    /**\n     * Should we auto generate mipmaps for this texture? This will automatically generate mipmaps\n     * for this texture when uploading to the GPU. Mipmapped textures take up more memory, but\n     * can look better when scaled down.\n     *\n     * For performance reasons, it is recommended to NOT use this with RenderTextures, as they are often updated every frame.\n     * If you do, make sure to call `updateMipmaps` after you update the texture.\n     */\n    autoGenerateMipmaps?: boolean;\n    /** the alpha mode of the texture */\n    alphaMode?: ALPHA_MODES;\n    /** optional label, can be used for debugging */\n    label?: string;\n    /** If true, the Garbage Collector will unload this texture if it is not used after a period of time */\n    autoGarbageCollect?: boolean;\n    /** Used by RenderTexture.create to allow resizing. Not used by TextureSource itself. */\n    dynamic?: boolean;\n}\n\n/**\n * A TextureSource stores the information that represents an image.\n * All textures have require TextureSource, which contains information about the source.\n * Therefore you can have many textures all using a single TextureSource (eg a sprite sheet)\n *\n * This is an class is extended depending on the source of the texture.\n * Eg if you are using an an image as your resource, then an ImageSource is used.\n * @category rendering\n * @advanced\n */\nexport class TextureSource<T extends Record<string, any> = any> extends EventEmitter<{\n    change: BindResource;\n    update: TextureSource;\n    unload: TextureSource;\n    destroy: TextureSource;\n    resize: TextureSource;\n    styleChange: TextureSource;\n    updateMipmaps: TextureSource;\n    error: Error;\n}> implements BindResource, GPUDataOwner, GCable\n{\n    /** The default options used when creating a new TextureSource. override these to add your own defaults */\n    public static defaultOptions: TextureSourceOptions = {\n        resolution: 1,\n        format: 'bgra8unorm',\n        alphaMode: 'premultiply-alpha-on-upload',\n        dimensions: '2d',\n        viewDimension: '2d',\n        arrayLayerCount: 1,\n        mipLevelCount: 1,\n        autoGenerateMipmaps: false,\n        sampleCount: 1,\n        antialias: false,\n        autoGarbageCollect: false,\n    };\n\n    /** @internal */\n    public _gpuData: Record<number, GlTexture | GPUTextureGpuData> = Object.create(null);\n    /** GC tracking data, undefined if not being tracked */\n    public _gcData?: GCData;\n    /** @internal */\n    public _gcLastUsed = -1;\n\n    /** unique id for this Texture source */\n    public readonly uid: number = uid('textureSource');\n    /** optional label, can be used for debugging */\n    public label: string;\n\n    /**\n     * The resource type used by this TextureSource. This is used by the bind groups to determine\n     * how to handle this resource.\n     * @internal\n     */\n    public readonly _resourceType = 'textureSource';\n    /**\n     * i unique resource id, used by the bind group systems.\n     * This can change if the texture is resized or its resource changes\n     * @internal\n     */\n    public _resourceId = uid('resource');\n    /**\n     * this is how the backends know how to upload this texture to the GPU\n     * It changes depending on the resource type. Classes that extend TextureSource\n     * should override this property.\n     * @internal\n     */\n    public uploadMethodId = 'unknown';\n\n    /** @internal */\n    public _resolution = 1;\n\n    /** the pixel width of this texture source. This is the REAL pure number, not accounting resolution */\n    public pixelWidth = 1;\n    /** the pixel height of this texture source. This is the REAL pure number, not accounting resolution */\n    public pixelHeight = 1;\n\n    /**\n     * the width of this texture source, accounting for resolution\n     * eg pixelWidth 200, resolution 2, then width will be 100\n     */\n    public width = 1;\n    /**\n     * the height of this texture source, accounting for resolution\n     * eg pixelHeight 200, resolution 2, then height will be 100\n     */\n    public height = 1;\n\n    /**\n     * the resource that will be uploaded to the GPU. This is where we get our pixels from\n     * eg an ImageBimt / Canvas / Video etc\n     */\n    public resource: T;\n\n    /**\n     * The number of samples of a multisample texture. This is always 1 for non-multisample textures.\n     * To enable multisample for a texture, set antialias to true\n     * @internal\n     */\n    public sampleCount = 1;\n\n    /**\n     * The number of mip levels to generate for this texture.\n     * this is overridden if autoGenerateMipmaps is true. it is read only!\n     */\n    public mipLevelCount = 1;\n    /**\n     * Should we auto generate mipmaps for this texture? This will automatically generate mipmaps\n     * for this texture when uploading to the GPU. Mipmapped textures take up more memory, but\n     * can look better when scaled down.\n     *\n     * For performance reasons, it is recommended to NOT use this with RenderTextures, as they are often updated every frame.\n     * If you do, make sure to call `updateMipmaps` after you update the texture.\n     */\n    public autoGenerateMipmaps = false;\n    /** the format that the texture data has */\n    public format: TEXTURE_FORMATS = 'rgba8unorm';\n    /** how many dimensions does this texture have? currently v8 only supports 2d */\n    public dimension: TEXTURE_DIMENSIONS = '2d';\n    /** how this texture is viewed/sampled by shaders (WebGPU view dimension) */\n    public viewDimension: TEXTURE_VIEW_DIMENSIONS = '2d';\n    /** how many array layers this texture has (WebGPU depthOrArrayLayers) */\n    public arrayLayerCount = 1;\n    /** the alpha mode of the texture */\n    public alphaMode: ALPHA_MODES;\n    private _style: TextureStyle;\n\n    /**\n     * Only really affects RenderTextures.\n     * Should we use antialiasing for this texture. It will look better, but may impact performance as a\n     * Blit operation will be required to resolve the texture.\n     */\n    public antialias = false;\n\n    /**\n     * Has the source been destroyed?\n     * @readonly\n     */\n    public destroyed: boolean;\n\n    /**\n     * Used by automatic texture Garbage Collection, stores last GC tick when it was bound\n     * @protected\n     */\n    public _touched = 0;\n\n    /**\n     * Used by the batcher to build texture batches. faster to have the variable here!\n     * @protected\n     */\n    public _batchTick = -1;\n    /**\n     * A temporary batch location for the texture batching. Here for performance reasons only!\n     * @protected\n     */\n    public _textureBindLocation = -1;\n\n    public isPowerOfTwo: boolean;\n\n    /** If true, the Garbage Collector will unload this texture if it is not used after a period of time */\n    public autoGarbageCollect: boolean;\n\n    /**\n     * used internally to know where a texture came from. Usually assigned by the asset loader!\n     * @ignore\n     */\n    public _sourceOrigin: string;\n\n    /**\n     * @param options - options for creating a new TextureSource\n     */\n    constructor(protected readonly options: TextureSourceOptions<T> = {})\n    {\n        super();\n\n        options = { ...TextureSource.defaultOptions, ...options };\n\n        this.label = options.label ?? '';\n        this.resource = options.resource;\n        this.autoGarbageCollect = options.autoGarbageCollect;\n        this._resolution = options.resolution;\n\n        if (options.width)\n        {\n            this.pixelWidth = options.width * this._resolution;\n        }\n        else\n        {\n            this.pixelWidth = this.resource ? (this.resourceWidth ?? 1) : 1;\n        }\n\n        if (options.height)\n        {\n            this.pixelHeight = options.height * this._resolution;\n        }\n        else\n        {\n            this.pixelHeight = this.resource ? (this.resourceHeight ?? 1) : 1;\n        }\n\n        this.width = this.pixelWidth / this._resolution;\n        this.height = this.pixelHeight / this._resolution;\n\n        this.format = options.format;\n        this.dimension = options.dimensions;\n        this.viewDimension = options.viewDimension ?? options.dimensions;\n        this.arrayLayerCount = options.arrayLayerCount;\n        this.mipLevelCount = options.mipLevelCount;\n        this.autoGenerateMipmaps = options.autoGenerateMipmaps;\n        this.sampleCount = options.sampleCount;\n        this.antialias = options.antialias;\n        this.alphaMode = options.alphaMode;\n\n        this.style = new TextureStyle(definedProps(options));\n\n        this.destroyed = false;\n\n        this._refreshPOT();\n    }\n\n    /** returns itself */\n    get source(): TextureSource\n    {\n        return this;\n    }\n\n    /** the style of the texture */\n    get style(): TextureStyle\n    {\n        return this._style;\n    }\n\n    set style(value: TextureStyle)\n    {\n        if (this.style === value) return;\n\n        this._style?.off('change', this._onStyleChange, this);\n        this._style = value;\n        this._style?.on('change', this._onStyleChange, this);\n\n        this._onStyleChange();\n    }\n\n    /** Specifies the maximum anisotropy value clamp used by the sampler. */\n    set maxAnisotropy(value: number)\n    {\n        this._style.maxAnisotropy = value;\n    }\n\n    get maxAnisotropy(): number\n    {\n        return this._style.maxAnisotropy;\n    }\n\n    /** setting this will set wrapModeU, wrapModeV and wrapModeW all at once! */\n    get addressMode(): WRAP_MODE\n    {\n        return this._style.addressMode;\n    }\n\n    set addressMode(value: WRAP_MODE)\n    {\n        this._style.addressMode = value;\n    }\n\n    /** setting this will set wrapModeU, wrapModeV and wrapModeW all at once! */\n    get repeatMode(): WRAP_MODE\n    {\n        return this._style.addressMode;\n    }\n\n    set repeatMode(value: WRAP_MODE)\n    {\n        this._style.addressMode = value;\n    }\n\n    /** Specifies the sampling behavior when the sample footprint is smaller than or equal to one texel. */\n    get magFilter(): SCALE_MODE\n    {\n        return this._style.magFilter;\n    }\n\n    set magFilter(value: SCALE_MODE)\n    {\n        this._style.magFilter = value;\n    }\n\n    /** Specifies the sampling behavior when the sample footprint is larger than one texel. */\n    get minFilter(): SCALE_MODE\n    {\n        return this._style.minFilter;\n    }\n\n    set minFilter(value: SCALE_MODE)\n    {\n        this._style.minFilter = value;\n    }\n\n    /** Specifies behavior for sampling between mipmap levels. */\n    get mipmapFilter(): SCALE_MODE\n    {\n        return this._style.mipmapFilter;\n    }\n\n    set mipmapFilter(value: SCALE_MODE)\n    {\n        this._style.mipmapFilter = value;\n    }\n\n    /** Specifies the minimum and maximum levels of detail, respectively, used internally when sampling a texture. */\n    get lodMinClamp(): number\n    {\n        return this._style.lodMinClamp;\n    }\n\n    set lodMinClamp(value: number)\n    {\n        this._style.lodMinClamp = value;\n    }\n\n    /** Specifies the minimum and maximum levels of detail, respectively, used internally when sampling a texture. */\n    get lodMaxClamp(): number\n    {\n        return this._style.lodMaxClamp;\n    }\n\n    set lodMaxClamp(value: number)\n    {\n        this._style.lodMaxClamp = value;\n    }\n\n    private _onStyleChange()\n    {\n        this.emit('styleChange', this);\n    }\n\n    /** call this if you have modified the texture outside of the constructor */\n    public update()\n    {\n        // update resource...\n        if (this.resource)\n        {\n            const resolution = this._resolution;\n\n            const didResize = this.resize(this.resourceWidth / resolution, this.resourceHeight / resolution);\n\n            // no need to dispatch the update we resized as that will\n            // notify the texture systems anyway\n            if (didResize) return;\n        }\n\n        this.emit('update', this);\n    }\n\n    /** Destroys this texture source */\n    public destroy()\n    {\n        this.destroyed = true;\n        this.unload();\n        this.emit('destroy', this);\n\n        if (this._style)\n        {\n            this._style.destroy();\n            this._style = null;\n        }\n\n        this.uploadMethodId = null;\n        this.resource = null;\n        this.removeAllListeners();\n    }\n\n    /**\n     * This will unload the Texture source from the GPU. This will free up the GPU memory\n     * As soon as it is required fore rendering, it will be re-uploaded.\n     */\n    public unload()\n    {\n        this._resourceId = uid('resource');\n        this.emit('change', this);\n\n        /** Unloads the GPU data from the view container. */\n        this.emit('unload', this);\n        for (const key in this._gpuData)\n        {\n            this._gpuData[key]?.destroy?.();\n        }\n        this._gpuData = Object.create(null);\n    }\n\n    /** the width of the resource. This is the REAL pure number, not accounting resolution   */\n    public get resourceWidth(): number\n    {\n        const { resource } = this;\n\n        return resource.naturalWidth || resource.videoWidth || resource.displayWidth || resource.width;\n    }\n\n    /** the height of the resource. This is the REAL pure number, not accounting resolution */\n    public get resourceHeight(): number\n    {\n        const { resource } = this;\n\n        return resource.naturalHeight || resource.videoHeight || resource.displayHeight || resource.height;\n    }\n\n    /**\n     * the resolution of the texture. Changing this number, will not change the number of pixels in the actual texture\n     * but will the size of the texture when rendered.\n     *\n     * changing the resolution of this texture to 2 for example will make it appear twice as small when rendered (as pixel\n     * density will have increased)\n     */\n    get resolution(): number\n    {\n        return this._resolution;\n    }\n\n    set resolution(resolution: number)\n    {\n        if (this._resolution === resolution) return;\n\n        this._resolution = resolution;\n\n        this.width = this.pixelWidth / resolution;\n        this.height = this.pixelHeight / resolution;\n    }\n\n    /**\n     * Resize the texture, this is handy if you want to use the texture as a render texture\n     * @param width - the new width of the texture\n     * @param height - the new height of the texture\n     * @param resolution - the new resolution of the texture\n     * @returns - if the texture was resized\n     */\n    public resize(width?: number, height?: number, resolution?: number): boolean\n    {\n        resolution ||= this._resolution;\n        width ||= this.width;\n        height ||= this.height;\n\n        // make sure we work with rounded pixels\n        const newPixelWidth = Math.round(width * resolution);\n        const newPixelHeight = Math.round(height * resolution);\n\n        this.width = newPixelWidth / resolution;\n        this.height = newPixelHeight / resolution;\n\n        this._resolution = resolution;\n\n        if (this.pixelWidth === newPixelWidth && this.pixelHeight === newPixelHeight)\n        {\n            return false;\n        }\n\n        this._refreshPOT();\n\n        this.pixelWidth = newPixelWidth;\n        this.pixelHeight = newPixelHeight;\n\n        this.emit('resize', this);\n\n        this._resourceId = uid('resource');\n        this.emit('change', this);\n\n        return true;\n    }\n\n    /**\n     * Lets the renderer know that this texture has been updated and its mipmaps should be re-generated.\n     * This is only important for RenderTexture instances, as standard Texture instances will have their\n     * mipmaps generated on upload. You should call this method after you make any change to the texture\n     *\n     * The reason for this is is can be quite expensive to update mipmaps for a texture. So by default,\n     * We want you, the developer to specify when this action should happen.\n     *\n     * Generally you don't want to have mipmaps generated on Render targets that are changed every frame,\n     */\n    public updateMipmaps()\n    {\n        if (this.autoGenerateMipmaps && this.mipLevelCount > 1)\n        {\n            this.emit('updateMipmaps', this);\n        }\n    }\n\n    set wrapMode(value: WRAP_MODE)\n    {\n        this._style.wrapMode = value;\n    }\n\n    get wrapMode(): WRAP_MODE\n    {\n        return this._style.wrapMode;\n    }\n\n    set scaleMode(value: SCALE_MODE)\n    {\n        this._style.scaleMode = value;\n    }\n\n    /** setting this will set magFilter,minFilter and mipmapFilter all at once!  */\n    get scaleMode(): SCALE_MODE\n    {\n        return this._style.scaleMode;\n    }\n\n    /**\n     * Refresh check for isPowerOfTwo texture based on size\n     * @private\n     */\n    protected _refreshPOT(): void\n    {\n        this.isPowerOfTwo = isPow2(this.pixelWidth) && isPow2(this.pixelHeight);\n    }\n\n    public static test(_resource: any): any\n    {\n        // this should be overridden by other sources..\n        throw new Error('Unimplemented');\n    }\n\n    /**\n     * A helper function that creates a new TextureSource based on the resource you provide.\n     * @param resource - The resource to create the texture source from.\n     */\n    public static from: (resource: TextureResourceOrOptions) => TextureSource;\n}\n"],"names":[],"mappings":"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"}
{"version":3,"file":"canvasUtils.js","sources":["../../../../../src/rendering/renderers/canvas/utils/canvasUtils.ts"],"sourcesContent":["import { Color } from '../../../../color/Color';\nimport { DOMAdapter } from '../../../../environment/adapter';\nimport { groupD8 } from '../../../../maths/matrix/groupD8';\nimport { canUseNewCanvasBlendModes } from './canUseNewCanvasBlendModes';\n\nimport type { ICanvas } from '../../../../environment/canvas/ICanvas';\nimport type { ICanvasRenderingContext2D } from '../../../../environment/canvas/ICanvasRenderingContext2D';\nimport type { ImageLike } from '../../../../environment/ImageLike';\nimport type { TextureSource } from '../../shared/texture/sources/TextureSource';\nimport type { Texture } from '../../shared/texture/Texture';\n\ntype TintCache = Record<string, (ICanvas & { tintId?: number }) | (ImageLike & { tintId?: number })>;\ntype CanvasSourceCache = {\n    canvas: ICanvas;\n    resourceId: number;\n};\n\n/**\n * Canvas helper utilities for tinting and pattern generation.\n * @internal\n */\nexport const canvasUtils = {\n    canvas: null as ICanvas | null,\n    convertTintToImage: false,\n    cacheStepsPerColorChannel: 8,\n    canUseMultiply: canUseNewCanvasBlendModes(),\n    tintMethod: null as (texture: Texture, color: number, canvas: ICanvas) => void,\n    _canvasSourceCache: new WeakMap<TextureSource, CanvasSourceCache>(),\n    _unpremultipliedCache: new WeakMap<TextureSource, CanvasSourceCache>(),\n    getCanvasSource: (texture: Texture): CanvasImageSource | null =>\n    {\n        const source = texture.source;\n        const resource = source?.resource as unknown;\n\n        if (!resource)\n        {\n            return null;\n        }\n\n        const isPMA = source.alphaMode === 'premultiplied-alpha';\n\n        const resourceWidth = source.resourceWidth ?? source.pixelWidth;\n        const resourceHeight = source.resourceHeight ?? source.pixelHeight;\n        const needsResize = resourceWidth !== source.pixelWidth || resourceHeight !== source.pixelHeight;\n\n        if (isPMA)\n        {\n            // If the resource is a canvas, we can assume it's already in a format that the context handles correctly\n            if (resource instanceof HTMLCanvasElement\n                || (typeof OffscreenCanvas !== 'undefined' && resource instanceof OffscreenCanvas))\n            {\n                if (!needsResize)\n                {\n                    return resource as CanvasImageSource;\n                }\n            }\n\n            const cached = canvasUtils._unpremultipliedCache.get(source);\n\n            if (cached?.resourceId === source._resourceId)\n            {\n                return cached.canvas as unknown as CanvasImageSource;\n            }\n        }\n\n        if (resource instanceof Uint8Array\n            || resource instanceof Uint8ClampedArray\n            || resource instanceof Int8Array\n            || resource instanceof Uint16Array\n            || resource instanceof Int16Array\n            || resource instanceof Uint32Array\n            || resource instanceof Int32Array\n            || resource instanceof Float32Array\n            || resource instanceof ArrayBuffer)\n        {\n            const cached = canvasUtils._canvasSourceCache.get(source);\n\n            if (cached?.resourceId === source._resourceId)\n            {\n                return cached.canvas as unknown as CanvasImageSource;\n            }\n\n            const canvas = DOMAdapter.get().createCanvas(source.pixelWidth, source.pixelHeight);\n            const context = canvas.getContext('2d');\n            const imageData = context.createImageData(source.pixelWidth, source.pixelHeight);\n            const data = imageData.data;\n\n            const bytes = resource instanceof ArrayBuffer\n                ? new Uint8Array(resource)\n                : new Uint8Array(resource.buffer, resource.byteOffset, resource.byteLength);\n\n            if (source.format === 'bgra8unorm')\n            {\n                for (let i = 0; i < data.length && i + 3 < bytes.length; i += 4)\n                {\n                    data[i] = bytes[i + 2];\n                    data[i + 1] = bytes[i + 1];\n                    data[i + 2] = bytes[i];\n                    data[i + 3] = bytes[i + 3];\n                }\n            }\n            else\n            {\n                data.set(bytes.subarray(0, data.length));\n            }\n\n            context.putImageData(imageData, 0, 0);\n\n            canvasUtils._canvasSourceCache.set(source, { canvas, resourceId: source._resourceId });\n\n            return canvas as unknown as CanvasImageSource;\n        }\n\n        if (isPMA)\n        {\n            const canvas = DOMAdapter.get().createCanvas(source.pixelWidth, source.pixelHeight);\n            const context = canvas.getContext('2d', { willReadFrequently: true });\n\n            canvas.width = source.pixelWidth;\n            canvas.height = source.pixelHeight;\n\n            context.drawImage(resource as CanvasImageSource, 0, 0);\n\n            const imageData = context.getImageData(0, 0, canvas.width, canvas.height);\n            const data = imageData.data;\n\n            for (let i = 0; i < data.length; i += 4)\n            {\n                const a = data[i + 3];\n\n                if (a > 0)\n                {\n                    const alphaInv = 255 / a;\n\n                    data[i] = Math.min(255, (data[i] * alphaInv) + 0.5);\n                    data[i + 1] = Math.min(255, (data[i + 1] * alphaInv) + 0.5);\n                    data[i + 2] = Math.min(255, (data[i + 2] * alphaInv) + 0.5);\n                }\n            }\n\n            context.putImageData(imageData, 0, 0);\n\n            canvasUtils._unpremultipliedCache.set(source, { canvas, resourceId: source._resourceId });\n\n            return canvas as unknown as CanvasImageSource;\n        }\n\n        if (needsResize)\n        {\n            const cached = canvasUtils._canvasSourceCache.get(source);\n\n            if (cached?.resourceId === source._resourceId)\n            {\n                return cached.canvas as unknown as CanvasImageSource;\n            }\n\n            const canvas = DOMAdapter.get().createCanvas(source.pixelWidth, source.pixelHeight);\n            const context = canvas.getContext('2d');\n\n            canvas.width = source.pixelWidth;\n            canvas.height = source.pixelHeight;\n\n            context.drawImage(resource as CanvasImageSource, 0, 0);\n\n            canvasUtils._canvasSourceCache.set(source, { canvas, resourceId: source._resourceId });\n\n            return canvas as unknown as CanvasImageSource;\n        }\n\n        return resource as CanvasImageSource;\n    },\n\n    getTintedCanvas: (sprite: { texture: Texture }, color: number): ICanvas | ImageLike =>\n    {\n        const texture = sprite.texture;\n        const stringColor = Color.shared.setValue(color).toHex();\n        const cache = (texture as any).tintCache as TintCache || ((texture as any).tintCache = {});\n\n        const cachedCanvas = cache[stringColor];\n        const resourceId = texture.source._resourceId;\n\n        if (cachedCanvas?.tintId === resourceId)\n        {\n            return cachedCanvas;\n        }\n\n        const canvas = (cachedCanvas && 'getContext' in cachedCanvas)\n            ? (cachedCanvas as ICanvas)\n            : DOMAdapter.get().createCanvas();\n\n        canvasUtils.tintMethod(texture, color, canvas);\n\n        (canvas as any).tintId = resourceId;\n\n        if (canvasUtils.convertTintToImage && canvas.toDataURL !== undefined)\n        {\n            const tintImage = DOMAdapter.get().createImage();\n\n            tintImage.src = canvas.toDataURL();\n            (tintImage as any).tintId = resourceId;\n\n            cache[stringColor] = tintImage as any;\n        }\n        else\n        {\n            cache[stringColor] = canvas;\n        }\n\n        return cache[stringColor];\n    },\n\n    getTintedPattern: (texture: Texture, color: number): CanvasPattern =>\n    {\n        const stringColor = Color.shared.setValue(color).toHex();\n        const cache = (texture as any).patternCache as Record<string, CanvasPattern & { tintId?: number }>\n            || ((texture as any).patternCache = {});\n        const resourceId = texture.source._resourceId;\n\n        let pattern = cache[stringColor];\n\n        if (pattern?.tintId === resourceId)\n        {\n            return pattern;\n        }\n\n        if (!canvasUtils.canvas)\n        {\n            canvasUtils.canvas = DOMAdapter.get().createCanvas();\n        }\n\n        // Always use tintMethod to handle frame cropping correctly (matching v7 approach)\n        canvasUtils.tintMethod(texture, color, canvasUtils.canvas);\n\n        const context = canvasUtils.canvas.getContext('2d');\n\n        pattern = context.createPattern(canvasUtils.canvas, 'repeat');\n\n        pattern.tintId = resourceId;\n        cache[stringColor] = pattern;\n\n        return pattern;\n    },\n\n    /**\n     * Applies a transform to a CanvasPattern.\n     * @param pattern - The pattern to apply the transform to.\n     * @param matrix - The matrix to apply.\n     * @param matrix.a\n     * @param matrix.b\n     * @param matrix.c\n     * @param matrix.d\n     * @param matrix.tx\n     * @param matrix.ty\n     * @param invert\n     */\n    applyPatternTransform: (\n        pattern: CanvasPattern,\n        matrix: {\n            a: number,\n            b: number,\n            c: number,\n            d: number,\n            tx: number,\n            ty: number\n        },\n        invert = true\n    ): void =>\n    {\n        if (!matrix) return;\n\n        const patternAny = pattern as unknown as { setTransform?: (value: DOMMatrix) => void };\n\n        if (!patternAny.setTransform) return;\n\n        const DOMMatrixCtor = (globalThis as { DOMMatrix?: typeof DOMMatrix }).DOMMatrix;\n\n        if (!DOMMatrixCtor) return;\n\n        const domMatrix = new DOMMatrixCtor([matrix.a, matrix.b, matrix.c, matrix.d, matrix.tx, matrix.ty]);\n\n        patternAny.setTransform(invert ? domMatrix.inverse() : domMatrix);\n    },\n\n    tintWithMultiply: (texture: Texture, color: number, canvas: ICanvas): void =>\n    {\n        const context = canvas.getContext('2d');\n        const crop = texture.frame.clone();\n        const resolution = texture.source._resolution ?? texture.source.resolution ?? 1;\n        const rotate = texture.rotate;\n\n        crop.x *= resolution;\n        crop.y *= resolution;\n        crop.width *= resolution;\n        crop.height *= resolution;\n\n        // When texture is rotated 90° or 270°, output dimensions are swapped\n        const isVertical = groupD8.isVertical(rotate);\n        const outWidth = isVertical ? crop.height : crop.width;\n        const outHeight = isVertical ? crop.width : crop.height;\n\n        canvas.width = Math.ceil(outWidth);\n        canvas.height = Math.ceil(outHeight);\n\n        context.save();\n        context.fillStyle = Color.shared.setValue(color).toHex();\n        context.fillRect(0, 0, outWidth, outHeight);\n\n        context.globalCompositeOperation = 'multiply';\n\n        const source = canvasUtils.getCanvasSource(texture);\n\n        if (!source)\n        {\n            context.restore();\n\n            return;\n        }\n\n        // Apply inverse rotation to compensate for spritesheet packing\n        if (rotate)\n        {\n            canvasUtils._applyInverseRotation(context, rotate, crop.width, crop.height);\n        }\n\n        context.drawImage(\n            source,\n            crop.x,\n            crop.y,\n            crop.width,\n            crop.height,\n            0,\n            0,\n            crop.width,\n            crop.height\n        );\n\n        context.globalCompositeOperation = 'destination-atop';\n        context.drawImage(\n            source,\n            crop.x,\n            crop.y,\n            crop.width,\n            crop.height,\n            0,\n            0,\n            crop.width,\n            crop.height\n        );\n        context.restore();\n    },\n\n    tintWithOverlay: (texture: Texture, color: number, canvas: ICanvas): void =>\n    {\n        const context = canvas.getContext('2d');\n        const crop = texture.frame.clone();\n        const resolution = texture.source._resolution ?? texture.source.resolution ?? 1;\n        const rotate = texture.rotate;\n\n        crop.x *= resolution;\n        crop.y *= resolution;\n        crop.width *= resolution;\n        crop.height *= resolution;\n\n        // When texture is rotated 90° or 270°, output dimensions are swapped\n        const isVertical = groupD8.isVertical(rotate);\n        const outWidth = isVertical ? crop.height : crop.width;\n        const outHeight = isVertical ? crop.width : crop.height;\n\n        canvas.width = Math.ceil(outWidth);\n        canvas.height = Math.ceil(outHeight);\n\n        context.save();\n        context.globalCompositeOperation = 'copy';\n        context.fillStyle = Color.shared.setValue(color).toHex();\n        context.fillRect(0, 0, outWidth, outHeight);\n\n        context.globalCompositeOperation = 'destination-atop';\n        const source = canvasUtils.getCanvasSource(texture);\n\n        if (!source)\n        {\n            context.restore();\n\n            return;\n        }\n\n        // Apply inverse rotation to compensate for spritesheet packing\n        if (rotate)\n        {\n            canvasUtils._applyInverseRotation(context, rotate, crop.width, crop.height);\n        }\n\n        context.drawImage(\n            source,\n            crop.x,\n            crop.y,\n            crop.width,\n            crop.height,\n            0,\n            0,\n            crop.width,\n            crop.height\n        );\n        context.restore();\n    },\n\n    tintWithPerPixel: (texture: Texture, color: number, canvas: ICanvas): void =>\n    {\n        const context = canvas.getContext('2d');\n        const crop = texture.frame.clone();\n        const resolution = texture.source._resolution ?? texture.source.resolution ?? 1;\n        const rotate = texture.rotate;\n\n        crop.x *= resolution;\n        crop.y *= resolution;\n        crop.width *= resolution;\n        crop.height *= resolution;\n\n        // When texture is rotated 90° or 270°, output dimensions are swapped\n        const isVertical = groupD8.isVertical(rotate);\n        const outWidth = isVertical ? crop.height : crop.width;\n        const outHeight = isVertical ? crop.width : crop.height;\n\n        canvas.width = Math.ceil(outWidth);\n        canvas.height = Math.ceil(outHeight);\n\n        context.save();\n        context.globalCompositeOperation = 'copy';\n        const source = canvasUtils.getCanvasSource(texture);\n\n        if (!source)\n        {\n            context.restore();\n\n            return;\n        }\n\n        // Apply inverse rotation to compensate for spritesheet packing\n        if (rotate)\n        {\n            canvasUtils._applyInverseRotation(context, rotate, crop.width, crop.height);\n        }\n\n        context.drawImage(\n            source,\n            crop.x,\n            crop.y,\n            crop.width,\n            crop.height,\n            0,\n            0,\n            crop.width,\n            crop.height\n        );\n\n        context.restore();\n\n        const r = (color >> 16) & 0xFF;\n        const g = (color >> 8) & 0xFF;\n        const b = color & 0xFF;\n\n        const imageData = context.getImageData(0, 0, outWidth, outHeight);\n        const data = imageData.data;\n\n        for (let i = 0; i < data.length; i += 4)\n        {\n            data[i] = (data[i] * r) / 255;\n            data[i + 1] = (data[i + 1] * g) / 255;\n            data[i + 2] = (data[i + 2] * b) / 255;\n        }\n\n        context.putImageData(imageData, 0, 0);\n    },\n\n    /**\n     * Applies inverse rotation transform to context for texture packer rotation compensation.\n     * Supports all 16 groupD8 symmetries (rotations and reflections).\n     * @param context - Canvas 2D context\n     * @param rotate - The groupD8 rotation value\n     * @param srcWidth - Source crop width (before rotation)\n     * @param srcHeight - Source crop height (before rotation)\n     */\n    _applyInverseRotation: (\n        context: ICanvasRenderingContext2D,\n        rotate: number,\n        srcWidth: number,\n        srcHeight: number\n    ): void =>\n    {\n        // Get inverse rotation matrix components using groupD8 utilities\n        const inv = groupD8.inv(rotate);\n        const a = groupD8.uX(inv);\n        const b = groupD8.uY(inv);\n        const c = groupD8.vX(inv);\n        const d = groupD8.vY(inv);\n\n        // Calculate translation to keep content at origin after transform\n        // Same approach as matrixAppendRotationInv\n        const tx = -Math.min(0, a * srcWidth, c * srcHeight, (a * srcWidth) + (c * srcHeight));\n        const ty = -Math.min(0, b * srcWidth, d * srcHeight, (b * srcWidth) + (d * srcHeight));\n\n        context.transform(a, b, c, d, tx, ty);\n    },\n};\n\ncanvasUtils.tintMethod = canvasUtils.canUseMultiply ? canvasUtils.tintWithMultiply : canvasUtils.tintWithPerPixel;\n"],"names":["canUseNewCanvasBlendModes","DOMAdapter","Color","groupD8"],"mappings":"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"}
{"version":3,"file":"extractAttributesFromGpuProgram.js","sources":["../../../../../../src/rendering/renderers/gpu/shader/utils/extractAttributesFromGpuProgram.ts"],"sourcesContent":["import { getAttributeInfoFromFormat } from '../../../shared/geometry/utils/getAttributeInfoFromFormat';\n\nimport type { ExtractedAttributeData } from '../../../gl/shader/program/extractAttributesFromGlProgram';\nimport type { VertexFormat } from '../../../shared/geometry/const';\nimport type { ProgramSource } from '../GpuProgram';\n\nconst WGSL_TO_VERTEX_TYPES: Record<string, VertexFormat> = {\n\n    f32:  'float32',\n    'vec2<f32>': 'float32x2',\n    'vec3<f32>': 'float32x3',\n    'vec4<f32>': 'float32x4',\n    vec2f: 'float32x2',\n    vec3f: 'float32x3',\n    vec4f: 'float32x4',\n\n    i32: 'sint32',\n    'vec2<i32>': 'sint32x2',\n    'vec3<i32>': 'sint32x3',\n    'vec4<i32>': 'sint32x4',\n    vec2i: 'sint32x2',\n    vec3i: 'sint32x3',\n    vec4i: 'sint32x4',\n\n    u32: 'uint32',\n    'vec2<u32>': 'uint32x2',\n    'vec3<u32>': 'uint32x3',\n    'vec4<u32>': 'uint32x4',\n    vec2u: 'uint32x2',\n    vec3u: 'uint32x3',\n    vec4u: 'uint32x4',\n\n    bool: 'uint32',\n    'vec2<bool>': 'uint32x2',\n    'vec3<bool>': 'uint32x3',\n    'vec4<bool>': 'uint32x4',\n};\n\n/** Regex to match \\@location decorated fields */\nconst LOCATION_REGEX = /@location\\((\\d+)\\)\\s+([a-zA-Z0-9_]+)\\s*:\\s*([a-zA-Z0-9_<>]+)(?:,|\\s|\\)|$)/g;\n\n/**\n * Parses \\@location attributes from a string and populates results.\n * @param str - String to search for \\@location patterns\n * @param results - Results object to populate\n */\nfunction parseLocations(str: string, results: Record<string, ExtractedAttributeData>): void\n{\n    let match;\n\n    while ((match = LOCATION_REGEX.exec(str)) !== null)\n    {\n        const format = WGSL_TO_VERTEX_TYPES[match[3] as VertexFormat] ?? 'float32';\n\n        results[match[2]] = {\n            location: parseInt(match[1], 10),\n            format,\n            stride: getAttributeInfoFromFormat(format).stride,\n            offset: 0,\n            instance: false,\n            start: 0,\n        };\n    }\n\n    // Reset regex state for reuse\n    LOCATION_REGEX.lastIndex = 0;\n}\n\n/**\n * Strips comments from WGSL source code.\n * @param source - WGSL source code\n * @returns Source with comments removed\n */\nfunction stripComments(source: string): string\n{\n    return source\n        .replace(/\\/\\/.*$/gm, '') // Remove line comments\n        .replace(/\\/\\*[\\s\\S]*?\\*\\//g, ''); // Remove block comments\n}\n\n/**\n * Extracts vertex attributes from a WGSL shader program.\n *\n * Supports two styles:\n * 1. Inline \\@location decorators in function parameters\n * 2. Struct-based input where \\@location decorators are in the struct definition\n * @param root0\n * @param root0.source\n * @param root0.entryPoint\n * @internal\n */\nexport function extractAttributesFromGpuProgram(\n    { source, entryPoint }: ProgramSource\n): Record<string, ExtractedAttributeData>\n{\n    const results: Record<string, ExtractedAttributeData> = {};\n\n    // Strip comments to avoid false matches\n    const cleanSource = stripComments(source);\n\n    // Step 1: Find the start of the vertex function (include '(' to avoid prefix matches)\n    const mainVertStart = cleanSource.indexOf(`fn ${entryPoint}(`);\n\n    if (mainVertStart === -1)\n    {\n        return results;\n    }\n\n    // Step 2: Find the index of the next '->' after the start of the function\n    const arrowFunctionStart = cleanSource.indexOf('->', mainVertStart);\n\n    if (arrowFunctionStart === -1)\n    {\n        return results;\n    }\n\n    const functionArgsSubstring = cleanSource.substring(mainVertStart, arrowFunctionStart);\n\n    // Step 3: Try parsing inline @location decorators first\n    parseLocations(functionArgsSubstring, results);\n\n    // Step 4: If no inline locations found, check for struct-based input\n    if (Object.keys(results).length === 0)\n    {\n        // Match first parameter type: (input: VertexInput, ...) or (data: MyStruct)\n        const structMatch = functionArgsSubstring.match(/\\(\\s*\\w+\\s*:\\s*(\\w+)/);\n\n        if (structMatch)\n        {\n            const structName = structMatch[1];\n\n            // Find the struct definition in the source\n            const structRegex = new RegExp(`struct\\\\s+${structName}\\\\s*\\\\{([^}]+)\\\\}`, 's');\n            const structBody = cleanSource.match(structRegex);\n\n            if (structBody)\n            {\n                // Parse @location from struct body\n                parseLocations(structBody[1], results);\n            }\n        }\n    }\n\n    return results;\n}\n"],"names":["getAttributeInfoFromFormat"],"mappings":"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"}
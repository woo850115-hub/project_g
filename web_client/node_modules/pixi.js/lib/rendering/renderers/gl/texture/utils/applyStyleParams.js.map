{"version":3,"file":"applyStyleParams.js","sources":["../../../../../../src/rendering/renderers/gl/texture/utils/applyStyleParams.ts"],"sourcesContent":["import {\n    compareModeToGlCompare,\n    mipmapScaleModeToGlFilter,\n    scaleModeToGlFilter,\n    wrapModeToGlAddress\n} from './pixiToGlMaps';\n\nimport type { TextureStyle } from '../../../shared/texture/TextureStyle';\n\n/**\n * @param style\n * @param gl\n * @param mipmaps\n * @param anisotropicExt\n * @param glFunctionName\n * @param firstParam\n * @param forceClamp\n * @param firstCreation\n * @internal\n */\nexport function applyStyleParams(\n    style: TextureStyle,\n    gl: WebGL2RenderingContext,\n    mipmaps: boolean,\n    // eslint-disable-next-line camelcase\n    anisotropicExt: EXT_texture_filter_anisotropic,\n    glFunctionName: 'samplerParameteri' | 'texParameteri',\n    firstParam: 3553 | WebGLSampler,\n    forceClamp: boolean,\n    /** if true we can skip setting certain values if the values is the same as the default gl values */\n    firstCreation: boolean\n)\n{\n    const castParam = firstParam as 3553;\n\n    if (!firstCreation\n        || style.addressModeU !== 'repeat'\n        || style.addressModeV !== 'repeat'\n        || style.addressModeW !== 'repeat'\n    )\n    {\n        // 1. set the wrapping mode\n        const wrapModeS = wrapModeToGlAddress[forceClamp ? 'clamp-to-edge' : style.addressModeU];\n        const wrapModeT = wrapModeToGlAddress[forceClamp ? 'clamp-to-edge' : style.addressModeV];\n        const wrapModeR = wrapModeToGlAddress[forceClamp ? 'clamp-to-edge' : style.addressModeW];\n\n        gl[glFunctionName](castParam, gl.TEXTURE_WRAP_S, wrapModeS);\n        gl[glFunctionName](castParam, gl.TEXTURE_WRAP_T, wrapModeT);\n\n        // does not exist in webGL1\n        if (gl.TEXTURE_WRAP_R) gl[glFunctionName](castParam, gl.TEXTURE_WRAP_R, wrapModeR);\n    }\n\n    if (!firstCreation || style.magFilter !== 'linear')\n    {\n        // 2. set the filtering mode\n        gl[glFunctionName](castParam, gl.TEXTURE_MAG_FILTER, scaleModeToGlFilter[style.magFilter]);\n    }\n\n    // assuming the currently bound texture is the one we want to set the filter for\n    // the only smelly part of this code, WebGPU is much better here :P\n    if (mipmaps)\n    {\n        if (!firstCreation || style.mipmapFilter !== 'linear')\n        {\n            const glFilterMode = mipmapScaleModeToGlFilter[style.minFilter][style.mipmapFilter];\n\n            gl[glFunctionName](castParam, gl.TEXTURE_MIN_FILTER, glFilterMode);\n        }\n    }\n\n    else\n    {\n        gl[glFunctionName](castParam, gl.TEXTURE_MIN_FILTER, scaleModeToGlFilter[style.minFilter]);\n    }\n\n    // 3. set the anisotropy\n    if (anisotropicExt && style.maxAnisotropy > 1)\n    {\n        const level = Math.min(style.maxAnisotropy, gl.getParameter(anisotropicExt.MAX_TEXTURE_MAX_ANISOTROPY_EXT));\n\n        gl[glFunctionName](castParam, anisotropicExt.TEXTURE_MAX_ANISOTROPY_EXT, level);\n    }\n\n    // 4. set the compare mode\n    if (style.compare)\n    {\n        gl[glFunctionName](castParam, gl.TEXTURE_COMPARE_FUNC, compareModeToGlCompare[style.compare]);\n    }\n}\n"],"names":["wrapModeToGlAddress","scaleModeToGlFilter","mipmapScaleModeToGlFilter","compareModeToGlCompare"],"mappings":";;;;;AAoBO,SAAS,gBAAA,CACZ,OACA,EAAA,EACA,OAAA,EAEA,gBACA,cAAA,EACA,UAAA,EACA,YAEA,aAAA,EAEJ;AACI,EAAA,MAAM,SAAA,GAAY,UAAA;AAElB,EAAA,IAAI,CAAC,aAAA,IACE,KAAA,CAAM,YAAA,KAAiB,QAAA,IACvB,MAAM,YAAA,KAAiB,QAAA,IACvB,KAAA,CAAM,YAAA,KAAiB,QAAA,EAE9B;AAEI,IAAA,MAAM,SAAA,GAAYA,gCAAA,CAAoB,UAAA,GAAa,eAAA,GAAkB,MAAM,YAAY,CAAA;AACvF,IAAA,MAAM,SAAA,GAAYA,gCAAA,CAAoB,UAAA,GAAa,eAAA,GAAkB,MAAM,YAAY,CAAA;AACvF,IAAA,MAAM,SAAA,GAAYA,gCAAA,CAAoB,UAAA,GAAa,eAAA,GAAkB,MAAM,YAAY,CAAA;AAEvF,IAAA,EAAA,CAAG,cAAc,CAAA,CAAE,SAAA,EAAW,EAAA,CAAG,gBAAgB,SAAS,CAAA;AAC1D,IAAA,EAAA,CAAG,cAAc,CAAA,CAAE,SAAA,EAAW,EAAA,CAAG,gBAAgB,SAAS,CAAA;AAG1D,IAAA,IAAI,EAAA,CAAG,gBAAgB,EAAA,CAAG,cAAc,EAAE,SAAA,EAAW,EAAA,CAAG,gBAAgB,SAAS,CAAA;AAAA,EACrF;AAEA,EAAA,IAAI,CAAC,aAAA,IAAiB,KAAA,CAAM,SAAA,KAAc,QAAA,EAC1C;AAEI,IAAA,EAAA,CAAG,cAAc,EAAE,SAAA,EAAW,EAAA,CAAG,oBAAoBC,gCAAA,CAAoB,KAAA,CAAM,SAAS,CAAC,CAAA;AAAA,EAC7F;AAIA,EAAA,IAAI,OAAA,EACJ;AACI,IAAA,IAAI,CAAC,aAAA,IAAiB,KAAA,CAAM,YAAA,KAAiB,QAAA,EAC7C;AACI,MAAA,MAAM,eAAeC,sCAAA,CAA0B,KAAA,CAAM,SAAS,CAAA,CAAE,MAAM,YAAY,CAAA;AAElF,MAAA,EAAA,CAAG,cAAc,CAAA,CAAE,SAAA,EAAW,EAAA,CAAG,oBAAoB,YAAY,CAAA;AAAA,IACrE;AAAA,EACJ,CAAA,MAGA;AACI,IAAA,EAAA,CAAG,cAAc,EAAE,SAAA,EAAW,EAAA,CAAG,oBAAoBD,gCAAA,CAAoB,KAAA,CAAM,SAAS,CAAC,CAAA;AAAA,EAC7F;AAGA,EAAA,IAAI,cAAA,IAAkB,KAAA,CAAM,aAAA,GAAgB,CAAA,EAC5C;AACI,IAAA,MAAM,KAAA,GAAQ,KAAK,GAAA,CAAI,KAAA,CAAM,eAAe,EAAA,CAAG,YAAA,CAAa,cAAA,CAAe,8BAA8B,CAAC,CAAA;AAE1G,IAAA,EAAA,CAAG,cAAc,CAAA,CAAE,SAAA,EAAW,cAAA,CAAe,4BAA4B,KAAK,CAAA;AAAA,EAClF;AAGA,EAAA,IAAI,MAAM,OAAA,EACV;AACI,IAAA,EAAA,CAAG,cAAc,EAAE,SAAA,EAAW,EAAA,CAAG,sBAAsBE,mCAAA,CAAuB,KAAA,CAAM,OAAO,CAAC,CAAA;AAAA,EAChG;AACJ;;;;"}
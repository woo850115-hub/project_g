{"version":3,"file":"Bounds.js","sources":["../../../../src/scene/container/bounds/Bounds.ts"],"sourcesContent":["import { Matrix } from '../../../maths/matrix/Matrix';\nimport { Rectangle } from '../../../maths/shapes/Rectangle';\n\n/**\n * A simple axis-aligned bounding box (AABB) data structure used to define rectangular boundaries.\n * Provides a clearer alternative to array-based bounds representation [minX, minY, maxX, maxY].\n * @example\n * ```ts\n * // Create bounds data\n * const bounds: BoundsData = {\n *     minX: 0,\n *     minY: 0,\n *     maxX: 100,\n *     maxY: 100\n * };\n *\n * // Calculate dimensions\n * const width = bounds.maxX - bounds.minX;\n * const height = bounds.maxY - bounds.minY;\n *\n * // Check if point is inside\n * const isInside = (x: number, y: number) =>\n *     x >= bounds.minX && x <= bounds.maxX &&\n *     y >= bounds.minY && y <= bounds.maxY;\n * ```\n * @see {@link Bounds} For full bounds implementation\n * @see {@link Container#getBounds} For getting bounds\n * @category rendering\n * @standard\n */\nexport interface BoundsData\n{\n    /** The minimum X coordinate of the bounds */\n    minX: number;\n    /** The minimum Y coordinate of the bounds */\n    minY: number;\n    /** The maximum X coordinate of the bounds */\n    maxX: number;\n    /** The maximum Y coordinate of the bounds */\n    maxY: number;\n}\n\nconst defaultMatrix = new Matrix();\n\n// TODO optimisations\n// 1 - get rectangle could use a dirty flag, rather than setting the data each time is called\n// 2- getFrame ALWAYS assumes a matrix, could be optimised to avoid the matrix calculation if not needed\n\n/**\n * A representation of an axis-aligned bounding box (AABB) used for efficient collision detection and culling.\n * Stores minimum and maximum coordinates to define a rectangular boundary.\n * @example\n * ```ts\n * // Create bounds\n * const bounds = new Bounds();\n *\n * // Add a rectangular frame\n * bounds.addFrame(0, 0, 100, 100);\n * console.log(bounds.width, bounds.height); // 100, 100\n *\n * // Transform bounds\n * const matrix = new Matrix()\n *     .translate(50, 50)\n *     .rotate(Math.PI / 4);\n * bounds.applyMatrix(matrix);\n *\n * // Check point intersection\n * if (bounds.containsPoint(75, 75)) {\n *     console.log('Point is inside bounds!');\n * }\n * ```\n * @category rendering\n * @standard\n */\nexport class Bounds\n{\n    /**\n     * The minimum X coordinate of the bounds.\n     * Represents the leftmost edge of the bounding box.\n     * @example\n     * ```ts\n     * const bounds = new Bounds();\n     * // Set left edge\n     * bounds.minX = 100;\n     * ```\n     * @default Infinity\n     */\n    public minX = Infinity;\n\n    /**\n     * The minimum Y coordinate of the bounds.\n     * Represents the topmost edge of the bounding box.\n     * @example\n     * ```ts\n     * const bounds = new Bounds();\n     * // Set top edge\n     * bounds.minY = 100;\n     * ```\n     * @default Infinity\n     */\n    public minY = Infinity;\n\n    /**\n     * The maximum X coordinate of the bounds.\n     * Represents the rightmost edge of the bounding box.\n     * @example\n     * ```ts\n     * const bounds = new Bounds();\n     * // Set right edge\n     * bounds.maxX = 200;\n     * // Get width\n     * const width = bounds.maxX - bounds.minX;\n     * ```\n     * @default -Infinity\n     */\n    public maxX = -Infinity;\n\n    /**\n     * The maximum Y coordinate of the bounds.\n     * Represents the bottommost edge of the bounding box.\n     * @example\n     * ```ts\n     * const bounds = new Bounds();\n     * // Set bottom edge\n     * bounds.maxY = 200;\n     * // Get height\n     * const height = bounds.maxY - bounds.minY;\n     * ```\n     * @default -Infinity\n     */\n    public maxY = -Infinity;\n\n    /**\n     * The transformation matrix applied to this bounds object.\n     * Used when calculating bounds with transforms.\n     * @example\n     * ```ts\n     * const bounds = new Bounds();\n     *\n     * // Apply translation matrix\n     * bounds.matrix = new Matrix()\n     *     .translate(100, 100);\n     *\n     * // Combine transformations\n     * bounds.matrix = new Matrix()\n     *     .translate(50, 50)\n     *     .rotate(Math.PI / 4)\n     *     .scale(2, 2);\n     *\n     * // Use in bounds calculations\n     * bounds.addFrame(0, 0, 100, 100); // Uses current matrix\n     * bounds.addFrame(0, 0, 100, 100, customMatrix); // Override matrix\n     * ```\n     * @advanced\n     */\n    public matrix = defaultMatrix;\n\n    private _rectangle: Rectangle;\n\n    /**\n     * Creates a new Bounds object.\n     * @param minX - The minimum X coordinate of the bounds.\n     * @param minY - The minimum Y coordinate of the bounds.\n     * @param maxX - The maximum X coordinate of the bounds.\n     * @param maxY - The maximum Y coordinate of the bounds.\n     */\n    constructor(minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity)\n    {\n        this.minX = minX;\n        this.minY = minY;\n        this.maxX = maxX;\n        this.maxY = maxY;\n    }\n\n    /**\n     * Checks if bounds are empty, meaning either width or height is zero or negative.\n     * Empty bounds occur when min values exceed max values on either axis.\n     * @example\n     * ```ts\n     * const bounds = new Bounds();\n     *\n     * // Check if newly created bounds are empty\n     * console.log(bounds.isEmpty()); // true, default bounds are empty\n     *\n     * // Add frame and check again\n     * bounds.addFrame(0, 0, 100, 100);\n     * console.log(bounds.isEmpty()); // false, bounds now have area\n     *\n     * // Clear bounds\n     * bounds.clear();\n     * console.log(bounds.isEmpty()); // true, bounds are empty again\n     * ```\n     * @returns True if bounds are empty (have no area)\n     * @see {@link Bounds#clear} For resetting bounds\n     * @see {@link Bounds#isValid} For checking validity\n     */\n    public isEmpty(): boolean\n    {\n        return this.minX > this.maxX || this.minY > this.maxY;\n    }\n\n    /**\n     * The bounding rectangle representation of these bounds.\n     * Lazily creates and updates a Rectangle instance based on the current bounds.\n     * @example\n     * ```ts\n     * const bounds = new Bounds(0, 0, 100, 100);\n     *\n     * // Get rectangle representation\n     * const rect = bounds.rectangle;\n     * console.log(rect.x, rect.y, rect.width, rect.height);\n     *\n     * // Use for hit testing\n     * if (bounds.rectangle.contains(mouseX, mouseY)) {\n     *     console.log('Mouse is inside bounds!');\n     * }\n     * ```\n     * @see {@link Rectangle} For rectangle methods\n     * @see {@link Bounds.isEmpty} For bounds validation\n     */\n    get rectangle(): Rectangle\n    {\n        if (!this._rectangle)\n        {\n            this._rectangle = new Rectangle();\n        }\n\n        const rectangle = this._rectangle;\n\n        if (this.minX > this.maxX || this.minY > this.maxY)\n        {\n            rectangle.x = 0;\n            rectangle.y = 0;\n            rectangle.width = 0;\n            rectangle.height = 0;\n        }\n        else\n        {\n            rectangle.copyFromBounds(this);\n        }\n\n        return rectangle;\n    }\n\n    /**\n     * Clears the bounds and resets all coordinates to their default values.\n     * Resets the transformation matrix back to identity.\n     * @example\n     * ```ts\n     * const bounds = new Bounds(0, 0, 100, 100);\n     * console.log(bounds.isEmpty()); // false\n     * // Clear the bounds\n     * bounds.clear();\n     * console.log(bounds.isEmpty()); // true\n     * ```\n     * @returns This bounds object for chaining\n     */\n    public clear(): this\n    {\n        this.minX = Infinity;\n        this.minY = Infinity;\n        this.maxX = -Infinity;\n        this.maxY = -Infinity;\n\n        this.matrix = defaultMatrix;\n\n        return this;\n    }\n\n    /**\n     * Sets the bounds directly using coordinate values.\n     * Provides a way to set all bounds values at once.\n     * @example\n     * ```ts\n     * const bounds = new Bounds();\n     * bounds.set(0, 0, 100, 100);\n     * ```\n     * @param x0 - Left X coordinate of frame\n     * @param y0 - Top Y coordinate of frame\n     * @param x1 - Right X coordinate of frame\n     * @param y1 - Bottom Y coordinate of frame\n     * @see {@link Bounds#addFrame} For matrix-aware bounds setting\n     * @see {@link Bounds#clear} For resetting bounds\n     */\n    public set(x0: number, y0: number, x1: number, y1: number)\n    {\n        this.minX = x0;\n        this.minY = y0;\n        this.maxX = x1;\n        this.maxY = y1;\n    }\n\n    /**\n     * Adds a rectangular frame to the bounds, optionally transformed by a matrix.\n     * Updates the bounds to encompass the new frame coordinates.\n     * @example\n     * ```ts\n     * const bounds = new Bounds();\n     * bounds.addFrame(0, 0, 100, 100);\n     *\n     * // Add transformed frame\n     * const matrix = new Matrix()\n     *     .translate(50, 50)\n     *     .rotate(Math.PI / 4);\n     * bounds.addFrame(0, 0, 100, 100, matrix);\n     * ```\n     * @param x0 - Left X coordinate of frame\n     * @param y0 - Top Y coordinate of frame\n     * @param x1 - Right X coordinate of frame\n     * @param y1 - Bottom Y coordinate of frame\n     * @param matrix - Optional transformation matrix\n     * @see {@link Bounds#addRect} For adding Rectangle objects\n     * @see {@link Bounds#addBounds} For adding other Bounds\n     */\n    public addFrame(x0: number, y0: number, x1: number, y1: number, matrix?: Matrix): void\n    {\n        matrix ||= this.matrix;\n\n        const a = matrix.a;\n        const b = matrix.b;\n        const c = matrix.c;\n        const d = matrix.d;\n        const tx = matrix.tx;\n        const ty = matrix.ty;\n\n        let minX = this.minX;\n        let minY = this.minY;\n        let maxX = this.maxX;\n        let maxY = this.maxY;\n\n        let x = (a * x0) + (c * y0) + tx;\n        let y = (b * x0) + (d * y0) + ty;\n\n        if (x < minX) minX = x;\n        if (y < minY) minY = y;\n        if (x > maxX) maxX = x;\n        if (y > maxY) maxY = y;\n\n        x = (a * x1) + (c * y0) + tx;\n        y = (b * x1) + (d * y0) + ty;\n\n        if (x < minX) minX = x;\n        if (y < minY) minY = y;\n        if (x > maxX) maxX = x;\n        if (y > maxY) maxY = y;\n\n        x = (a * x0) + (c * y1) + tx;\n        y = (b * x0) + (d * y1) + ty;\n\n        if (x < minX) minX = x;\n        if (y < minY) minY = y;\n        if (x > maxX) maxX = x;\n        if (y > maxY) maxY = y;\n\n        x = (a * x1) + (c * y1) + tx;\n        y = (b * x1) + (d * y1) + ty;\n\n        if (x < minX) minX = x;\n        if (y < minY) minY = y;\n        if (x > maxX) maxX = x;\n        if (y > maxY) maxY = y;\n\n        this.minX = minX;\n        this.minY = minY;\n        this.maxX = maxX;\n        this.maxY = maxY;\n    }\n\n    /**\n     * Adds a rectangle to the bounds, optionally transformed by a matrix.\n     * Updates the bounds to encompass the given rectangle.\n     * @example\n     * ```ts\n     * const bounds = new Bounds();\n     * // Add simple rectangle\n     * const rect = new Rectangle(0, 0, 100, 100);\n     * bounds.addRect(rect);\n     *\n     * // Add transformed rectangle\n     * const matrix = new Matrix()\n     *     .translate(50, 50)\n     *     .rotate(Math.PI / 4);\n     * bounds.addRect(rect, matrix);\n     * ```\n     * @param rect - The rectangle to be added\n     * @param matrix - Optional transformation matrix\n     * @see {@link Bounds#addFrame} For adding raw coordinates\n     * @see {@link Bounds#addBounds} For adding other bounds\n     */\n    public addRect(rect: Rectangle, matrix?: Matrix)\n    {\n        this.addFrame(rect.x, rect.y, rect.x + rect.width, rect.y + rect.height, matrix);\n    }\n\n    /**\n     * Adds another bounds object to this one, optionally transformed by a matrix.\n     * Expands the bounds to include the given bounds' area.\n     * @example\n     * ```ts\n     * const bounds = new Bounds();\n     *\n     * // Add child bounds\n     * const childBounds = sprite.getBounds();\n     * bounds.addBounds(childBounds);\n     *\n     * // Add transformed bounds\n     * const matrix = new Matrix()\n     *     .scale(2, 2);\n     * bounds.addBounds(childBounds, matrix);\n     * ```\n     * @param bounds - The bounds to be added\n     * @param matrix - Optional transformation matrix\n     * @see {@link Bounds#addFrame} For adding raw coordinates\n     * @see {@link Bounds#addRect} For adding rectangles\n     */\n    public addBounds(bounds: BoundsData, matrix?: Matrix)\n    {\n        this.addFrame(bounds.minX, bounds.minY, bounds.maxX, bounds.maxY, matrix);\n    }\n\n    /**\n     * Adds other Bounds as a mask, creating an intersection of the two bounds.\n     * Only keeps the overlapping region between current bounds and mask bounds.\n     * @example\n     * ```ts\n     * const bounds = new Bounds(0, 0, 100, 100);\n     * // Create mask bounds\n     * const mask = new Bounds();\n     * mask.addFrame(50, 50, 150, 150);\n     * // Apply mask - results in bounds of (50,50,100,100)\n     * bounds.addBoundsMask(mask);\n     * ```\n     * @param mask - The Bounds to use as a mask\n     * @see {@link Bounds#addBounds} For union operation\n     * @see {@link Bounds#fit} For fitting to rectangle\n     */\n    public addBoundsMask(mask: Bounds): void\n    {\n        this.minX = this.minX > mask.minX ? this.minX : mask.minX;\n        this.minY = this.minY > mask.minY ? this.minY : mask.minY;\n        this.maxX = this.maxX < mask.maxX ? this.maxX : mask.maxX;\n        this.maxY = this.maxY < mask.maxY ? this.maxY : mask.maxY;\n    }\n\n    /**\n     * Applies a transformation matrix to the bounds, updating its coordinates.\n     * Transforms all corners of the bounds using the given matrix.\n     * @example\n     * ```ts\n     * const bounds = new Bounds(0, 0, 100, 100);\n     * // Apply translation\n     * const translateMatrix = new Matrix()\n     *     .translate(50, 50);\n     * bounds.applyMatrix(translateMatrix);\n     * ```\n     * @param matrix - The matrix to apply to the bounds\n     * @see {@link Matrix} For matrix operations\n     * @see {@link Bounds#addFrame} For adding transformed frames\n     */\n    public applyMatrix(matrix: Matrix): void\n    {\n        const minX = this.minX;\n        const minY = this.minY;\n        const maxX = this.maxX;\n        const maxY = this.maxY;\n\n        // multiple bounds by matrix\n        const { a, b, c, d, tx, ty } = matrix;\n\n        let x = (a * minX) + (c * minY) + tx;\n        let y = (b * minX) + (d * minY) + ty;\n\n        this.minX = x;\n        this.minY = y;\n        this.maxX = x;\n        this.maxY = y;\n\n        x = (a * maxX) + (c * minY) + tx;\n        y = (b * maxX) + (d * minY) + ty;\n        this.minX = x < this.minX ? x : this.minX;\n        this.minY = y < this.minY ? y : this.minY;\n        this.maxX = x > this.maxX ? x : this.maxX;\n        this.maxY = y > this.maxY ? y : this.maxY;\n\n        x = (a * minX) + (c * maxY) + tx;\n        y = (b * minX) + (d * maxY) + ty;\n        this.minX = x < this.minX ? x : this.minX;\n        this.minY = y < this.minY ? y : this.minY;\n        this.maxX = x > this.maxX ? x : this.maxX;\n        this.maxY = y > this.maxY ? y : this.maxY;\n\n        x = (a * maxX) + (c * maxY) + tx;\n        y = (b * maxX) + (d * maxY) + ty;\n        this.minX = x < this.minX ? x : this.minX;\n        this.minY = y < this.minY ? y : this.minY;\n        this.maxX = x > this.maxX ? x : this.maxX;\n        this.maxY = y > this.maxY ? y : this.maxY;\n    }\n\n    /**\n     * Resizes the bounds object to fit within the given rectangle.\n     * Clips the bounds if they extend beyond the rectangle's edges.\n     * @example\n     * ```ts\n     * const bounds = new Bounds(0, 0, 200, 200);\n     * // Fit within viewport\n     * const viewport = new Rectangle(50, 50, 100, 100);\n     * bounds.fit(viewport);\n     * // bounds are now (50, 50, 150, 150)\n     * ```\n     * @param rect - The rectangle to fit within\n     * @returns This bounds object for chaining\n     * @see {@link Bounds#addBoundsMask} For intersection\n     * @see {@link Bounds#pad} For expanding bounds\n     */\n    public fit(rect: Rectangle): this\n    {\n        if (this.minX < rect.left) this.minX = rect.left;\n        if (this.maxX > rect.right) this.maxX = rect.right;\n\n        if (this.minY < rect.top) this.minY = rect.top;\n        if (this.maxY > rect.bottom) this.maxY = rect.bottom;\n\n        return this;\n    }\n\n    /**\n     * Resizes the bounds object to include the given bounds.\n     * Similar to fit() but works with raw coordinate values instead of a Rectangle.\n     * @example\n     * ```ts\n     * const bounds = new Bounds(0, 0, 200, 200);\n     * // Fit to specific coordinates\n     * bounds.fitBounds(50, 150, 50, 150);\n     * // bounds are now (50, 50, 150, 150)\n     * ```\n     * @param left - The left value of the bounds\n     * @param right - The right value of the bounds\n     * @param top - The top value of the bounds\n     * @param bottom - The bottom value of the bounds\n     * @returns This bounds object for chaining\n     * @see {@link Bounds#fit} For fitting to Rectangle\n     * @see {@link Bounds#addBoundsMask} For intersection\n     */\n    public fitBounds(left: number, right: number, top: number, bottom: number): this\n    {\n        if (this.minX < left) this.minX = left;\n        if (this.maxX > right) this.maxX = right;\n\n        if (this.minY < top) this.minY = top;\n        if (this.maxY > bottom) this.maxY = bottom;\n\n        return this;\n    }\n\n    /**\n     * Pads bounds object, making it grow in all directions.\n     * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.\n     * @example\n     * ```ts\n     * const bounds = new Bounds(0, 0, 100, 100);\n     *\n     * // Add equal padding\n     * bounds.pad(10);\n     * // bounds are now (-10, -10, 110, 110)\n     *\n     * // Add different padding for x and y\n     * bounds.pad(20, 10);\n     * // bounds are now (-30, -20, 130, 120)\n     * ```\n     * @param paddingX - The horizontal padding amount\n     * @param paddingY - The vertical padding amount\n     * @returns This bounds object for chaining\n     * @see {@link Bounds#fit} For constraining bounds\n     * @see {@link Bounds#scale} For uniform scaling\n     */\n    public pad(paddingX: number, paddingY: number = paddingX): this\n    {\n        this.minX -= paddingX;\n        this.maxX += paddingX;\n\n        this.minY -= paddingY;\n        this.maxY += paddingY;\n\n        return this;\n    }\n\n    /**\n     * Ceils the bounds by rounding up max values and rounding down min values.\n     * Useful for pixel-perfect calculations and avoiding fractional pixels.\n     * @example\n     * ```ts\n     * const bounds = new Bounds();\n     * bounds.set(10.2, 10.9, 50.1, 50.8);\n     *\n     * // Round to whole pixels\n     * bounds.ceil();\n     * // bounds are now (10, 10, 51, 51)\n     * ```\n     * @returns This bounds object for chaining\n     * @see {@link Bounds#scale} For size adjustments\n     * @see {@link Bounds#fit} For constraining bounds\n     */\n    public ceil(): this\n    {\n        this.minX = Math.floor(this.minX);\n        this.minY = Math.floor(this.minY);\n        this.maxX = Math.ceil(this.maxX);\n        this.maxY = Math.ceil(this.maxY);\n\n        return this;\n    }\n\n    /**\n     * Creates a new Bounds instance with the same values.\n     * @example\n     * ```ts\n     * const bounds = new Bounds(0, 0, 100, 100);\n     *\n     * // Create a copy\n     * const copy = bounds.clone();\n     *\n     * // Original and copy are independent\n     * bounds.pad(10);\n     * console.log(copy.width === bounds.width); // false\n     * ```\n     * @returns A new Bounds instance with the same values\n     * @see {@link Bounds#copyFrom} For reusing existing bounds\n     */\n    public clone(): Bounds\n    {\n        return new Bounds(this.minX, this.minY, this.maxX, this.maxY);\n    }\n\n    /**\n     * Scales the bounds by the given values, adjusting all edges proportionally.\n     * @example\n     * ```ts\n     * const bounds = new Bounds(0, 0, 100, 100);\n     *\n     * // Scale uniformly\n     * bounds.scale(2);\n     * // bounds are now (0, 0, 200, 200)\n     *\n     * // Scale non-uniformly\n     * bounds.scale(0.5, 2);\n     * // bounds are now (0, 0, 100, 400)\n     * ```\n     * @param x - The X value to scale by\n     * @param y - The Y value to scale by (defaults to x)\n     * @returns This bounds object for chaining\n     * @see {@link Bounds#pad} For adding padding\n     * @see {@link Bounds#fit} For constraining size\n     */\n    public scale(x: number, y: number = x): this\n    {\n        this.minX *= x;\n        this.minY *= y;\n        this.maxX *= x;\n        this.maxY *= y;\n\n        return this;\n    }\n\n    /**\n     * The x position of the bounds in local space.\n     * Setting this value will move the bounds while maintaining its width.\n     * @example\n     * ```ts\n     * const bounds = new Bounds(0, 0, 100, 100);\n     * // Get x position\n     * console.log(bounds.x); // 0\n     *\n     * // Move bounds horizontally\n     * bounds.x = 50;\n     * console.log(bounds.minX, bounds.maxX); // 50, 150\n     *\n     * // Width stays the same\n     * console.log(bounds.width); // Still 100\n     * ```\n     */\n    get x(): number\n    {\n        return this.minX;\n    }\n    set x(value: number)\n    {\n        const width = this.maxX - this.minX;\n\n        this.minX = value;\n        this.maxX = value + width;\n    }\n\n    /**\n     * The y position of the bounds in local space.\n     * Setting this value will move the bounds while maintaining its height.\n     * @example\n     * ```ts\n     * const bounds = new Bounds(0, 0, 100, 100);\n     * // Get y position\n     * console.log(bounds.y); // 0\n     *\n     * // Move bounds vertically\n     * bounds.y = 50;\n     * console.log(bounds.minY, bounds.maxY); // 50, 150\n     *\n     * // Height stays the same\n     * console.log(bounds.height); // Still 100\n     * ```\n     */\n    get y(): number\n    {\n        return this.minY;\n    }\n\n    set y(value: number)\n    {\n        const height = this.maxY - this.minY;\n\n        this.minY = value;\n        this.maxY = value + height;\n    }\n\n    /**\n     * The width value of the bounds.\n     * Represents the distance between minX and maxX coordinates.\n     * @example\n     * ```ts\n     * const bounds = new Bounds(0, 0, 100, 100);\n     * // Get width\n     * console.log(bounds.width); // 100\n     * // Resize width\n     * bounds.width = 200;\n     * console.log(bounds.maxX - bounds.minX); // 200\n     * ```\n     */\n    get width(): number\n    {\n        return this.maxX - this.minX;\n    }\n\n    set width(value: number)\n    {\n        this.maxX = this.minX + value;\n    }\n\n    /**\n     * The height value of the bounds.\n     * Represents the distance between minY and maxY coordinates.\n     * @example\n     * ```ts\n     * const bounds = new Bounds(0, 0, 100, 100);\n     * // Get height\n     * console.log(bounds.height); // 100\n     * // Resize height\n     * bounds.height = 150;\n     * console.log(bounds.maxY - bounds.minY); // 150\n     * ```\n     */\n    get height(): number\n    {\n        return this.maxY - this.minY;\n    }\n\n    set height(value: number)\n    {\n        this.maxY = this.minY + value;\n    }\n\n    /**\n     * The left edge coordinate of the bounds.\n     * Alias for minX.\n     * @example\n     * ```ts\n     * const bounds = new Bounds(50, 0, 150, 100);\n     * console.log(bounds.left); // 50\n     * console.log(bounds.left === bounds.minX); // true\n     * ```\n     * @readonly\n     */\n    get left(): number\n    {\n        return this.minX;\n    }\n\n    /**\n     * The right edge coordinate of the bounds.\n     * Alias for maxX.\n     * @example\n     * ```ts\n     * const bounds = new Bounds(0, 0, 100, 100);\n     * console.log(bounds.right); // 100\n     * console.log(bounds.right === bounds.maxX); // true\n     * ```\n     * @readonly\n     */\n    get right(): number\n    {\n        return this.maxX;\n    }\n\n    /**\n     * The top edge coordinate of the bounds.\n     * Alias for minY.\n     * @example\n     * ```ts\n     * const bounds = new Bounds(0, 25, 100, 125);\n     * console.log(bounds.top); // 25\n     * console.log(bounds.top === bounds.minY); // true\n     * ```\n     * @readonly\n     */\n    get top(): number\n    {\n        return this.minY;\n    }\n\n    /**\n     * The bottom edge coordinate of the bounds.\n     * Alias for maxY.\n     * @example\n     * ```ts\n     * const bounds = new Bounds(0, 0, 100, 200);\n     * console.log(bounds.bottom); // 200\n     * console.log(bounds.bottom === bounds.maxY); // true\n     * ```\n     * @readonly\n     */\n    get bottom(): number\n    {\n        return this.maxY;\n    }\n\n    /**\n     * Whether the bounds has positive width and height.\n     * Checks if both dimensions are greater than zero.\n     * @example\n     * ```ts\n     * const bounds = new Bounds(0, 0, 100, 100);\n     * // Check if bounds are positive\n     * console.log(bounds.isPositive); // true\n     *\n     * // Negative bounds\n     * bounds.maxX = bounds.minX;\n     * console.log(bounds.isPositive); // false, width is 0\n     * ```\n     * @readonly\n     * @see {@link Bounds#isEmpty} For checking empty state\n     * @see {@link Bounds#isValid} For checking validity\n     */\n    get isPositive(): boolean\n    {\n        return (this.maxX - this.minX > 0) && (this.maxY - this.minY > 0);\n    }\n\n    /**\n     * Whether the bounds has valid coordinates.\n     * Checks if the bounds has been initialized with real values.\n     * @example\n     * ```ts\n     * const bounds = new Bounds();\n     * console.log(bounds.isValid); // false, default state\n     *\n     * // Set valid bounds\n     * bounds.addFrame(0, 0, 100, 100);\n     * console.log(bounds.isValid); // true\n     * ```\n     * @readonly\n     * @see {@link Bounds#isEmpty} For checking empty state\n     * @see {@link Bounds#isPositive} For checking dimensions\n     */\n    get isValid(): boolean\n    {\n        return (this.minX + this.minY !== Infinity);\n    }\n\n    /**\n     * Adds vertices from a Float32Array to the bounds, optionally transformed by a matrix.\n     * Used for efficiently updating bounds from raw vertex data.\n     * @example\n     * ```ts\n     * const bounds = new Bounds();\n     *\n     * // Add vertices from geometry\n     * const vertices = new Float32Array([\n     *     0, 0,    // Vertex 1\n     *     100, 0,  // Vertex 2\n     *     100, 100 // Vertex 3\n     * ]);\n     * bounds.addVertexData(vertices, 0, 6);\n     *\n     * // Add transformed vertices\n     * const matrix = new Matrix()\n     *     .translate(50, 50)\n     *     .rotate(Math.PI / 4);\n     * bounds.addVertexData(vertices, 0, 6, matrix);\n     *\n     * // Add subset of vertices\n     * bounds.addVertexData(vertices, 2, 4); // Only second vertex\n     * ```\n     * @param vertexData - The array of vertices to add\n     * @param beginOffset - Starting index in the vertex array\n     * @param endOffset - Ending index in the vertex array (excluded)\n     * @param matrix - Optional transformation matrix\n     * @see {@link Bounds#addFrame} For adding rectangular frames\n     * @see {@link Matrix} For transformation details\n     */\n    public addVertexData(vertexData: Float32Array, beginOffset: number, endOffset: number, matrix?: Matrix): void\n    {\n        let minX = this.minX;\n        let minY = this.minY;\n        let maxX = this.maxX;\n        let maxY = this.maxY;\n\n        matrix ||= this.matrix;\n\n        const a = matrix.a;\n        const b = matrix.b;\n        const c = matrix.c;\n        const d = matrix.d;\n        const tx = matrix.tx;\n        const ty = matrix.ty;\n\n        for (let i = beginOffset; i < endOffset; i += 2)\n        {\n            const localX = vertexData[i];\n            const localY = vertexData[i + 1];\n\n            const x = (a * localX) + (c * localY) + tx;\n            const y = (b * localX) + (d * localY) + ty;\n\n            minX = x < minX ? x : minX;\n            minY = y < minY ? y : minY;\n            maxX = x > maxX ? x : maxX;\n            maxY = y > maxY ? y : maxY;\n        }\n\n        this.minX = minX;\n        this.minY = minY;\n        this.maxX = maxX;\n        this.maxY = maxY;\n    }\n\n    /**\n     * Checks if a point is contained within the bounds.\n     * Returns true if the point's coordinates fall within the bounds' area.\n     * @example\n     * ```ts\n     * const bounds = new Bounds(0, 0, 100, 100);\n     * // Basic point check\n     * console.log(bounds.containsPoint(50, 50)); // true\n     * console.log(bounds.containsPoint(150, 150)); // false\n     *\n     * // Check edges\n     * console.log(bounds.containsPoint(0, 0));   // true, includes edges\n     * console.log(bounds.containsPoint(100, 100)); // true, includes edges\n     * ```\n     * @param x - x coordinate to check\n     * @param y - y coordinate to check\n     * @returns True if the point is inside the bounds\n     * @see {@link Bounds#isPositive} For valid bounds check\n     * @see {@link Bounds#rectangle} For Rectangle representation\n     */\n    public containsPoint(x: number, y: number): boolean\n    {\n        if (this.minX <= x && this.minY <= y && this.maxX >= x && this.maxY >= y)\n        {\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Returns a string representation of the bounds.\n     * Useful for debugging and logging bounds information.\n     * @example\n     * ```ts\n     * const bounds = new Bounds(0, 0, 100, 100);\n     * console.log(bounds.toString()); // \"[pixi.js:Bounds minX=0 minY=0 maxX=100 maxY=100 width=100 height=100]\"\n     * ```\n     * @returns A string describing the bounds\n     * @see {@link Bounds#copyFrom} For copying bounds\n     * @see {@link Bounds#clone} For creating a new instance\n     */\n    public toString(): string\n    {\n        // eslint-disable-next-line max-len\n        return `[pixi.js:Bounds minX=${this.minX} minY=${this.minY} maxX=${this.maxX} maxY=${this.maxY} width=${this.width} height=${this.height}]`;\n    }\n\n    /**\n     * Copies the bounds from another bounds object.\n     * Useful for reusing bounds objects and avoiding allocations.\n     * @example\n     * ```ts\n     * const sourceBounds = new Bounds(0, 0, 100, 100);\n     * // Copy bounds\n     * const targetBounds = new Bounds();\n     * targetBounds.copyFrom(sourceBounds);\n     * ```\n     * @param bounds - The bounds to copy from\n     * @returns This bounds object for chaining\n     * @see {@link Bounds#clone} For creating new instances\n     */\n    public copyFrom(bounds: Bounds): this\n    {\n        this.minX = bounds.minX;\n        this.minY = bounds.minY;\n        this.maxX = bounds.maxX;\n        this.maxY = bounds.maxY;\n\n        return this;\n    }\n}\n\n"],"names":["Matrix","Rectangle"],"mappings":"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"}
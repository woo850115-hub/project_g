{"version":3,"file":"RenderGroupSystem.mjs","sources":["../../../src/scene/container/RenderGroupSystem.ts"],"sourcesContent":["import { ExtensionType } from '../../extensions/Extensions';\nimport { Matrix } from '../../maths/matrix/Matrix';\nimport { TexturePool } from '../../rendering/renderers/shared/texture/TexturePool';\nimport { TextureStyle } from '../../rendering/renderers/shared/texture/TextureStyle';\nimport { Bounds } from './bounds/Bounds';\nimport { clearList } from './utils/clearList';\nimport { executeInstructions } from './utils/executeInstructions';\nimport { updateRenderGroupTransforms } from './utils/updateRenderGroupTransforms';\nimport { validateRenderables } from './utils/validateRenderables';\n\nimport type { WebGPURenderer } from '../../rendering/renderers/gpu/WebGPURenderer';\nimport type { System } from '../../rendering/renderers/shared/system/System';\nimport type { Renderer, RenderPipes } from '../../rendering/renderers/types';\nimport type { ViewContainer } from '../view/ViewContainer';\nimport type { Container } from './Container';\nimport type { RenderGroup } from './RenderGroup';\n\nconst tempMatrix = new Matrix();\n\n/**\n * The view system manages the main canvas that is attached to the DOM.\n * This main role is to deal with how the holding the view reference and dealing with how it is resized.\n * @category rendering\n * @internal\n */\nexport class RenderGroupSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'renderGroup',\n    } as const;\n\n    private readonly _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    protected render({ container, transform }: {container: Container, transform: Matrix}): void\n    {\n        // we need to save the parent and renderGroupParent, so we can restore them later\n        const parent = container.parent;\n        const renderGroupParent = container.renderGroup.renderGroupParent;\n\n        // we set the transforms and parents to null, so we can render the container without any transforms\n        container.parent = null;\n        container.renderGroup.renderGroupParent = null;\n\n        const renderer = this._renderer;\n\n        // collect all the renderGroups in the scene and then render them one by one..\n        const originalLocalTransform: Matrix = tempMatrix;\n\n        if (transform)\n        {\n            originalLocalTransform.copyFrom(container.renderGroup.localTransform);\n            container.renderGroup.localTransform.copyFrom(transform);\n        }\n\n        //  this._assignTop(container.renderGroup, null);\n        const renderPipes = (renderer as WebGPURenderer).renderPipes;\n\n        this._updateCachedRenderGroups(container.renderGroup, null);\n\n        this._updateRenderGroups(container.renderGroup);\n\n        renderer.globalUniforms.start({\n            worldTransformMatrix: transform ? container.renderGroup.localTransform : container.renderGroup.worldTransform,\n            worldColor: container.renderGroup.worldColorAlpha,\n        });\n\n        executeInstructions(container.renderGroup, renderPipes);\n\n        // TODO need to add some events / runners for things like this to hook up to\n        if (renderPipes.uniformBatch)\n        {\n            renderPipes.uniformBatch.renderEnd();\n        }\n\n        // now return the transforms back to normal..\n        if (transform)\n        {\n            container.renderGroup.localTransform.copyFrom(originalLocalTransform);\n        }\n\n        container.parent = parent;\n        container.renderGroup.renderGroupParent = renderGroupParent;\n    }\n\n    public destroy()\n    {\n        (this._renderer as null) = null;\n    }\n\n    private _updateCachedRenderGroups(renderGroup: RenderGroup, closestCacheAsTexture: RenderGroup | null): void\n    {\n        renderGroup._parentCacheAsTextureRenderGroup = closestCacheAsTexture;\n\n        if (renderGroup.isCachedAsTexture)\n        {\n            // Early out as nothing further needs to be updated!\n            if (!renderGroup.textureNeedsUpdate) return;\n\n            closestCacheAsTexture = renderGroup;\n        }\n\n        // Update the closest cache reference for children if this render group is cached as texture\n        for (let i = renderGroup.renderGroupChildren.length - 1; i >= 0; i--)\n        {\n            this._updateCachedRenderGroups(renderGroup.renderGroupChildren[i], closestCacheAsTexture);\n        }\n\n        renderGroup.invalidateMatrices();\n\n        if (renderGroup.isCachedAsTexture)\n        {\n            if (renderGroup.textureNeedsUpdate)\n            {\n                // lets get the texture ready for rendering\n                // but the rendering will not happen until the renderGroup is rendered!\n                // We also want to know now, what the bounds of the texture will be.\n                // as if the texture changes, we need to invalidate the parent render group!\n                const bounds = renderGroup.root.getLocalBounds();\n                const renderer = this._renderer;\n                const resolution = renderGroup.textureOptions.resolution || renderer.view.resolution;\n                const antialias = renderGroup.textureOptions.antialias ?? renderer.view.antialias;\n                const scaleMode = renderGroup.textureOptions.scaleMode ?? 'linear';\n                const lastTexture = renderGroup.texture;\n\n                bounds.ceil();\n\n                if (renderGroup.texture)\n                {\n                    TexturePool.returnTexture(renderGroup.texture, true);\n                }\n\n                const texture = TexturePool.getOptimalTexture(\n                    bounds.width,\n                    bounds.height,\n                    resolution,\n                    antialias\n                );\n\n                texture._source.style = new TextureStyle({ scaleMode });\n                renderGroup.texture = texture;\n                renderGroup._textureBounds ||= new Bounds();\n                renderGroup._textureBounds.copyFrom(bounds);\n\n                if (lastTexture !== renderGroup.texture)\n                {\n                    if (renderGroup.renderGroupParent)\n                    {\n                        renderGroup.renderGroupParent.structureDidChange = true;\n                    }\n                }\n            }\n        }\n        else if (renderGroup.texture)\n        {\n            TexturePool.returnTexture(renderGroup.texture, true);\n            renderGroup.texture = null;\n        }\n    }\n\n    private _updateRenderGroups(renderGroup: RenderGroup): void\n    {\n        const renderer = this._renderer;\n        const renderPipes = renderer.renderPipes;\n\n        renderGroup.runOnRender(renderer);\n\n        renderGroup.instructionSet.renderPipes = renderPipes;\n\n        if (!renderGroup.structureDidChange)\n        {\n            // phase 1 - validate all the renderables\n            validateRenderables(renderGroup, renderPipes);\n        }\n        else\n        {\n            clearList(renderGroup.childrenRenderablesToUpdate.list, 0);\n        }\n\n        // phase 2 - update all the transforms\n        // including updating the renderables..\n        updateRenderGroupTransforms(renderGroup);\n\n        if (renderGroup.structureDidChange)\n        {\n            renderGroup.structureDidChange = false;\n\n            // build the renderables\n            this._buildInstructions(renderGroup, renderer);\n        }\n        else\n        {\n            // update remaining renderables\n            this._updateRenderables(renderGroup);\n        }\n\n        // reset the renderables to update\n        renderGroup.childrenRenderablesToUpdate.index = 0;\n\n        // upload all the things!\n        renderer.renderPipes.batch.upload(renderGroup.instructionSet);\n\n        // early out if it's a texture and it hasn't changed!\n        if (renderGroup.isCachedAsTexture && !renderGroup.textureNeedsUpdate) return;\n\n        for (let i = 0; i < renderGroup.renderGroupChildren.length; i++)\n        {\n            this._updateRenderGroups(renderGroup.renderGroupChildren[i]);\n        }\n    }\n\n    private _updateRenderables(renderGroup: RenderGroup)\n    {\n        const { list, index } = renderGroup.childrenRenderablesToUpdate;\n\n        for (let i = 0; i < index; i++)\n        {\n            const container = list[i];\n\n            if (container.didViewUpdate)\n            {\n                renderGroup.updateRenderable(container as ViewContainer);\n            }\n        }\n\n        clearList(list, index);\n    }\n\n    /**\n     * @param renderGroup\n     * @param renderPipes\n     * @deprecated since 8.3.0\n     */\n    private _buildInstructions(renderGroup: RenderGroup, renderPipes: RenderPipes): void;\n    private _buildInstructions(renderGroup: RenderGroup, renderer: Renderer): void;\n    private _buildInstructions(renderGroup: RenderGroup, rendererOrPipes: RenderPipes | Renderer): void\n    {\n    // rebuild the scene graph based on layers...\n        const root = renderGroup.root;\n        const instructionSet = renderGroup.instructionSet;\n\n        instructionSet.reset();\n\n        // deprecate the use of renderPipes by finding the renderer attached to the batch pipe as this is always there\n        const renderer = (rendererOrPipes as Renderer).renderPipes\n            ? (rendererOrPipes as Renderer)\n            : (rendererOrPipes as RenderPipes).batch.renderer;\n        const renderPipes = renderer.renderPipes;\n\n        // TODO add some events / runners for build start\n        renderPipes.batch.buildStart(instructionSet);\n        renderPipes.blendMode.buildStart();\n        renderPipes.colorMask.buildStart();\n\n        if (root.sortableChildren)\n        {\n            root.sortChildren();\n        }\n\n        root.collectRenderablesWithEffects(instructionSet, renderer, null);\n\n        // TODO add some events / runners for build end\n        renderPipes.batch.buildEnd(instructionSet);\n        renderPipes.blendMode.buildEnd(instructionSet);\n    }\n}\n\n"],"names":[],"mappings":"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"}
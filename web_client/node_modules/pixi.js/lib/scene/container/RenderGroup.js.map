{"version":3,"file":"RenderGroup.js","sources":["../../../src/scene/container/RenderGroup.ts"],"sourcesContent":["import { Matrix } from '../../maths/matrix/Matrix';\nimport { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport { type SCALE_MODE } from '../../rendering/renderers/shared/texture/const';\nimport { TexturePool } from '../../rendering/renderers/shared/texture/TexturePool';\nimport { type Renderer } from '../../rendering/renderers/types';\n\nimport type { Instruction } from '../../rendering/renderers/shared/instructions/Instruction';\nimport type { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport type { BatchableSprite } from '../sprite/BatchableSprite';\nimport type { ViewContainer } from '../view/ViewContainer';\nimport type { Bounds } from './bounds/Bounds';\nimport type { Container } from './Container';\n\n/**\n * Options for caching a container as a texture.\n * @category rendering\n * @advanced\n */\nexport interface CacheAsTextureOptions\n{\n    /**\n     * If true, the texture will be antialiased. This smooths out the edges of the texture.\n     * @default false\n     */\n    antialias?: boolean;\n    /**\n     * The resolution of the texture. A higher resolution means a sharper texture but uses more memory.\n     * By default the resolution is 1 which is the same as the rendererers resolution.\n     */\n    resolution?: number;\n    /**\n     * Scale Mode to use for the cached texture\n     * @type {SCALE_MODE}\n     * @default 'linear'\n     * @example\n     * ```ts\n     * const container = new Container();\n     * container.cacheAsTexture({ scaleMode: 'nearest' });\n     * ```\n     * @see {@link SCALE_MODE}\n     */\n    scaleMode?: SCALE_MODE;\n}\n\n/**\n * A RenderGroup is a class that is responsible for I generating a set of instructions that are used to render the\n * root container and its children. It also watches for any changes in that container or its children,\n * these changes are analysed and either the instruction set is rebuild or the instructions data is updated.\n * @category rendering\n * @advanced\n */\nexport class RenderGroup implements Instruction\n{\n    public renderPipeId = 'renderGroup';\n    public root: Container = null;\n\n    public canBundle = false;\n\n    public renderGroupParent: RenderGroup = null;\n    public renderGroupChildren: RenderGroup[] = [];\n\n    public worldTransform: Matrix = new Matrix();\n    public worldColorAlpha = 0xffffffff;\n    public worldColor = 0xffffff;\n    public worldAlpha = 1;\n\n    // these updates are transform changes..\n    public readonly childrenToUpdate: Record<number, { list: Container[]; index: number; }> = Object.create(null);\n    public updateTick = 0;\n    public gcTick = 0;\n\n    // these update are renderable changes..\n    public readonly childrenRenderablesToUpdate: { list: Container[]; index: number; } = { list: [], index: 0 };\n\n    // other\n    public structureDidChange = true;\n\n    public instructionSet: InstructionSet = new InstructionSet();\n\n    private readonly _onRenderContainers: Container[] = [];\n\n    /**\n     * Indicates if the cached texture needs to be updated.\n     * @default true\n     */\n    public textureNeedsUpdate = true;\n\n    /**\n     * Indicates if the container should be cached as a texture.\n     * @default false\n     */\n    public isCachedAsTexture = false;\n\n    /**\n     * The texture used for caching the container. this is only set if isCachedAsTexture is true.\n     * It can only be accessed after a render pass.\n     * @type {Texture | undefined}\n     */\n    public texture?: Texture;\n\n    /**\n     * The bounds of the cached texture.\n     * @type {Bounds | undefined}\n     * @ignore\n     */\n    public _textureBounds?: Bounds;\n\n    /**\n     * The options for caching the container as a texture.\n     * @type {CacheAsTextureOptions}\n     */\n    public textureOptions: CacheAsTextureOptions;\n\n    /**\n     *  holds a reference to the batchable render sprite\n     *  @ignore\n     */\n    public _batchableRenderGroup: BatchableSprite;\n\n    /**\n     * Holds a reference to the closest parent RenderGroup that has isCachedAsTexture enabled.\n     * This is used to properly transform coordinates when rendering into cached textures.\n     * @type {RenderGroup | null}\n     * @ignore\n     */\n    public _parentCacheAsTextureRenderGroup: RenderGroup;\n\n    private _inverseWorldTransform: Matrix;\n    private _textureOffsetInverseTransform: Matrix;\n    private _inverseParentTextureTransform: Matrix;\n\n    private _matrixDirty = 0b111;\n\n    public init(root: Container)\n    {\n        this.root = root;\n\n        if (root._onRender) this.addOnRender(root);\n\n        root.didChange = true;\n\n        const children = root.children;\n\n        for (let i = 0; i < children.length; i++)\n        {\n            const child = children[i];\n\n            // make sure the children are all updated on the first pass..\n            child._updateFlags = 0b1111;\n\n            this.addChild(child);\n        }\n    }\n\n    public enableCacheAsTexture(options: CacheAsTextureOptions = {}): void\n    {\n        this.textureOptions = options;\n        this.isCachedAsTexture = true;\n        this.textureNeedsUpdate = true;\n    }\n\n    public disableCacheAsTexture(): void\n    {\n        this.isCachedAsTexture = false;\n        if (this.texture)\n        {\n            TexturePool.returnTexture(this.texture, true);\n            this.texture = null;\n        }\n    }\n\n    public updateCacheTexture(): void\n    {\n        this.textureNeedsUpdate = true;\n\n        const cachedParent = this._parentCacheAsTextureRenderGroup;\n\n        // It's worth going bottom-up and notify all parents cached as texture\n        // that cached child was updated.\n        if (cachedParent && !cachedParent.textureNeedsUpdate)\n        {\n            cachedParent.updateCacheTexture();\n        }\n    }\n\n    public reset()\n    {\n        this.renderGroupChildren.length = 0;\n\n        for (const i in this.childrenToUpdate)\n        {\n            const childrenAtDepth = this.childrenToUpdate[i];\n\n            childrenAtDepth.list.fill(null);\n            childrenAtDepth.index = 0;\n        }\n\n        this.childrenRenderablesToUpdate.index = 0;\n        this.childrenRenderablesToUpdate.list.fill(null);\n\n        this.root = null;\n        this.updateTick = 0;\n        this.structureDidChange = true;\n\n        this._onRenderContainers.length = 0;\n        this.renderGroupParent = null;\n\n        this.disableCacheAsTexture();\n    }\n\n    get localTransform()\n    {\n        return this.root.localTransform;\n    }\n\n    public addRenderGroupChild(renderGroupChild: RenderGroup)\n    {\n        if (renderGroupChild.renderGroupParent)\n        {\n            renderGroupChild.renderGroupParent._removeRenderGroupChild(renderGroupChild);\n        }\n\n        renderGroupChild.renderGroupParent = this;\n\n        this.renderGroupChildren.push(renderGroupChild);\n    }\n\n    private _removeRenderGroupChild(renderGroupChild: RenderGroup)\n    {\n        const index = this.renderGroupChildren.indexOf(renderGroupChild);\n\n        if (index > -1)\n        {\n            this.renderGroupChildren.splice(index, 1);\n        }\n\n        renderGroupChild.renderGroupParent = null;\n    }\n\n    public addChild(child: Container)\n    {\n        this.structureDidChange = true;\n\n        child.parentRenderGroup = this;\n\n        child.updateTick = -1;\n\n        if (child.parent === this.root)\n        {\n            child.relativeRenderGroupDepth = 1;\n        }\n        else\n        {\n            child.relativeRenderGroupDepth = child.parent.relativeRenderGroupDepth + 1;\n        }\n\n        child.didChange = true;\n        this.onChildUpdate(child);\n\n        if (child.renderGroup)\n        {\n            this.addRenderGroupChild(child.renderGroup);\n\n            return;\n        }\n\n        if (child._onRender) this.addOnRender(child);\n\n        const children = child.children;\n\n        for (let i = 0; i < children.length; i++)\n        {\n            this.addChild(children[i]);\n        }\n    }\n\n    public removeChild(child: Container)\n    {\n        // remove all the children...\n        this.structureDidChange = true;\n\n        if (child._onRender)\n        {\n            // Remove the child to the onRender list under the following conditions:\n            // 1. If the child is not a render group.\n            // 2. If the child is a render group root of this render group - which it can't be removed from in this case.\n            if (!child.renderGroup)\n            {\n                this.removeOnRender(child);\n            }\n        }\n\n        child.parentRenderGroup = null;\n\n        if (child.renderGroup)\n        {\n            this._removeRenderGroupChild(child.renderGroup);\n\n            return;\n        }\n\n        const children = child.children;\n\n        for (let i = 0; i < children.length; i++)\n        {\n            this.removeChild(children[i]);\n        }\n    }\n\n    public removeChildren(children: Container[])\n    {\n        for (let i = 0; i < children.length; i++)\n        {\n            this.removeChild(children[i]);\n        }\n    }\n\n    public onChildUpdate(child: Container)\n    {\n        let childrenToUpdate = this.childrenToUpdate[child.relativeRenderGroupDepth];\n\n        if (!childrenToUpdate)\n        {\n            childrenToUpdate = this.childrenToUpdate[child.relativeRenderGroupDepth] = {\n                index: 0,\n                list: [],\n            };\n        }\n\n        childrenToUpdate.list[childrenToUpdate.index++] = child;\n    }\n\n    public updateRenderable(renderable: ViewContainer)\n    {\n        if (renderable.globalDisplayStatus < 0b111) return;\n        this.instructionSet.renderPipes[renderable.renderPipeId].updateRenderable(renderable);\n        renderable.didViewUpdate = false;\n    }\n\n    public onChildViewUpdate(child: Container)\n    {\n        this.childrenRenderablesToUpdate.list[this.childrenRenderablesToUpdate.index++] = child;\n    }\n\n    get isRenderable(): boolean\n    {\n        return (this.root.localDisplayStatus === 0b111 && this.worldAlpha > 0);\n    }\n\n    /**\n     * adding a container to the onRender list will make sure the user function\n     * passed in to the user defined 'onRender` callBack\n     * @param container - the container to add to the onRender list\n     */\n    public addOnRender(container: Container)\n    {\n        this._onRenderContainers.push(container);\n    }\n\n    public removeOnRender(container: Container)\n    {\n        this._onRenderContainers.splice(this._onRenderContainers.indexOf(container), 1);\n    }\n\n    public runOnRender(renderer: Renderer)\n    {\n        for (let i = 0; i < this._onRenderContainers.length; i++)\n        {\n            this._onRenderContainers[i]._onRender(renderer);\n        }\n    }\n\n    public destroy()\n    {\n        this.disableCacheAsTexture();\n\n        this.renderGroupParent = null;\n        this.root = null;\n        (this.childrenRenderablesToUpdate as any) = null;\n        (this.childrenToUpdate as any) = null;\n        (this.renderGroupChildren as any) = null;\n        (this._onRenderContainers as any) = null;\n        this.instructionSet = null;\n    }\n\n    public getChildren(out: Container[] = []): Container[]\n    {\n        const children = this.root.children;\n\n        for (let i = 0; i < children.length; i++)\n        {\n            this._getChildren(children[i], out);\n        }\n\n        return out;\n    }\n\n    private _getChildren(container: Container, out: Container[] = []): Container[]\n    {\n        out.push(container);\n\n        if (container.renderGroup) return out;\n\n        const children = container.children;\n\n        for (let i = 0; i < children.length; i++)\n        {\n            this._getChildren(children[i], out);\n        }\n\n        return out;\n    }\n\n    public invalidateMatrices()\n    {\n        this._matrixDirty = 0b111;\n    }\n\n    /**\n     * Returns the inverse of the world transform matrix.\n     * @returns {Matrix} The inverse of the world transform matrix.\n     */\n    public get inverseWorldTransform()\n    {\n        if ((this._matrixDirty & 0b001) === 0) return this._inverseWorldTransform;\n\n        this._matrixDirty &= ~0b001;\n\n        // TODO - add dirty flag\n        this._inverseWorldTransform ||= new Matrix();\n\n        return this._inverseWorldTransform\n            .copyFrom(this.worldTransform)\n            .invert();\n    }\n\n    /**\n     * Returns the inverse of the texture offset transform matrix.\n     * @returns {Matrix} The inverse of the texture offset transform matrix.\n     */\n    public get textureOffsetInverseTransform()\n    {\n        if ((this._matrixDirty & 0b010) === 0) return this._textureOffsetInverseTransform;\n\n        this._matrixDirty &= ~0b010;\n\n        this._textureOffsetInverseTransform ||= new Matrix();\n\n        // TODO shared.. bad!\n        return this._textureOffsetInverseTransform\n            .copyFrom(this.inverseWorldTransform)\n            .translate(\n                -this._textureBounds.x,\n                -this._textureBounds.y\n            );\n    }\n\n    /**\n     * Returns the inverse of the parent texture transform matrix.\n     * This is used to properly transform coordinates when rendering into cached textures.\n     * @returns {Matrix} The inverse of the parent texture transform matrix.\n     */\n    public get inverseParentTextureTransform()\n    {\n        if ((this._matrixDirty & 0b100) === 0) return this._inverseParentTextureTransform;\n\n        this._matrixDirty &= ~0b100;\n\n        const parentCacheAsTexture = this._parentCacheAsTextureRenderGroup;\n\n        if (parentCacheAsTexture)\n        {\n            this._inverseParentTextureTransform ||= new Matrix();\n\n            // Get relative transform by removing parent's world transform\n            return this._inverseParentTextureTransform\n                .copyFrom(this.worldTransform)\n                .prepend(parentCacheAsTexture.inverseWorldTransform)\n                // Offset by texture bounds\n                .translate(\n                    -parentCacheAsTexture._textureBounds.x,\n                    -parentCacheAsTexture._textureBounds.y\n                );\n        }\n\n        return this.worldTransform;\n    }\n\n    /**\n     * Returns a matrix that transforms coordinates to the correct coordinate space of the texture being rendered to.\n     * This is the texture offset inverse transform of the closest parent RenderGroup that is cached as a texture.\n     * @returns {Matrix | null} The transform matrix for the cached texture coordinate space,\n     * or null if no parent is cached as texture.\n     */\n    public get cacheToLocalTransform()\n    {\n        if (this.isCachedAsTexture)\n        {\n            return this.textureOffsetInverseTransform;\n        }\n\n        if (!this._parentCacheAsTextureRenderGroup) return null;\n\n        return this._parentCacheAsTextureRenderGroup.textureOffsetInverseTransform;\n    }\n}\n"],"names":["Matrix","InstructionSet","TexturePool"],"mappings":"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"}
{"version":3,"file":"Sprite.mjs","sources":["../../../src/scene/sprite/Sprite.ts"],"sourcesContent":["import { ObservablePoint } from '../../maths/point/ObservablePoint';\nimport { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport { updateQuadBounds } from '../../utils/data/updateQuadBounds';\nimport { deprecation } from '../../utils/logging/deprecation';\nimport { ViewContainer, type ViewContainerOptions } from '../view/ViewContainer';\nimport { type BatchableSprite } from './BatchableSprite';\n\nimport type { Size } from '../../maths/misc/Size';\nimport type { PointData } from '../../maths/point/PointData';\nimport type { TextureSourceLike } from '../../rendering/renderers/shared/texture/Texture';\nimport type { BoundsData } from '../container/bounds/Bounds';\nimport type { Optional } from '../container/container-mixins/measureMixin';\nimport type { DestroyOptions } from '../container/destroyTypes';\n\n/**\n * Options for configuring a Sprite instance. Defines the texture, anchor point, and rendering behavior.\n * @example\n * ```ts\n * // Create a basic sprite with texture\n * const sprite = new Sprite({\n *     texture: Texture.from('sprite.png')\n * });\n *\n * // Create a centered sprite with rounded position\n * const centeredSprite = new Sprite({\n *     texture: Texture.from('centered.png'),\n *     anchor: 0.5,        // Center point\n *     roundPixels: true,  // Crisp rendering\n *     x: 100,            // Position from ViewContainerOptions\n *     y: 100\n * });\n *\n * // Create a sprite with specific anchor points\n * const anchoredSprite = new Sprite({\n *     texture: Texture.from('corner.png'),\n *     anchor: {\n *         x: 1,  // Right-aligned\n *         y: 0   // Top-aligned\n *     }\n * });\n * ```\n * @extends ViewContainerOptions\n * @category scene\n * @standard\n * @noInheritDoc\n */\nexport interface SpriteOptions extends PixiMixins.SpriteOptions, ViewContainerOptions\n{\n    /**\n     * The texture to use for the sprite. If not provided, uses Texture.EMPTY\n     * @default Texture.EMPTY\n     * @example\n     * ```ts\n     * // Create a sprite with a texture\n     * const sprite = new Sprite({\n     *     texture: Texture.from('path/to/image.png')\n     * });\n     * // Update the texture later\n     * sprite.texture = Texture.from('path/to/another-image.png');\n     * ```\n     */\n    texture?: Texture;\n\n    /**\n     * The anchor point of the sprite (0-1 range).\n     * Controls the origin point for rotation, scaling, and positioning.\n     * Can be a number for uniform anchor or a PointData for separate x/y values.\n     * @default 0\n     * @example\n     * ```ts\n     * // Centered anchor\n     * anchor: 0.5\n     * // Separate x/y anchor\n     * anchor: { x: 0.5, y: 0.5 }\n     * // Right-aligned anchor\n     * anchor: { x: 1, y: 0 }\n     * ```\n     */\n    anchor?: PointData | number;\n\n    /**\n     * Whether or not to round the x/y position to whole pixels.\n     * Useful for crisp pixel art style rendering.\n     * @default false\n     * @example\n     * ```ts\n     * const sprite = new Sprite({\n     *     texture: Texture.from('sprite.png'),\n     *     roundPixels: true // Ensures crisp rendering\n     * });\n     * ```\n     */\n    roundPixels?: boolean;\n}\n// eslint-disable-next-line requireExport/require-export-jsdoc, requireMemberAPI/require-member-api-doc\nexport interface Sprite extends PixiMixins.Sprite, ViewContainer<BatchableSprite> {}\n\n/**\n * The Sprite object is one of the most important objects in PixiJS. It is a\n * drawing item that can be added to a scene and rendered to the screen.\n * Sprites can display images, handle input events, and be transformed in various ways.\n * @example\n * ```ts\n * // Create a sprite directly from an image path\n * const sprite = Sprite.from('assets/image.png');\n * sprite.position.set(100, 100);\n * app.stage.addChild(sprite);\n *\n * // Create from a spritesheet (more efficient)\n * const sheet = await Assets.load('assets/spritesheet.json');\n * const sprite = new Sprite(sheet.textures['image.png']);\n *\n * // Create with specific options\n * const configuredSprite = new Sprite({\n *     texture: Texture.from('sprite.png'),\n *     anchor: 0.5,           // Center anchor point\n *     position: { x: 100, y: 100 },\n *     scale: { x: 2, y: 2 }, // Double size\n *     rotation: Math.PI / 4   // 45 degrees\n * });\n *\n * // Animate sprite properties\n * app.ticker.add(() => {\n *     sprite.rotation += 0.1;      // Rotate\n *     sprite.scale.x = Math.sin(performance.now() / 1000) + 1; // Pulse scale\n * });\n * ```\n * @category scene\n * @standard\n * @see {@link SpriteOptions} For configuration options\n * @see {@link Texture} For texture management\n * @see {@link Assets} For asset loading\n */\nexport class Sprite extends ViewContainer<BatchableSprite>\n{\n    /**\n     * Creates a new sprite based on a source texture, image, video, or canvas element.\n     * This is a convenience method that automatically creates and manages textures.\n     * @example\n     * ```ts\n     * // Create from path or URL\n     * const sprite = Sprite.from('assets/image.png');\n     *\n     * // Create from existing texture\n     * const sprite = Sprite.from(texture);\n     *\n     * // Create from canvas\n     * const canvas = document.createElement('canvas');\n     * const sprite = Sprite.from(canvas, true); // Skip caching new texture\n     * ```\n     * @param source - The source to create the sprite from. Can be a path to an image, a texture,\n     * or any valid texture source (canvas, video, etc.)\n     * @param skipCache - Whether to skip adding to the texture cache when creating a new texture\n     * @returns A new sprite based on the source\n     * @see {@link Texture.from} For texture creation details\n     * @see {@link Assets} For asset loading and management\n     */\n    public static from(source: Texture | TextureSourceLike, skipCache = false): Sprite\n    {\n        if (source instanceof Texture)\n        {\n            return new Sprite(source);\n        }\n\n        return new Sprite(Texture.from(source, skipCache));\n    }\n\n    /** @internal */\n    public override readonly renderPipeId: string = 'sprite';\n\n    /** @internal */\n    public batched = true;\n    /** @internal */\n    public readonly _anchor: ObservablePoint;\n\n    /** @internal */\n    public _texture: Texture;\n\n    private readonly _visualBounds: BoundsData = { minX: 0, maxX: 1, minY: 0, maxY: 0 };\n\n    private _width: number;\n    private _height: number;\n\n    /**\n     * @param options - The options for creating the sprite.\n     */\n    constructor(options: SpriteOptions | Texture = Texture.EMPTY)\n    {\n        if (options instanceof Texture)\n        {\n            options = { texture: options };\n        }\n\n        // split out\n        const { texture = Texture.EMPTY, anchor, roundPixels, width, height, ...rest } = options;\n\n        super({\n            label: 'Sprite',\n            ...rest\n        });\n\n        this._anchor = new ObservablePoint(\n            {\n                _onUpdate: () =>\n                {\n                    this.onViewUpdate();\n                }\n            },\n        );\n\n        if (anchor)\n        {\n            this.anchor = anchor;\n        }\n        else if (texture.defaultAnchor)\n        {\n            this.anchor = texture.defaultAnchor;\n        }\n\n        this.texture = texture;\n\n        this.allowChildren = false;\n        this.roundPixels = roundPixels ?? false;\n\n        // needs to be set after the container has initiated\n        if (width !== undefined) this.width = width;\n        if (height !== undefined) this.height = height;\n    }\n\n    set texture(value: Texture)\n    {\n        value ||= Texture.EMPTY;\n\n        const currentTexture = this._texture;\n\n        if (currentTexture === value) return;\n\n        if (currentTexture && currentTexture.dynamic) currentTexture.off('update', this.onViewUpdate, this);\n        if (value.dynamic) value.on('update', this.onViewUpdate, this);\n\n        this._texture = value;\n\n        if (this._width)\n        {\n            this._setWidth(this._width, this._texture.orig.width);\n        }\n\n        if (this._height)\n        {\n            this._setHeight(this._height, this._texture.orig.height);\n        }\n\n        this.onViewUpdate();\n    }\n\n    /**\n     * The texture that is displayed by the sprite. When changed, automatically updates\n     * the sprite dimensions and manages texture event listeners.\n     * @example\n     * ```ts\n     * // Create sprite with texture\n     * const sprite = new Sprite({\n     *     texture: Texture.from('sprite.png')\n     * });\n     *\n     * // Update texture\n     * sprite.texture = Texture.from('newSprite.png');\n     *\n     * // Use texture from spritesheet\n     * const sheet = await Assets.load('spritesheet.json');\n     * sprite.texture = sheet.textures['frame1.png'];\n     *\n     * // Reset to empty texture\n     * sprite.texture = Texture.EMPTY;\n     * ```\n     * @see {@link Texture} For texture creation and management\n     * @see {@link Assets} For asset loading\n     */\n    get texture()\n    {\n        return this._texture;\n    }\n\n    /**\n     * The bounds of the sprite, taking into account the texture's trim area.\n     * @example\n     * ```ts\n     * const texture = new Texture({\n     *     source: new TextureSource({ width: 300, height: 300 }),\n     *     frame: new Rectangle(196, 66, 58, 56),\n     *     trim: new Rectangle(4, 4, 58, 56),\n     *     orig: new Rectangle(0, 0, 64, 64),\n     *     rotate: 2,\n     * });\n     * const sprite = new Sprite(texture);\n     * const visualBounds = sprite.visualBounds;\n     * // console.log(visualBounds); // { minX: -4, maxX: 62, minY: -4, maxY: 60 }\n     */\n    get visualBounds()\n    {\n        updateQuadBounds(this._visualBounds, this._anchor, this._texture);\n\n        return this._visualBounds;\n    }\n\n    /**\n     * @deprecated\n     * @ignore\n     */\n    get sourceBounds()\n    {\n        // #if _DEBUG\n        deprecation('8.6.1', 'Sprite.sourceBounds is deprecated, use visualBounds instead.');\n        // #endif\n\n        return this.visualBounds;\n    }\n\n    /** @private */\n    protected updateBounds()\n    {\n        const anchor = this._anchor;\n        const texture = this._texture;\n\n        const bounds = this._bounds;\n\n        const { width, height } = texture.orig;\n\n        bounds.minX = -anchor._x * width;\n        bounds.maxX = bounds.minX + width;\n\n        bounds.minY = -anchor._y * height;\n        bounds.maxY = bounds.minY + height;\n    }\n\n    /**\n     * Destroys this sprite renderable and optionally its texture.\n     * @param options - Options parameter. A boolean will act as if all options\n     *  have been set to that value\n     * @example\n     * sprite.destroy();\n     * sprite.destroy(true);\n     * sprite.destroy({ texture: true, textureSource: true });\n     */\n    public override destroy(options: DestroyOptions = false)\n    {\n        super.destroy(options);\n\n        const destroyTexture = typeof options === 'boolean' ? options : options?.texture;\n\n        if (destroyTexture)\n        {\n            const destroyTextureSource = typeof options === 'boolean' ? options : options?.textureSource;\n\n            this._texture.destroy(destroyTextureSource);\n        }\n\n        this._texture = null;\n        (this._visualBounds as null) = null;\n        (this._bounds as null) = null;\n        (this._anchor as null) = null;\n    }\n\n    /**\n     * The anchor sets the origin point of the sprite. The default value is taken from the {@link Texture}\n     * and passed to the constructor.\n     *\n     * - The default is `(0,0)`, this means the sprite's origin is the top left.\n     * - Setting the anchor to `(0.5,0.5)` means the sprite's origin is centered.\n     * - Setting the anchor to `(1,1)` would mean the sprite's origin point will be the bottom right corner.\n     *\n     * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.\n     * @example\n     * ```ts\n     * // Center the anchor point\n     * sprite.anchor = 0.5; // Sets both x and y to 0.5\n     * sprite.position.set(400, 300); // Sprite will be centered at this position\n     *\n     * // Set specific x/y anchor points\n     * sprite.anchor = {\n     *     x: 1, // Right edge\n     *     y: 0  // Top edge\n     * };\n     *\n     * // Using individual coordinates\n     * sprite.anchor.set(0.5, 1); // Center-bottom\n     *\n     * // For rotation around center\n     * sprite.anchor.set(0.5);\n     * sprite.rotation = Math.PI / 4; // 45 degrees around center\n     *\n     * // For scaling from center\n     * sprite.anchor.set(0.5);\n     * sprite.scale.set(2); // Scales from center point\n     * ```\n     */\n    get anchor(): ObservablePoint\n    {\n        return this._anchor;\n    }\n\n    set anchor(value: PointData | number)\n    {\n        typeof value === 'number' ? this._anchor.set(value) : this._anchor.copyFrom(value);\n    }\n\n    /**\n     * The width of the sprite, setting this will actually modify the scale to achieve the value set.\n     * @example\n     * ```ts\n     * // Set width directly\n     * sprite.width = 200;\n     * console.log(sprite.scale.x); // Scale adjusted to match width\n     *\n     * // Set width while preserving aspect ratio\n     * const ratio = sprite.height / sprite.width;\n     * sprite.width = 300;\n     * sprite.height = 300 * ratio;\n     *\n     * // For better performance when setting both width and height\n     * sprite.setSize(300, 400); // Avoids recalculating bounds twice\n     *\n     * // Reset to original texture size\n     * sprite.width = sprite.texture.orig.width;\n     * ```\n     */\n    override get width(): number\n    {\n        return Math.abs(this.scale.x) * this._texture.orig.width;\n    }\n\n    override set width(value: number)\n    {\n        this._setWidth(value, this._texture.orig.width);\n        this._width = value;\n    }\n\n    /**\n     * The height of the sprite, setting this will actually modify the scale to achieve the value set.\n     * @example\n     * ```ts\n     * // Set height directly\n     * sprite.height = 150;\n     * console.log(sprite.scale.y); // Scale adjusted to match height\n     *\n     * // Set height while preserving aspect ratio\n     * const ratio = sprite.width / sprite.height;\n     * sprite.height = 200;\n     * sprite.width = 200 * ratio;\n     *\n     * // For better performance when setting both width and height\n     * sprite.setSize(300, 400); // Avoids recalculating bounds twice\n     *\n     * // Reset to original texture size\n     * sprite.height = sprite.texture.orig.height;\n     * ```\n     */\n    override get height(): number\n    {\n        return Math.abs(this.scale.y) * this._texture.orig.height;\n    }\n\n    override set height(value: number)\n    {\n        this._setHeight(value, this._texture.orig.height);\n        this._height = value;\n    }\n\n    /**\n     * Retrieves the size of the Sprite as a [Size]{@link Size} object based on the texture dimensions and scale.\n     * This is faster than getting width and height separately as it only calculates the bounds once.\n     * @example\n     * ```ts\n     * // Basic size retrieval\n     * const sprite = new Sprite(Texture.from('sprite.png'));\n     * const size = sprite.getSize();\n     * console.log(`Size: ${size.width}x${size.height}`);\n     *\n     * // Reuse existing size object\n     * const reuseSize = { width: 0, height: 0 };\n     * sprite.getSize(reuseSize);\n     * ```\n     * @param out - Optional object to store the size in, to avoid allocating a new object\n     * @returns The size of the Sprite\n     * @see {@link Sprite#width} For getting just the width\n     * @see {@link Sprite#height} For getting just the height\n     * @see {@link Sprite#setSize} For setting both width and height\n     */\n    public override getSize(out?: Size): Size\n    {\n        out ||= {} as Size;\n        out.width = Math.abs(this.scale.x) * this._texture.orig.width;\n        out.height = Math.abs(this.scale.y) * this._texture.orig.height;\n\n        return out;\n    }\n\n    /**\n     * Sets the size of the Sprite to the specified width and height.\n     * This is faster than setting width and height separately as it only recalculates bounds once.\n     * @example\n     * ```ts\n     * // Basic size setting\n     * const sprite = new Sprite(Texture.from('sprite.png'));\n     * sprite.setSize(100, 200); // Width: 100, Height: 200\n     *\n     * // Set uniform size\n     * sprite.setSize(100); // Sets both width and height to 100\n     *\n     * // Set size with object\n     * sprite.setSize({\n     *     width: 200,\n     *     height: 300\n     * });\n     *\n     * // Reset to texture size\n     * sprite.setSize(\n     *     sprite.texture.orig.width,\n     *     sprite.texture.orig.height\n     * );\n     * ```\n     * @param value - This can be either a number or a {@link Size} object\n     * @param height - The height to set. Defaults to the value of `width` if not provided\n     * @see {@link Sprite#width} For setting width only\n     * @see {@link Sprite#height} For setting height only\n     * @see {@link Sprite#texture} For the source dimensions\n     */\n    public override setSize(value: number | Optional<Size, 'height'>, height?: number)\n    {\n        if (typeof value === 'object')\n        {\n            height = value.height ?? value.width;\n            value = value.width;\n        }\n        else\n        {\n            height ??= value;\n        }\n\n        value !== undefined && this._setWidth(value, this._texture.orig.width);\n        height !== undefined && this._setHeight(height, this._texture.orig.height);\n    }\n}\n"],"names":[],"mappings":"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"}
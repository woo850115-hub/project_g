{"version":3,"file":"generateTextureFillMatrix.js","sources":["../../../../../src/scene/graphics/shared/utils/generateTextureFillMatrix.ts"],"sourcesContent":["import { Matrix } from '../../../../maths/matrix/Matrix';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport { FillGradient } from '../fill/FillGradient';\n\nimport type { ShapePrimitive } from '../../../../maths/shapes/ShapePrimitive';\nimport type { FillStyle, StrokeStyle } from '../FillTypes';\n\n/**\n * Temporary matrix used for matrix calculations\n * @internal\n */\nconst tempTextureMatrix = new Matrix();\n\n/**\n * Temporary rectangle used for bounds calculations\n * @internal\n */\nconst tempRect = new Rectangle();\n\n/**\n * Generates a texture matrix for mapping textures onto shapes.\n * This function handles both local and global texture space mapping.\n *\n * In local space, the texture is mapped to fit exactly within the bounds of the shape.\n * In global space, the texture is mapped using its own dimensions and position.\n * @param out - The matrix to store the result in\n * @param style - The fill style containing texture and mapping properties\n * @param shape - The shape to map the texture onto\n * @param matrix - Optional transform matrix to apply\n * @returns The generated texture matrix for UV mapping\n * @example\n * ```ts\n * const matrix = new Matrix();\n * const textureMatrix = generateTextureMatrix(matrix, fillStyle, shape);\n * // textureMatrix now contains the proper UV mapping for the texture\n * ```\n * @internal\n */\nexport function generateTextureMatrix(out: Matrix, style: FillStyle | StrokeStyle, shape: ShapePrimitive, matrix?: Matrix)\n{\n    // Start with either the style's matrix inverted, or identity matrix\n    const textureMatrix = style.matrix\n        ? out.copyFrom(style.matrix).invert()\n        : out.identity();\n\n    if (style.textureSpace === 'local')\n    {\n        // For local space, map texture to shape's bounds\n        const bounds = shape.getBounds(tempRect);\n\n        if ((style as StrokeStyle).width)\n        {\n            bounds.pad((style as StrokeStyle).width);\n        }\n\n        const { x: tx, y: ty } = bounds;\n        const sx = 1 / bounds.width;\n        const sy = 1 / bounds.height;\n\n        const mTx = -tx * sx;\n        const mTy = -ty * sy;\n\n        const a1 = textureMatrix.a;\n        const b1 = textureMatrix.b;\n        const c1 = textureMatrix.c;\n        const d1 = textureMatrix.d;\n\n        textureMatrix.a *= sx;\n        textureMatrix.b *= sx;\n        textureMatrix.c *= sy;\n        textureMatrix.d *= sy;\n\n        textureMatrix.tx = (mTx * a1) + (mTy * c1) + textureMatrix.tx;\n        textureMatrix.ty = (mTx * b1) + (mTy * d1) + textureMatrix.ty;\n    }\n    else\n    {\n        // For global space, use texture's own dimensions\n        textureMatrix.translate(style.texture.frame.x, style.texture.frame.y);\n        textureMatrix.scale(1 / (style.texture.source.width), 1 / (style.texture.source.height));\n    }\n\n    const sourceStyle = style.texture.source.style;\n\n    // we don't want to set the address mode if the fill is a gradient as this handles its own address mode\n    if (!(style.fill instanceof FillGradient) && sourceStyle.addressMode === 'clamp-to-edge')\n    {\n        sourceStyle.addressMode = 'repeat';\n        sourceStyle.update();\n    }\n\n    // Apply any additional transform matrix\n    if (matrix)\n    {\n        textureMatrix.append(tempTextureMatrix.copyFrom(matrix).invert());\n    }\n\n    return textureMatrix;\n}\n"],"names":["Matrix","Rectangle","FillGradient"],"mappings":";;;;;;;AAWA,MAAM,iBAAA,GAAoB,IAAIA,aAAA,EAAO;AAMrC,MAAM,QAAA,GAAW,IAAIC,mBAAA,EAAU;AAqBxB,SAAS,qBAAA,CAAsB,GAAA,EAAa,KAAA,EAAgC,KAAA,EAAuB,MAAA,EAC1G;AAEI,EAAA,MAAM,aAAA,GAAgB,KAAA,CAAM,MAAA,GACtB,GAAA,CAAI,QAAA,CAAS,KAAA,CAAM,MAAM,CAAA,CAAE,MAAA,EAAO,GAClC,GAAA,CAAI,QAAA,EAAS;AAEnB,EAAA,IAAI,KAAA,CAAM,iBAAiB,OAAA,EAC3B;AAEI,IAAA,MAAM,MAAA,GAAS,KAAA,CAAM,SAAA,CAAU,QAAQ,CAAA;AAEvC,IAAA,IAAK,MAAsB,KAAA,EAC3B;AACI,MAAA,MAAA,CAAO,GAAA,CAAK,MAAsB,KAAK,CAAA;AAAA,IAC3C;AAEA,IAAA,MAAM,EAAE,CAAA,EAAG,EAAA,EAAI,CAAA,EAAG,IAAG,GAAI,MAAA;AACzB,IAAA,MAAM,EAAA,GAAK,IAAI,MAAA,CAAO,KAAA;AACtB,IAAA,MAAM,EAAA,GAAK,IAAI,MAAA,CAAO,MAAA;AAEtB,IAAA,MAAM,GAAA,GAAM,CAAC,EAAA,GAAK,EAAA;AAClB,IAAA,MAAM,GAAA,GAAM,CAAC,EAAA,GAAK,EAAA;AAElB,IAAA,MAAM,KAAK,aAAA,CAAc,CAAA;AACzB,IAAA,MAAM,KAAK,aAAA,CAAc,CAAA;AACzB,IAAA,MAAM,KAAK,aAAA,CAAc,CAAA;AACzB,IAAA,MAAM,KAAK,aAAA,CAAc,CAAA;AAEzB,IAAA,aAAA,CAAc,CAAA,IAAK,EAAA;AACnB,IAAA,aAAA,CAAc,CAAA,IAAK,EAAA;AACnB,IAAA,aAAA,CAAc,CAAA,IAAK,EAAA;AACnB,IAAA,aAAA,CAAc,CAAA,IAAK,EAAA;AAEnB,IAAA,aAAA,CAAc,EAAA,GAAM,GAAA,GAAM,EAAA,GAAO,GAAA,GAAM,KAAM,aAAA,CAAc,EAAA;AAC3D,IAAA,aAAA,CAAc,EAAA,GAAM,GAAA,GAAM,EAAA,GAAO,GAAA,GAAM,KAAM,aAAA,CAAc,EAAA;AAAA,EAC/D,CAAA,MAEA;AAEI,IAAA,aAAA,CAAc,SAAA,CAAU,MAAM,OAAA,CAAQ,KAAA,CAAM,GAAG,KAAA,CAAM,OAAA,CAAQ,MAAM,CAAC,CAAA;AACpE,IAAA,aAAA,CAAc,KAAA,CAAM,CAAA,GAAK,KAAA,CAAM,OAAA,CAAQ,MAAA,CAAO,OAAQ,CAAA,GAAK,KAAA,CAAM,OAAA,CAAQ,MAAA,CAAO,MAAO,CAAA;AAAA,EAC3F;AAEA,EAAA,MAAM,WAAA,GAAc,KAAA,CAAM,OAAA,CAAQ,MAAA,CAAO,KAAA;AAGzC,EAAA,IAAI,EAAE,KAAA,CAAM,IAAA,YAAgBC,yBAAA,CAAA,IAAiB,WAAA,CAAY,gBAAgB,eAAA,EACzE;AACI,IAAA,WAAA,CAAY,WAAA,GAAc,QAAA;AAC1B,IAAA,WAAA,CAAY,MAAA,EAAO;AAAA,EACvB;AAGA,EAAA,IAAI,MAAA,EACJ;AACI,IAAA,aAAA,CAAc,OAAO,iBAAA,CAAkB,QAAA,CAAS,MAAM,CAAA,CAAE,QAAQ,CAAA;AAAA,EACpE;AAEA,EAAA,OAAO,aAAA;AACX;;;;"}
{"version":3,"file":"buildGeometryFromPath.mjs","sources":["../../../../../src/scene/graphics/shared/utils/buildGeometryFromPath.ts"],"sourcesContent":["import { buildSimpleUvs, buildUvs } from '../../../../rendering/renderers/shared/geometry/utils/buildUvs';\nimport { transformVertices } from '../../../../rendering/renderers/shared/geometry/utils/transformVertices';\nimport { MeshGeometry } from '../../../mesh/shared/MeshGeometry';\nimport { GraphicsPath } from '../path/GraphicsPath';\nimport { shapeBuilders } from './buildContextBatches';\n\nimport type { Matrix } from '../../../../maths/matrix/Matrix';\n\n/**\n * Options for building geometry from a graphics path.\n * Provides a possibility to specify a transformation Matrix for the texture's UVs and output mesh geometry.\n * @example\n * ```ts\n * const options: GeometryPathOptions = {\n *     path: new GraphicsPath().rect(0, 0, 64, 64),\n *     textureMatrix: new Matrix()\n *         .scale(2, 2)\n *         .rotate(Math.PI / 4),\n *     out: meshGeometry\n * };\n * const geometry:MeshGeometry = buildGeometryFromPath(options);\n * const mesh = new Mesh({\n *     geometry: meshGeometry,\n *     texture: bunnyTexture\n * });\n * ```\n * @category scene\n * @advanced\n */\nexport interface GeometryPathOptions\n{\n    /** the path to build the geometry from */\n    path: GraphicsPath\n    /** a `Matrix` that can be used to modify the texture UVs of the path being built */\n    textureMatrix?: Matrix\n    /** an optional `MeshGeometry` to write too instead of creating a new one*/\n    out?: MeshGeometry\n}\n\n/**\n * When building a mesh, it helps to leverage the simple API we have in `GraphicsPath` as it can often be easier to\n * define the geometry in a more human-readable way. This function takes a `GraphicsPath` and returns a `MeshGeometry`.\n * @example\n * ```ts\n *\n * const path = new GraphicsPath()\n *    .drawRect(0, 0, 100, 100)\n *\n * const geometry:MeshGeometry = buildGeometryFromPath(path);\n *\n * const mesh = new Mesh({geometry});\n *\n * ```\n * You can also pass in a Matrix to transform the uvs as by default you may want to control how they are set up.\n * @param options - either a `GraphicsPath` or `GeometryPathOptions`\n * @returns a new `MeshGeometry` instance build from the path\n * @category scene\n * @advanced\n */\nexport function buildGeometryFromPath(options: GraphicsPath | GeometryPathOptions): MeshGeometry\n{\n    if (options instanceof GraphicsPath)\n    {\n        options = {\n            path: options,\n            textureMatrix: null,\n            out: null,\n        };\n    }\n\n    const vertices: number[] = [];\n    const uvs: number[] = [];\n    const indices: number[] = [];\n\n    // build path collection of polygons and shapes points..\n    const shapePath = options.path.shapePath;\n    const textureMatrix = options.textureMatrix;\n\n    shapePath.shapePrimitives.forEach(({ shape, transform: matrix }) =>\n    {\n        const indexOffset = indices.length;\n        const vertOffset = vertices.length / 2;\n\n        const points: number[] = [];\n\n        const build = shapeBuilders[shape.type];\n\n        build.build(shape, points);\n\n        if (matrix)\n        {\n            transformVertices(points, matrix);\n        }\n\n        build.triangulate(points, vertices, 2, vertOffset, indices, indexOffset);\n\n        const uvsOffset = uvs.length / 2;\n\n        if (textureMatrix)\n        {\n            // todo can prolly do this before calculating uvs..\n            if (matrix)\n            {\n                textureMatrix.append(matrix.clone().invert());\n            }\n\n            buildUvs(vertices, 2, vertOffset, uvs, uvsOffset, 2, (vertices.length / 2) - vertOffset, textureMatrix);\n        }\n        else\n        {\n            buildSimpleUvs(uvs, uvsOffset, 2, (vertices.length / 2) - vertOffset);\n        }\n    });\n\n    const out = options.out;\n\n    if (out)\n    {\n        out.positions = new Float32Array(vertices);\n        out.uvs = new Float32Array(uvs);\n        out.indices = new Uint32Array(indices);\n\n        return out;\n    }\n\n    const geometry = new MeshGeometry({\n        positions: new Float32Array(vertices),\n        uvs: new Float32Array(uvs),\n        indices: new Uint32Array(indices),\n    });\n\n    return geometry;\n}\n"],"names":[],"mappings":";;;;;;;AA2DO,SAAS,sBAAsB,OAAA,EACtC;AACI,EAAA,IAAI,mBAAmB,YAAA,EACvB;AACI,IAAA,OAAA,GAAU;AAAA,MACN,IAAA,EAAM,OAAA;AAAA,MACN,aAAA,EAAe,IAAA;AAAA,MACf,GAAA,EAAK;AAAA,KACT;AAAA,EACJ;AAEA,EAAA,MAAM,WAAqB,EAAC;AAC5B,EAAA,MAAM,MAAgB,EAAC;AACvB,EAAA,MAAM,UAAoB,EAAC;AAG3B,EAAA,MAAM,SAAA,GAAY,QAAQ,IAAA,CAAK,SAAA;AAC/B,EAAA,MAAM,gBAAgB,OAAA,CAAQ,aAAA;AAE9B,EAAA,SAAA,CAAU,gBAAgB,OAAA,CAAQ,CAAC,EAAE,KAAA,EAAO,SAAA,EAAW,QAAO,KAC9D;AACI,IAAA,MAAM,cAAc,OAAA,CAAQ,MAAA;AAC5B,IAAA,MAAM,UAAA,GAAa,SAAS,MAAA,GAAS,CAAA;AAErC,IAAA,MAAM,SAAmB,EAAC;AAE1B,IAAA,MAAM,KAAA,GAAQ,aAAA,CAAc,KAAA,CAAM,IAAI,CAAA;AAEtC,IAAA,KAAA,CAAM,KAAA,CAAM,OAAO,MAAM,CAAA;AAEzB,IAAA,IAAI,MAAA,EACJ;AACI,MAAA,iBAAA,CAAkB,QAAQ,MAAM,CAAA;AAAA,IACpC;AAEA,IAAA,KAAA,CAAM,YAAY,MAAA,EAAQ,QAAA,EAAU,CAAA,EAAG,UAAA,EAAY,SAAS,WAAW,CAAA;AAEvE,IAAA,MAAM,SAAA,GAAY,IAAI,MAAA,GAAS,CAAA;AAE/B,IAAA,IAAI,aAAA,EACJ;AAEI,MAAA,IAAI,MAAA,EACJ;AACI,QAAA,aAAA,CAAc,MAAA,CAAO,MAAA,CAAO,KAAA,EAAM,CAAE,QAAQ,CAAA;AAAA,MAChD;AAEA,MAAA,QAAA,CAAS,QAAA,EAAU,CAAA,EAAG,UAAA,EAAY,GAAA,EAAK,SAAA,EAAW,GAAI,QAAA,CAAS,MAAA,GAAS,CAAA,GAAK,UAAA,EAAY,aAAa,CAAA;AAAA,IAC1G,CAAA,MAEA;AACI,MAAA,cAAA,CAAe,KAAK,SAAA,EAAW,CAAA,EAAI,QAAA,CAAS,MAAA,GAAS,IAAK,UAAU,CAAA;AAAA,IACxE;AAAA,EACJ,CAAC,CAAA;AAED,EAAA,MAAM,MAAM,OAAA,CAAQ,GAAA;AAEpB,EAAA,IAAI,GAAA,EACJ;AACI,IAAA,GAAA,CAAI,SAAA,GAAY,IAAI,YAAA,CAAa,QAAQ,CAAA;AACzC,IAAA,GAAA,CAAI,GAAA,GAAM,IAAI,YAAA,CAAa,GAAG,CAAA;AAC9B,IAAA,GAAA,CAAI,OAAA,GAAU,IAAI,WAAA,CAAY,OAAO,CAAA;AAErC,IAAA,OAAO,GAAA;AAAA,EACX;AAEA,EAAA,MAAM,QAAA,GAAW,IAAI,YAAA,CAAa;AAAA,IAC9B,SAAA,EAAW,IAAI,YAAA,CAAa,QAAQ,CAAA;AAAA,IACpC,GAAA,EAAK,IAAI,YAAA,CAAa,GAAG,CAAA;AAAA,IACzB,OAAA,EAAS,IAAI,WAAA,CAAY,OAAO;AAAA,GACnC,CAAA;AAED,EAAA,OAAO,QAAA;AACX;;;;"}
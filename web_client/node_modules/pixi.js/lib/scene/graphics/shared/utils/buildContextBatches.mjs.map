{"version":3,"file":"buildContextBatches.mjs","sources":["../../../../../src/scene/graphics/shared/utils/buildContextBatches.ts"],"sourcesContent":["import { extensions, ExtensionType } from '../../../../extensions/Extensions';\nimport { Matrix } from '../../../../maths/matrix/Matrix';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport { buildSimpleUvs, buildUvs } from '../../../../rendering/renderers/shared/geometry/utils/buildUvs';\nimport { transformVertices } from '../../../../rendering/renderers/shared/geometry/utils/transformVertices';\nimport { Texture } from '../../../../rendering/renderers/shared/texture/Texture';\nimport { BigPool } from '../../../../utils/pool/PoolGroup';\nimport { BatchableGraphics } from '../BatchableGraphics';\nimport { buildCircle, buildEllipse, buildRoundedRectangle } from '../buildCommands/buildCircle';\nimport { buildLine } from '../buildCommands/buildLine';\nimport { buildPixelLine } from '../buildCommands/buildPixelLine';\nimport { buildPolygon } from '../buildCommands/buildPolygon';\nimport { buildRectangle } from '../buildCommands/buildRectangle';\nimport { buildTriangle } from '../buildCommands/buildTriangle';\nimport { generateTextureMatrix as generateTextureFillMatrix } from './generateTextureFillMatrix';\nimport { triangulateWithHoles } from './triangulateWithHoles';\n\nimport type { Polygon } from '../../../../maths/shapes/Polygon';\nimport type { Topology } from '../../../../rendering/renderers/shared/geometry/const';\nimport type { ShapeBuildCommand } from '../buildCommands/ShapeBuildCommand';\nimport type { ConvertedFillStyle, ConvertedStrokeStyle } from '../FillTypes';\nimport type { GraphicsContext, TextureInstruction } from '../GraphicsContext';\nimport type { GpuGraphicsContext } from '../GraphicsContextSystem';\nimport type { ShapePath, ShapePrimitiveWithHoles } from '../path/ShapePath';\n\n/**\n * A record of shape builders, keyed by shape type.\n * @category scene\n * @advanced\n */\nexport const shapeBuilders: Record<string, ShapeBuildCommand> = {};\n\nextensions.handleByMap(ExtensionType.ShapeBuilder, shapeBuilders);\nextensions.add(buildRectangle, buildPolygon, buildTriangle, buildCircle, buildEllipse, buildRoundedRectangle);\n\nconst tempRect = new Rectangle();\nconst tempTextureMatrix = new Matrix();\n\n/**\n * @param context\n * @param gpuContext\n * @internal\n */\nexport function buildContextBatches(context: GraphicsContext, gpuContext: GpuGraphicsContext)\n{\n    const { geometryData, batches } = gpuContext;\n\n    // reset them..\n    batches.length = 0;\n    geometryData.indices.length = 0;\n    geometryData.vertices.length = 0;\n    geometryData.uvs.length = 0;\n\n    for (let i = 0; i < context.instructions.length; i++)\n    {\n        const instruction = context.instructions[i];\n\n        if (instruction.action === 'texture')\n        {\n            // add a quad!\n            addTextureToGeometryData(instruction.data, batches, geometryData);\n        }\n        else if (instruction.action === 'fill' || instruction.action === 'stroke')\n        {\n            const isStroke = instruction.action === 'stroke';\n\n            // build path collection of polys and shapes points..\n            const shapePath = instruction.data.path.shapePath;\n\n            const style = instruction.data.style;\n\n            const hole = instruction.data.hole;\n\n            if (isStroke && hole)\n            {\n                addShapePathToGeometryData(hole.shapePath, style, true, batches, geometryData);\n            }\n\n            if (hole)\n            {\n                // add the holes to the last shape primitive\n                shapePath.shapePrimitives[shapePath.shapePrimitives.length - 1].holes = hole.shapePath.shapePrimitives;\n            }\n\n            addShapePathToGeometryData(shapePath, style, isStroke, batches, geometryData);\n        }\n    }\n}\n\nfunction addTextureToGeometryData(\n    data: TextureInstruction['data'],\n    batches: BatchableGraphics[],\n    geometryData: {\n        vertices: number[];\n        uvs: number[];\n        indices: number[];\n    }\n)\n{\n    const points: number[] = [];\n\n    const build = shapeBuilders.rectangle;\n\n    const rect = tempRect;\n\n    rect.x = data.dx;\n    rect.y = data.dy;\n    rect.width = data.dw;\n    rect.height = data.dh;\n\n    const matrix = data.transform;\n\n    // TODO - this can be cached...\n    if (!build.build(rect, points))\n    {\n        return;\n    }\n\n    const { vertices, uvs, indices } = geometryData;\n\n    const indexOffset = indices.length;\n    const vertOffset = vertices.length / 2;\n\n    if (matrix)\n    {\n        transformVertices(points, matrix);\n    }\n\n    build.triangulate(points, vertices, 2, vertOffset, indices, indexOffset);\n\n    const texture = data.image;\n    const textureUvs = texture.uvs;\n\n    uvs.push(\n        textureUvs.x0, textureUvs.y0,\n        textureUvs.x1, textureUvs.y1,\n        textureUvs.x3, textureUvs.y3,\n        textureUvs.x2, textureUvs.y2,\n    );\n\n    const graphicsBatch = BigPool.get(BatchableGraphics);\n\n    graphicsBatch.indexOffset = indexOffset;\n    graphicsBatch.indexSize = indices.length - indexOffset;\n\n    graphicsBatch.attributeOffset = vertOffset;\n    graphicsBatch.attributeSize = (vertices.length / 2) - vertOffset;\n\n    graphicsBatch.baseColor = data.style;\n    graphicsBatch.alpha = data.alpha;\n\n    graphicsBatch.texture = texture;\n    graphicsBatch.geometryData = geometryData;\n\n    batches.push(graphicsBatch);\n}\n\nfunction addShapePathToGeometryData(\n    shapePath: ShapePath,\n    style: ConvertedFillStyle | ConvertedStrokeStyle,\n    isStroke: boolean,\n    batches: BatchableGraphics[],\n    geometryData: {\n        vertices: number[];\n        uvs: number[];\n        indices: number[];\n    }\n)\n{\n    const { vertices, uvs, indices } = geometryData;\n\n    shapePath.shapePrimitives.forEach(({ shape, transform: matrix, holes }) =>\n    {\n        const points: number[] = [];\n        const build = shapeBuilders[shape.type];\n        // TODO - this can be cached...\n        // TODO - THIS IS DONE TWICE!!!!!!\n        // ONCE FOR STROKE AND ONCE FOR FILL\n        // move to the ShapePath2D class itself?\n\n        if (!build.build(shape, points))\n        {\n            return;\n        }\n\n        const indexOffset = indices.length;\n        const vertOffset = vertices.length / 2;\n        let topology: Topology = 'triangle-list';\n\n        if (matrix)\n        {\n            transformVertices(points, matrix);\n        }\n\n        if (!isStroke)\n        {\n            if (holes)\n            {\n                const holeIndices: number[] = [];\n\n                const otherPoints = points.slice();\n\n                const holeArrays = getHoleArrays(holes);\n\n                holeArrays.forEach((holePoints) =>\n                {\n                    holeIndices.push(otherPoints.length / 2);\n                    otherPoints.push(...holePoints);\n                });\n\n                triangulateWithHoles(otherPoints, holeIndices, vertices, 2, vertOffset, indices, indexOffset);\n            }\n            else\n            {\n                build.triangulate(points, vertices, 2, vertOffset, indices, indexOffset);\n            }\n        }\n        else\n        {\n            const close = (shape as Polygon).closePath ?? true;\n            const lineStyle = style as ConvertedStrokeStyle;\n\n            if (!lineStyle.pixelLine)\n            {\n                buildLine(points, lineStyle, false, close, vertices, indices);\n            }\n            else\n            {\n                buildPixelLine(points, close, vertices, indices);\n                topology = 'line-list';\n            }\n        }\n\n        const uvsOffset = uvs.length / 2;\n\n        const texture = style.texture;\n\n        if (texture !== Texture.WHITE)\n        {\n            const textureMatrix = generateTextureFillMatrix(tempTextureMatrix, style, shape, matrix);\n\n            buildUvs(vertices, 2, vertOffset, uvs, uvsOffset, 2, (vertices.length / 2) - vertOffset, textureMatrix);\n        }\n        else\n        {\n            buildSimpleUvs(uvs, uvsOffset, 2, (vertices.length / 2) - vertOffset);\n        }\n\n        const graphicsBatch = BigPool.get(BatchableGraphics);\n\n        graphicsBatch.indexOffset = indexOffset;\n        graphicsBatch.indexSize = indices.length - indexOffset;\n\n        graphicsBatch.attributeOffset = vertOffset;\n        graphicsBatch.attributeSize = (vertices.length / 2) - vertOffset;\n\n        graphicsBatch.baseColor = style.color;\n        graphicsBatch.alpha = style.alpha;\n\n        graphicsBatch.texture = texture;\n        graphicsBatch.geometryData = geometryData;\n        graphicsBatch.topology = topology;\n\n        batches.push(graphicsBatch);\n    });\n}\n\nfunction getHoleArrays(holePrimitives: ShapePrimitiveWithHoles[])\n{\n    const holeArrays = [];\n\n    for (let k = 0; k < holePrimitives.length; k++)\n    {\n        const holePrimitive = holePrimitives[k].shape;\n\n        // TODO - need to transform the points via there transform here..\n        const holePoints: number[] = [];\n\n        const holeBuilder = shapeBuilders[holePrimitive.type] as ShapeBuildCommand;\n\n        if (holeBuilder.build(holePrimitive, holePoints))\n        {\n            holeArrays.push(holePoints);\n        }\n    }\n\n    return holeArrays;\n}\n"],"names":["generateTextureFillMatrix"],"mappings":"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"}
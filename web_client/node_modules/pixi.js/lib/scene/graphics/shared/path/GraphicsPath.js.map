{"version":3,"file":"GraphicsPath.js","sources":["../../../../../src/scene/graphics/shared/path/GraphicsPath.ts"],"sourcesContent":["import { Point } from '../../../../maths/point/Point';\nimport { uid } from '../../../../utils/data/uid';\nimport { warn } from '../../../../utils/logging/warn';\nimport { parseSVGPath } from '../svg/parseSVGPath';\nimport { ShapePath } from './ShapePath';\n\nimport type { Matrix } from '../../../../maths/matrix/Matrix';\nimport type { PointData } from '../../../../maths/point/PointData';\nimport type { Bounds } from '../../../container/bounds/Bounds';\nimport type { RoundedPoint } from './roundShape';\n\n/**\n * Represents a single drawing instruction in a `GraphicsPath`.\n * Each instruction consists of an action type and associated data.\n * @category scene\n * @advanced\n */\nexport interface PathInstruction\n{\n    action: 'moveTo' | 'lineTo' | 'quadraticCurveTo' |\n    'bezierCurveTo' | 'arc' | 'closePath' |\n    'addPath' | 'arcTo' | 'ellipse' |\n    'rect' | 'roundRect' | 'arcToSvg' |\n    'poly' | 'circle' |\n    'regularPoly' | 'roundPoly' | 'roundShape' | 'filletRect' | 'chamferRect'\n    data: any[];\n}\n\n/**\n * The `GraphicsPath` class is designed to represent a graphical path consisting of multiple drawing instructions.\n * This class serves as a collection of drawing commands that can be executed to render shapes and paths on a canvas or\n * similar graphical context. It supports high-level drawing operations like lines, arcs, curves, and more, enabling\n * complex graphic constructions with relative ease.\n * @category scene\n * @advanced\n */\nexport class GraphicsPath\n{\n    public instructions: PathInstruction[] = [];\n\n    /** unique id for this graphics path */\n    public readonly uid: number = uid('graphicsPath');\n\n    private _dirty = true;\n    // needed for hit testing and bounds calculations\n    private _shapePath: ShapePath;\n\n    /**\n     * Controls whether shapes in this path should be checked for holes using the non-zero fill rule.\n     * When true, any closed shape that is fully contained within another shape will become\n     * a hole in that shape during filling operations.\n     *\n     * This follows SVG's non-zero fill rule where:\n     * 1. Shapes are analyzed to find containment relationships\n     * 2. If Shape B is fully contained within Shape A, Shape B becomes a hole in Shape A\n     * 3. Multiple nested holes are supported\n     *\n     * Mainly used internally by the SVG parser to correctly handle holes in complex paths.\n     * When false, all shapes are filled independently without checking for holes.\n     */\n    public checkForHoles: boolean;\n\n    /**\n     * Provides access to the internal shape path, ensuring it is up-to-date with the current instructions.\n     * @returns The `ShapePath` instance associated with this `GraphicsPath`.\n     */\n    get shapePath(): ShapePath\n    {\n        if (!this._shapePath)\n        {\n            this._shapePath = new ShapePath(this);\n        }\n\n        if (this._dirty)\n        {\n            this._dirty = false;\n            this._shapePath.buildPath();\n        }\n\n        return this._shapePath;\n    }\n\n    /**\n     * Creates a `GraphicsPath` instance optionally from an SVG path string or an array of `PathInstruction`.\n     * @param instructions - An SVG path string or an array of `PathInstruction` objects.\n     * @param signed\n     */\n    constructor(instructions?: string | PathInstruction[], signed = false)\n    {\n        this.checkForHoles = signed;\n\n        if (typeof instructions === 'string')\n        {\n            parseSVGPath(instructions, this);\n        }\n        else\n        {\n            this.instructions = instructions?.slice() ?? [];\n        }\n    }\n\n    /**\n     * Adds another `GraphicsPath` to this path, optionally applying a transformation.\n     * @param path - The `GraphicsPath` to add.\n     * @param transform - An optional transformation to apply to the added path.\n     * @returns The instance of the current object for chaining.\n     */\n    public addPath(path: GraphicsPath, transform?: Matrix): this\n    {\n        path = path.clone();\n        this.instructions.push({ action: 'addPath', data: [path, transform] });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Adds an arc to the path. The arc is centered at (x, y)\n     *  position with radius `radius` starting at `startAngle` and ending at `endAngle`.\n     * @param x - The x-coordinate of the arc's center.\n     * @param y - The y-coordinate of the arc's center.\n     * @param radius - The radius of the arc.\n     * @param startAngle - The starting angle of the arc, in radians.\n     * @param endAngle - The ending angle of the arc, in radians.\n     * @param counterclockwise - Specifies whether the arc should be drawn in the anticlockwise direction. False by default.\n     * @returns The instance of the current object for chaining.\n     */\n    public arc(x: number, y: number, radius: number, startAngle: number, endAngle: number, counterclockwise?: boolean): this;\n    public arc(...args: [number, number, number, number, number, boolean]): this\n    {\n        this.instructions.push({ action: 'arc', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Adds an arc to the path with the arc tangent to the line joining two specified points.\n     * The arc radius is specified by `radius`.\n     * @param x1 - The x-coordinate of the first point.\n     * @param y1 - The y-coordinate of the first point.\n     * @param x2 - The x-coordinate of the second point.\n     * @param y2 - The y-coordinate of the second point.\n     * @param radius - The radius of the arc.\n     * @returns The instance of the current object for chaining.\n     */\n    public arcTo(x1: number, y1: number, x2: number, y2: number, radius: number): this;\n    public arcTo(...args: [number, number, number, number, number]): this\n    {\n        this.instructions.push({ action: 'arcTo', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.\n     * @param rx - The x-radius of the ellipse.\n     * @param ry - The y-radius of the ellipse.\n     * @param xAxisRotation - The rotation of the ellipse's x-axis relative\n     * to the x-axis of the coordinate system, in degrees.\n     * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.\n     * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.\n     * @param x - The x-coordinate of the arc's end point.\n     * @param y - The y-coordinate of the arc's end point.\n     * @returns The instance of the current object for chaining.\n     */\n    // eslint-disable-next-line max-len\n    public arcToSvg(rx: number, ry: number, xAxisRotation: number, largeArcFlag: number, sweepFlag: number, x: number, y: number): this;\n    public arcToSvg(...args: [number, number, number, number, number, number, number]): this\n    {\n        this.instructions.push({ action: 'arcToSvg', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Adds a cubic Bezier curve to the path.\n     * It requires three points: the first two are control points and the third one is the end point.\n     * The starting point is the last point in the current path.\n     * @param cp1x - The x-coordinate of the first control point.\n     * @param cp1y - The y-coordinate of the first control point.\n     * @param cp2x - The x-coordinate of the second control point.\n     * @param cp2y - The y-coordinate of the second control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public bezierCurveTo(\n        cp1x: number, cp1y: number, cp2x: number, cp2y: number,\n        x: number, y: number,\n        smoothness?: number\n    ): this;\n    public bezierCurveTo(...args: [number, number, number, number, number, number, number]): this\n    {\n        this.instructions.push({ action: 'bezierCurveTo', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Adds a cubic Bezier curve to the path.\n     * It requires two points: the second control point and the end point. The first control point is assumed to be\n     * The starting point is the last point in the current path.\n     * @param cp2x - The x-coordinate of the second control point.\n     * @param cp2y - The y-coordinate of the second control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public bezierCurveToShort(cp2x: number, cp2y: number, x: number, y: number, smoothness?: number): this\n    {\n        const last = this.instructions[this.instructions.length - 1];\n\n        const lastPoint = this.getLastPoint(Point.shared);\n\n        let cp1x = 0;\n        let cp1y = 0;\n\n        if (!last || last.action !== 'bezierCurveTo')\n        {\n            cp1x = lastPoint.x;\n            cp1y = lastPoint.y;\n        }\n        else\n        {\n            cp1x = last.data[2];\n            cp1y = last.data[3];\n\n            const currentX = lastPoint.x;\n            const currentY = lastPoint.y;\n\n            cp1x = currentX + (currentX - cp1x);\n            cp1y = currentY + (currentY - cp1y);\n        }\n\n        this.instructions.push({ action: 'bezierCurveTo', data: [cp1x, cp1y, cp2x, cp2y, x, y, smoothness] });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Closes the current path by drawing a straight line back to the start.\n     * If the shape is already closed or there are no points in the path, this method does nothing.\n     * @returns The instance of the current object for chaining.\n     */\n    public closePath(): this\n    {\n        this.instructions.push({ action: 'closePath', data: [] });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws an ellipse at the specified location and with the given x and y radii.\n     * An optional transformation can be applied, allowing for rotation, scaling, and translation.\n     * @param x - The x-coordinate of the center of the ellipse.\n     * @param y - The y-coordinate of the center of the ellipse.\n     * @param radiusX - The horizontal radius of the ellipse.\n     * @param radiusY - The vertical radius of the ellipse.\n     * @param matrix - An optional `Matrix` object to apply a transformation to the ellipse. This can include rotations.\n     * @returns The instance of the current object for chaining.\n     */\n    public ellipse(x: number, y: number, radiusX: number, radiusY: number, matrix?: Matrix): this;\n    public ellipse(...args: [number, number, number, number, Matrix]): this\n    {\n        this.instructions.push({ action: 'ellipse', data: args });\n\n        // TODO nail this!\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Connects the current point to a new point with a straight line. This method updates the current path.\n     * @param x - The x-coordinate of the new point to connect to.\n     * @param y - The y-coordinate of the new point to connect to.\n     * @returns The instance of the current object for chaining.\n     */\n    public lineTo(x: number, y: number): this;\n    public lineTo(...args: [number, number]): this\n    {\n        this.instructions.push({ action: 'lineTo', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.\n     * @param x - The x-coordinate for the starting point.\n     * @param y - The y-coordinate for the starting point.\n     * @returns The instance of the current object for chaining.\n     */\n    public moveTo(x: number, y: number): this;\n    public moveTo(...args: [number, number]): this\n    {\n        this.instructions.push({ action: 'moveTo', data: args });\n\n        return this;\n    }\n\n    /**\n     * Adds a quadratic curve to the path. It requires two points: the control point and the end point.\n     * The starting point is the last point in the current path.\n     * @param cpx - The x-coordinate of the control point.\n     * @param cpy - The y-coordinate of the control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public quadraticCurveTo(cpx: number, cpy: number, x: number, y: number, smoothness?: number): this;\n    public quadraticCurveTo(...args: [number, number, number, number, number]): this\n    {\n        this.instructions.push({ action: 'quadraticCurveTo', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Adds a quadratic curve to the path. It uses the previous point as the control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public quadraticCurveToShort(x: number, y: number, smoothness?: number): this\n    {\n        // check if we have a previous quadraticCurveTo\n        const last = this.instructions[this.instructions.length - 1];\n\n        const lastPoint = this.getLastPoint(Point.shared);\n\n        let cpx1 = 0;\n        let cpy1 = 0;\n\n        if (!last || last.action !== 'quadraticCurveTo')\n        {\n            cpx1 = lastPoint.x;\n            cpy1 = lastPoint.y;\n        }\n        else\n        {\n            cpx1 = last.data[0];\n            cpy1 = last.data[1];\n\n            const currentX = lastPoint.x;\n            const currentY = lastPoint.y;\n\n            cpx1 = currentX + (currentX - cpx1);\n            cpy1 = currentY + (currentY - cpy1);\n        }\n\n        this.instructions.push({ action: 'quadraticCurveTo', data: [cpx1, cpy1, x, y, smoothness] });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.\n     * @param x - The x-coordinate of the top-left corner of the rectangle.\n     * @param y - The y-coordinate of the top-left corner of the rectangle.\n     * @param w - The width of the rectangle.\n     * @param h - The height of the rectangle.\n     * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.\n     * @returns The instance of the current object for chaining.\n     */\n    public rect(x: number, y: number, w: number, h: number, transform?: Matrix): this\n    {\n        this.instructions.push({ action: 'rect', data: [x, y, w, h, transform] });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws a circle shape. This method adds a new circle path to the current drawing.\n     * @param x - The x-coordinate of the center of the circle.\n     * @param y - The y-coordinate of the center of the circle.\n     * @param radius - The radius of the circle.\n     * @param transform - An optional `Matrix` object to apply a transformation to the circle.\n     * @returns The instance of the current object for chaining.\n     */\n    public circle(x: number, y: number, radius: number, transform?: Matrix): this\n    {\n        this.instructions.push({ action: 'circle', data: [x, y, radius, transform] });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws a rectangle with rounded corners.\n     * The corner radius can be specified to determine how rounded the corners should be.\n     * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.\n     * @param x - The x-coordinate of the top-left corner of the rectangle.\n     * @param y - The y-coordinate of the top-left corner of the rectangle.\n     * @param w - The width of the rectangle.\n     * @param h - The height of the rectangle.\n     * @param radius - The radius of the rectangle's corners. If not specified, corners will be sharp.\n     * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundRect(x: number, y: number, w: number, h: number, radius?: number, transform?: Matrix): this;\n    public roundRect(...args: [number, number, number, number, number, Matrix?]): this\n    {\n        this.instructions.push({ action: 'roundRect', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws a polygon shape by specifying a sequence of points. This method allows for the creation of complex polygons,\n     * which can be both open and closed. An optional transformation can be applied, enabling the polygon to be scaled,\n     * rotated, or translated as needed.\n     * @param points - An array of numbers representing the x and y coordinates of the polygon's vertices, in sequence.\n     * @param close - A boolean indicating whether to close the polygon path. True by default.\n     * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n     * @returns The instance of the current object for chaining further drawing commands.\n     */\n    public poly(points: number[] | PointData[], close?: boolean, transform?: Matrix): this;\n    public poly(...args: [number[] | PointData[], boolean, Matrix?]): this\n    {\n        this.instructions.push({ action: 'poly', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws a regular polygon with a specified number of sides. All sides and angles are equal.\n     * @param x - The x-coordinate of the center of the polygon.\n     * @param y - The y-coordinate of the center of the polygon.\n     * @param radius - The radius of the circumscribed circle of the polygon.\n     * @param sides - The number of sides of the polygon. Must be 3 or more.\n     * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n     * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n     * @returns The instance of the current object for chaining.\n     */\n    public regularPoly(x: number, y: number, radius: number, sides: number, rotation?: number, transform?: Matrix): this;\n    public regularPoly(...args: [number, number, number, number, number]): this\n    {\n        this.instructions.push({ action: 'regularPoly', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws a polygon with rounded corners.\n     * Similar to `regularPoly` but with the ability to round the corners of the polygon.\n     * @param x - The x-coordinate of the center of the polygon.\n     * @param y - The y-coordinate of the center of the polygon.\n     * @param radius - The radius of the circumscribed circle of the polygon.\n     * @param sides - The number of sides of the polygon. Must be 3 or more.\n     * @param corner - The radius of the rounding of the corners.\n     * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundPoly(x: number, y: number, radius: number, sides: number, corner: number, rotation?: number): this;\n    public roundPoly(...args: [number, number, number, number, number, number]): this\n    {\n        this.instructions.push({ action: 'roundPoly', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.\n     * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.\n     * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.\n     * A minimum of 3 points is required.\n     * @param radius - The default radius for the corners.\n     * This radius is applied to all corners unless overridden in `points`.\n     * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve\n     *  method instead of an arc method. Defaults to false.\n     * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.\n     * Higher values make the curve smoother.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundShape(points: RoundedPoint[], radius: number, useQuadratic?: boolean, smoothness?: number): this;\n    public roundShape(...args: [RoundedPoint[], number, boolean, number]): this\n    {\n        this.instructions.push({ action: 'roundShape', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draw Rectangle with fillet corners. This is much like rounded rectangle\n     * however it support negative numbers as well for the corner radius.\n     * @param x - Upper left corner of rect\n     * @param y - Upper right corner of rect\n     * @param width - Width of rect\n     * @param height - Height of rect\n     * @param fillet - accept negative or positive values\n     */\n    public filletRect(x: number, y: number, width: number, height: number, fillet: number): this;\n    public filletRect(...args: [number, number, number, number, number]): this\n    {\n        this.instructions.push({ action: 'filletRect', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draw Rectangle with chamfer corners. These are angled corners.\n     * @param x - Upper left corner of rect\n     * @param y - Upper right corner of rect\n     * @param width - Width of rect\n     * @param height - Height of rect\n     * @param chamfer - non-zero real number, size of corner cutout\n     * @param transform\n     */\n    public chamferRect(x: number, y: number, width: number, height: number, chamfer: number, transform?: Matrix): this;\n    public chamferRect(...args: [number, number, number, number, number]): this\n    {\n        this.instructions.push({ action: 'chamferRect', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws a star shape centered at a specified location. This method allows for the creation\n     *  of stars with a variable number of points, outer radius, optional inner radius, and rotation.\n     * The star is drawn as a closed polygon with alternating outer and inner vertices to create the star's points.\n     * An optional transformation can be applied to scale, rotate, or translate the star as needed.\n     * @param x - The x-coordinate of the center of the star.\n     * @param y - The y-coordinate of the center of the star.\n     * @param points - The number of points of the star.\n     * @param radius - The outer radius of the star (distance from the center to the outer points).\n     * @param innerRadius - Optional. The inner radius of the star\n     * (distance from the center to the inner points between the outer points).\n     * If not provided, defaults to half of the `radius`.\n     * @param rotation - Optional. The rotation of the star in radians, where 0 is aligned with the y-axis.\n     * Defaults to 0, meaning one point is directly upward.\n     * @param transform - An optional `Matrix` object to apply a transformation to the star.\n     * This can include rotations, scaling, and translations.\n     * @returns The instance of the current object for chaining further drawing commands.\n     */\n    // eslint-disable-next-line max-len\n    public star(x: number, y: number, points: number, radius: number, innerRadius?: number, rotation?: number, transform?: Matrix): this\n    {\n        innerRadius ||= radius / 2;\n\n        const startAngle = (-1 * Math.PI / 2) + rotation;\n        const len = points * 2;\n        const delta = (Math.PI * 2) / len;\n        const polygon = [];\n\n        for (let i = 0; i < len; i++)\n        {\n            const r = i % 2 ? innerRadius : radius;\n            const angle = (i * delta) + startAngle;\n\n            polygon.push(\n                x + (r * Math.cos(angle)),\n                y + (r * Math.sin(angle))\n            );\n        }\n\n        this.poly(polygon, true, transform);\n\n        return this;\n    }\n\n    /**\n     * Creates a copy of the current `GraphicsPath` instance. This method supports both shallow and deep cloning.\n     * A shallow clone copies the reference of the instructions array, while a deep clone creates a new array and\n     * copies each instruction individually, ensuring that modifications to the instructions of the cloned `GraphicsPath`\n     * do not affect the original `GraphicsPath` and vice versa.\n     * @param deep - A boolean flag indicating whether the clone should be deep.\n     * @returns A new `GraphicsPath` instance that is a clone of the current instance.\n     */\n    public clone(deep = false): GraphicsPath\n    {\n        const newGraphicsPath2D = new GraphicsPath();\n\n        newGraphicsPath2D.checkForHoles = this.checkForHoles;\n\n        if (!deep)\n        {\n            newGraphicsPath2D.instructions = this.instructions.slice();\n        }\n        else\n        {\n            for (let i = 0; i < this.instructions.length; i++)\n            {\n                const instruction = this.instructions[i];\n\n                newGraphicsPath2D.instructions.push({ action: instruction.action, data: instruction.data.slice() });\n            }\n        }\n\n        return newGraphicsPath2D;\n    }\n\n    public clear(): this\n    {\n        this.instructions.length = 0;\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Applies a transformation matrix to all drawing instructions within the `GraphicsPath`.\n     * This method enables the modification of the path's geometry according to the provided\n     * transformation matrix, which can include translations, rotations, scaling, and skewing.\n     *\n     * Each drawing instruction in the path is updated to reflect the transformation,\n     * ensuring the visual representation of the path is consistent with the applied matrix.\n     *\n     * Note: The transformation is applied directly to the coordinates and control points of the drawing instructions,\n     * not to the path as a whole. This means the transformation's effects are baked into the individual instructions,\n     * allowing for fine-grained control over the path's appearance.\n     * @param matrix - A `Matrix` object representing the transformation to apply.\n     * @returns The instance of the current object for chaining further operations.\n     */\n    public transform(matrix: Matrix): this\n    {\n        if (matrix.isIdentity()) return this;\n\n        const a = matrix.a;\n        const b = matrix.b;\n        const c = matrix.c;\n        const d = matrix.d;\n        const tx = matrix.tx;\n        const ty = matrix.ty;\n\n        let x = 0;\n        let y = 0;\n\n        let cpx1 = 0;\n        let cpy1 = 0;\n        let cpx2 = 0;\n        let cpy2 = 0;\n\n        let rx = 0;\n        let ry = 0;\n\n        for (let i = 0; i < this.instructions.length; i++)\n        {\n            const instruction = this.instructions[i];\n            const data = instruction.data as any[];\n\n            switch (instruction.action)\n            {\n                case 'moveTo':\n                case 'lineTo':\n\n                    x = data[0];\n                    y = data[1];\n\n                    data[0] = (a * x) + (c * y) + tx;\n                    data[1] = (b * x) + (d * y) + ty;\n                    break;\n                case 'bezierCurveTo':\n\n                    cpx1 = data[0];\n                    cpy1 = data[1];\n                    cpx2 = data[2];\n                    cpy2 = data[3];\n\n                    x = data[4];\n                    y = data[5];\n\n                    data[0] = (a * cpx1) + (c * cpy1) + tx;\n                    data[1] = (b * cpx1) + (d * cpy1) + ty;\n                    data[2] = (a * cpx2) + (c * cpy2) + tx;\n                    data[3] = (b * cpx2) + (d * cpy2) + ty;\n                    data[4] = (a * x) + (c * y) + tx;\n                    data[5] = (b * x) + (d * y) + ty;\n                    break;\n\n                case 'quadraticCurveTo':\n\n                    cpx1 = data[0];\n                    cpy1 = data[1];\n\n                    x = data[2];\n                    y = data[3];\n\n                    data[0] = (a * cpx1) + (c * cpy1) + tx;\n                    data[1] = (b * cpx1) + (d * cpy1) + ty;\n\n                    data[2] = (a * x) + (c * y) + tx;\n                    data[3] = (b * x) + (d * y) + ty;\n\n                    break;\n\n                case 'arcToSvg':\n\n                    x = data[5];\n                    y = data[6];\n\n                    rx = data[0];\n                    ry = data[1];\n\n                    // multiply the radius by the transform..\n\n                    data[0] = (a * rx) + (c * ry);\n                    data[1] = (b * rx) + (d * ry);\n\n                    data[5] = (a * x) + (c * y) + tx;\n                    data[6] = (b * x) + (d * y) + ty;\n\n                    break;\n\n                case 'circle':\n                    data[4] = adjustTransform(data[3], matrix);\n                    break;\n                case 'rect':\n                    data[4] = adjustTransform(data[4], matrix);\n                    break;\n                case 'ellipse':\n                    data[8] = adjustTransform(data[8], matrix);\n                    break;\n                case 'roundRect':\n                    data[5] = adjustTransform(data[5], matrix);\n                    break;\n                case 'addPath':\n                    data[0].transform(matrix);\n                    break;\n                case 'poly':\n                    data[2] = adjustTransform(data[2], matrix);\n                    break;\n                default:\n                    // #if _DEBUG\n                    warn('unknown transform action', instruction.action);\n                    // #endif\n                    break;\n            }\n        }\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    get bounds(): Bounds\n    {\n        return this.shapePath.bounds;\n    }\n\n    /**\n     * Retrieves the last point from the current drawing instructions in the `GraphicsPath`.\n     * This method is useful for operations that depend on the path's current endpoint,\n     * such as connecting subsequent shapes or paths. It supports various drawing instructions,\n     * ensuring the last point's position is accurately determined regardless of the path's complexity.\n     *\n     * If the last instruction is a `closePath`, the method iterates backward through the instructions\n     *  until it finds an actionable instruction that defines a point (e.g., `moveTo`, `lineTo`,\n     * `quadraticCurveTo`, etc.). For compound paths added via `addPath`, it recursively retrieves\n     * the last point from the nested path.\n     * @param out - A `Point` object where the last point's coordinates will be stored.\n     * This object is modified directly to contain the result.\n     * @returns The `Point` object containing the last point's coordinates.\n     */\n    public getLastPoint(out: Point): Point\n    {\n        let index = this.instructions.length - 1;\n\n        let lastInstruction = this.instructions[index];\n\n        if (!lastInstruction)\n        {\n            out.x = 0;\n            out.y = 0;\n\n            return out;\n        }\n\n        while (lastInstruction.action === 'closePath')\n        {\n            index--;\n\n            if (index < 0)\n            {\n                out.x = 0;\n                out.y = 0;\n\n                return out;\n            }\n\n            lastInstruction = this.instructions[index];\n        }\n\n        switch (lastInstruction.action)\n        {\n            case 'moveTo':\n            case 'lineTo':\n                out.x = lastInstruction.data[0];\n                out.y = lastInstruction.data[1];\n                break;\n            case 'quadraticCurveTo':\n                out.x = lastInstruction.data[2];\n                out.y = lastInstruction.data[3];\n                break;\n            case 'bezierCurveTo':\n                out.x = lastInstruction.data[4];\n                out.y = lastInstruction.data[5];\n                break;\n            case 'arc':\n            case 'arcToSvg':\n                out.x = lastInstruction.data[5];\n                out.y = lastInstruction.data[6];\n                break;\n            case 'addPath':\n                // TODO prolly should transform the last point of the path\n                lastInstruction.data[0].getLastPoint(out);\n                break;\n        }\n\n        return out;\n    }\n}\n\nfunction adjustTransform(currentMatrix?: Matrix, transform?: Matrix): Matrix\n{\n    if (currentMatrix)\n    {\n        return currentMatrix.prepend(transform);\n    }\n\n    return transform.clone();\n}\n"],"names":["uid","parseSVGPath","ShapePath","Point","warn"],"mappings":"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"}
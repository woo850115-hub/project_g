{"version":3,"file":"ShapePath.mjs","sources":["../../../../../src/scene/graphics/shared/path/ShapePath.ts"],"sourcesContent":["// a shape lets you build out a shape with lines and curves and primitives..\n\nimport { Circle } from '../../../../maths/shapes/Circle';\nimport { Ellipse } from '../../../../maths/shapes/Ellipse';\nimport { Polygon } from '../../../../maths/shapes/Polygon';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport { RoundedRectangle } from '../../../../maths/shapes/RoundedRectangle';\nimport { Bounds } from '../../../container/bounds/Bounds';\nimport { buildAdaptiveBezier } from '../buildCommands/buildAdaptiveBezier';\nimport { buildAdaptiveQuadratic } from '../buildCommands/buildAdaptiveQuadratic';\nimport { buildArc } from '../buildCommands/buildArc';\nimport { buildArcTo } from '../buildCommands/buildArcTo';\nimport { buildArcToSvg } from '../buildCommands/buildArcToSvg';\nimport { roundedShapeArc, roundedShapeQuadraticCurve } from './roundShape';\n\nimport type { Matrix } from '../../../../maths/matrix/Matrix';\nimport type { PointData } from '../../../../maths/point/PointData';\nimport type { ShapePrimitive } from '../../../../maths/shapes/ShapePrimitive';\nimport type { GraphicsPath } from './GraphicsPath';\nimport type { RoundedPoint } from './roundShape';\n\nconst tempRectangle = new Rectangle();\n\n/**\n * A type representing a shape primitive with optional transformation and holes.\n * @category scene\n * @advanced\n */\nexport type ShapePrimitiveWithHoles = {\n    shape: ShapePrimitive,\n    transform?: Matrix,\n    holes?: ShapePrimitiveWithHoles[]\n};\n\n/**\n * The `ShapePath` class acts as a bridge between high-level drawing commands\n * and the lower-level `GraphicsContext` rendering engine.\n * It translates drawing commands, such as those for creating lines, arcs, ellipses, rectangles, and complex polygons, into a\n * format that can be efficiently processed by a `GraphicsContext`. This includes handling path starts,\n * ends, and transformations for shapes.\n *\n * It is used internally by `GraphicsPath` to build up the path.\n * @category scene\n * @advanced\n */\nexport class ShapePath\n{\n    /** The list of shape primitives that make up the path. */\n    public shapePrimitives: ShapePrimitiveWithHoles[] = [];\n    private _currentPoly: Polygon | null = null;\n    private readonly _graphicsPath2D: GraphicsPath;\n    private readonly _bounds = new Bounds();\n    public readonly signed: boolean;\n\n    constructor(graphicsPath2D: GraphicsPath)\n    {\n        this._graphicsPath2D = graphicsPath2D;\n        this.signed = graphicsPath2D.checkForHoles;\n    }\n\n    /**\n     * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.\n     * @param x - The x-coordinate for the starting point.\n     * @param y - The y-coordinate for the starting point.\n     * @returns The instance of the current object for chaining.\n     */\n    public moveTo(x: number, y: number): this\n    {\n        this.startPoly(x, y);\n\n        return this;\n    }\n\n    /**\n     * Connects the current point to a new point with a straight line. This method updates the current path.\n     * @param x - The x-coordinate of the new point to connect to.\n     * @param y - The y-coordinate of the new point to connect to.\n     * @returns The instance of the current object for chaining.\n     */\n    public lineTo(x: number, y: number): this\n    {\n        this._ensurePoly();\n\n        const points = this._currentPoly.points;\n\n        const fromX = points[points.length - 2];\n        const fromY = points[points.length - 1];\n\n        if (fromX !== x || fromY !== y)\n        {\n            points.push(x, y);\n        }\n\n        return this;\n    }\n\n    /**\n     * Adds an arc to the path. The arc is centered at (x, y)\n     *  position with radius `radius` starting at `startAngle` and ending at `endAngle`.\n     * @param x - The x-coordinate of the arc's center.\n     * @param y - The y-coordinate of the arc's center.\n     * @param radius - The radius of the arc.\n     * @param startAngle - The starting angle of the arc, in radians.\n     * @param endAngle - The ending angle of the arc, in radians.\n     * @param counterclockwise - Specifies whether the arc should be drawn in the anticlockwise direction. False by default.\n     * @returns The instance of the current object for chaining.\n     */\n    public arc(x: number, y: number, radius: number, startAngle: number, endAngle: number, counterclockwise: boolean): this\n    {\n        // TODO - if its 360 degrees.. make it a circle object?\n\n        this._ensurePoly(false);\n\n        const points = this._currentPoly.points;\n\n        buildArc(points, x, y, radius, startAngle, endAngle, counterclockwise);\n\n        return this;\n    }\n\n    /**\n     * Adds an arc to the path with the arc tangent to the line joining two specified points.\n     * The arc radius is specified by `radius`.\n     * @param x1 - The x-coordinate of the first point.\n     * @param y1 - The y-coordinate of the first point.\n     * @param x2 - The x-coordinate of the second point.\n     * @param y2 - The y-coordinate of the second point.\n     * @param radius - The radius of the arc.\n     * @returns The instance of the current object for chaining.\n     */\n    public arcTo(x1: number, y1: number, x2: number, y2: number, radius: number): this\n    {\n        this._ensurePoly();\n\n        const points = this._currentPoly.points;\n\n        buildArcTo(points, x1, y1, x2, y2, radius);\n\n        return this;\n    }\n\n    /**\n     * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.\n     * @param rx - The x-radius of the ellipse.\n     * @param ry - The y-radius of the ellipse.\n     * @param xAxisRotation - The rotation of the ellipse's x-axis relative\n     * to the x-axis of the coordinate system, in degrees.\n     * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.\n     * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.\n     * @param x - The x-coordinate of the arc's end point.\n     * @param y - The y-coordinate of the arc's end point.\n     * @returns The instance of the current object for chaining.\n     */\n    public arcToSvg(\n        rx: number, ry: number,\n        xAxisRotation: number, largeArcFlag: number, sweepFlag: number,\n        x: number, y: number\n    ): this\n    {\n        const points = this._currentPoly.points;\n\n        // this needs to work on both canvas and GPU backends so might want to move this to the Graphics2D path..\n        buildArcToSvg(\n            points,\n            this._currentPoly.lastX,\n            this._currentPoly.lastY,\n            x,\n            y,\n            rx,\n            ry,\n            xAxisRotation,\n            largeArcFlag,\n            sweepFlag,\n        );\n\n        return this;\n    }\n\n    /**\n     * Adds a cubic Bezier curve to the path.\n     * It requires three points: the first two are control points and the third one is the end point.\n     * The starting point is the last point in the current path.\n     * @param cp1x - The x-coordinate of the first control point.\n     * @param cp1y - The y-coordinate of the first control point.\n     * @param cp2x - The x-coordinate of the second control point.\n     * @param cp2y - The y-coordinate of the second control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public bezierCurveTo(\n        cp1x: number, cp1y: number, cp2x: number, cp2y: number,\n        x: number, y: number,\n        smoothness?: number\n    ): this\n    {\n        this._ensurePoly();\n\n        const currentPoly = this._currentPoly;\n\n        // ensure distance from last point to first control point is not too small\n\n        // TODO - make this a plugin that people can override..\n        buildAdaptiveBezier(\n            this._currentPoly.points,\n            currentPoly.lastX, currentPoly.lastY,\n            cp1x, cp1y, cp2x, cp2y, x, y,\n            smoothness,\n        );\n\n        return this;\n    }\n\n    /**\n     * Adds a quadratic curve to the path. It requires two points: the control point and the end point.\n     * The starting point is the last point in the current path.\n     * @param cp1x - The x-coordinate of the control point.\n     * @param cp1y - The y-coordinate of the control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothing - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public quadraticCurveTo(cp1x: number, cp1y: number, x: number, y: number, smoothing?: number): this\n    {\n        this._ensurePoly();\n\n        const currentPoly = this._currentPoly;\n\n        // ensure distance from last point to first control point is not too small\n\n        // TODO - make this a plugin that people can override..\n        buildAdaptiveQuadratic(\n            this._currentPoly.points,\n            currentPoly.lastX, currentPoly.lastY,\n            cp1x, cp1y, x, y,\n            smoothing,\n        );\n\n        return this;\n    }\n\n    /**\n     * Closes the current path by drawing a straight line back to the start.\n     * If the shape is already closed or there are no points in the path, this method does nothing.\n     * @returns The instance of the current object for chaining.\n     */\n    public closePath(): this\n    {\n        this.endPoly(true);\n\n        return this;\n    }\n\n    /**\n     * Adds another path to the current path. This method allows for the combination of multiple paths into one.\n     * @param path - The `GraphicsPath` object representing the path to add.\n     * @param transform - An optional `Matrix` object to apply a transformation to the path before adding it.\n     * @returns The instance of the current object for chaining.\n     */\n    public addPath(path: GraphicsPath, transform?: Matrix): this\n    {\n        this.endPoly();\n\n        // Only clone if we need to transform\n        if (transform && !transform.isIdentity())\n        {\n            path = path.clone(true);\n            path.transform(transform);\n        }\n\n        const shapePrimitives = this.shapePrimitives;\n        const start = shapePrimitives.length;\n\n        for (let i = 0; i < path.instructions.length; i++)\n        {\n            const instruction = path.instructions[i];\n\n            this[instruction.action](...(instruction.data as [never, never, never, never, never, never, never]));\n        }\n\n        // This section processes holes in polygons by checking if any polygon is contained within another.\n        // If a polygon is found to be inside another polygon (mainShape), it's treated as a hole.\n        // The hole polygon is removed from the main shapePrimitives array and added to the holes array\n        // of the containing polygon. This allows for proper rendering of shapes with holes.\n        if (path.checkForHoles && shapePrimitives.length - start > 1)\n        {\n            let mainShape = null;\n\n            // Process in place instead of creating a removal array\n            for (let i = start; i < shapePrimitives.length; i++)\n            {\n                const shapePrimitive = shapePrimitives[i];\n\n                if (shapePrimitive.shape.type === 'polygon')\n                {\n                    const polygon = shapePrimitive.shape as Polygon;\n                    const mainPolygon = mainShape?.shape as Polygon;\n\n                    if (mainPolygon && mainPolygon.containsPolygon(polygon))\n                    {\n                        // Initialize holes array only when needed\n                        mainShape.holes ||= [];\n                        mainShape.holes.push(shapePrimitive);\n\n                        // Remove the hole by moving elements left\n                        shapePrimitives.copyWithin(i, i + 1);\n                        shapePrimitives.length--;\n                        i--;\n                    }\n                    else\n                    {\n                        mainShape = shapePrimitive;\n                    }\n                }\n            }\n        }\n\n        return this;\n    }\n\n    /**\n     * Finalizes the drawing of the current path. Optionally, it can close the path.\n     * @param closePath - A boolean indicating whether to close the path after finishing. False by default.\n     */\n    public finish(closePath = false)\n    {\n        this.endPoly(closePath);\n    }\n\n    /**\n     * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.\n     * @param x - The x-coordinate of the top-left corner of the rectangle.\n     * @param y - The y-coordinate of the top-left corner of the rectangle.\n     * @param w - The width of the rectangle.\n     * @param h - The height of the rectangle.\n     * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.\n     * @returns The instance of the current object for chaining.\n     */\n    public rect(x: number, y: number, w: number, h: number, transform?: Matrix): this\n    {\n        this.drawShape(new Rectangle(x, y, w, h), transform);\n\n        return this;\n    }\n\n    /**\n     * Draws a circle shape. This method adds a new circle path to the current drawing.\n     * @param x - The x-coordinate of the center of the circle.\n     * @param y - The y-coordinate of the center of the circle.\n     * @param radius - The radius of the circle.\n     * @param transform - An optional `Matrix` object to apply a transformation to the circle.\n     * @returns The instance of the current object for chaining.\n     */\n    public circle(x: number, y: number, radius: number, transform?: Matrix): this\n    {\n        this.drawShape(new Circle(x, y, radius), transform);\n\n        return this;\n    }\n\n    /**\n     * Draws a polygon shape. This method allows for the creation of complex polygons by specifying a sequence of points.\n     * @param points - An array of numbers, or or an array of PointData objects eg [{x,y}, {x,y}, {x,y}]\n     * representing the x and y coordinates of the polygon's vertices, in sequence.\n     * @param close - A boolean indicating whether to close the polygon path. True by default.\n     * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n     * @returns The instance of the current object for chaining.\n     */\n    public poly(points: number[] | PointData[], close?: boolean, transform?: Matrix): this\n    {\n        const polygon = new Polygon(points);\n\n        polygon.closePath = close;\n\n        this.drawShape(polygon, transform);\n\n        return this;\n    }\n\n    /**\n     * Draws a regular polygon with a specified number of sides. All sides and angles are equal.\n     * @param x - The x-coordinate of the center of the polygon.\n     * @param y - The y-coordinate of the center of the polygon.\n     * @param radius - The radius of the circumscribed circle of the polygon.\n     * @param sides - The number of sides of the polygon. Must be 3 or more.\n     * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n     * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n     * @returns The instance of the current object for chaining.\n     */\n    public regularPoly(x: number, y: number, radius: number, sides: number, rotation = 0, transform?: Matrix): this\n    {\n        sides = Math.max(sides | 0, 3);\n        const startAngle = (-1 * Math.PI / 2) + rotation;\n        const delta = (Math.PI * 2) / sides;\n        const polygon = [];\n\n        for (let i = 0; i < sides; i++)\n        {\n            const angle = startAngle - (i * delta);\n\n            polygon.push(\n                x + (radius * Math.cos(angle)),\n                y + (radius * Math.sin(angle))\n            );\n        }\n\n        this.poly(polygon, true, transform);\n\n        return this;\n    }\n\n    /**\n     * Draws a polygon with rounded corners.\n     * Similar to `regularPoly` but with the ability to round the corners of the polygon.\n     * @param x - The x-coordinate of the center of the polygon.\n     * @param y - The y-coordinate of the center of the polygon.\n     * @param radius - The radius of the circumscribed circle of the polygon.\n     * @param sides - The number of sides of the polygon. Must be 3 or more.\n     * @param corner - The radius of the rounding of the corners.\n     * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n     * @param smoothness - Optional parameter to adjust the smoothness of the rounding.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundPoly(\n        x: number, y: number,\n        radius: number,\n        sides: number, corner: number,\n        rotation = 0,\n        smoothness?: number,\n    ): this\n    {\n        sides = Math.max((sides | 0), 3);\n\n        if (corner <= 0)\n        {\n            return this.regularPoly(x, y, radius, sides, rotation);\n        }\n\n        const sideLength = (radius * Math.sin(Math.PI / sides)) - 0.001;\n\n        corner = Math.min(corner, sideLength);\n\n        const startAngle = (-1 * Math.PI / 2) + rotation;\n        const delta = (Math.PI * 2) / sides;\n        const internalAngle = ((sides - 2) * Math.PI) / sides / 2;\n\n        for (let i = 0; i < sides; i++)\n        {\n            const angle = (i * delta) + startAngle;\n            const x0 = x + (radius * Math.cos(angle));\n            const y0 = y + (radius * Math.sin(angle));\n            const a1 = angle + (Math.PI) + internalAngle;\n            const a2 = angle - (Math.PI) - internalAngle;\n            const x1 = x0 + (corner * Math.cos(a1));\n            const y1 = y0 + (corner * Math.sin(a1));\n            const x3 = x0 + (corner * Math.cos(a2));\n            const y3 = y0 + (corner * Math.sin(a2));\n\n            if (i === 0)\n            {\n                this.moveTo(x1, y1);\n            }\n            else\n            {\n                this.lineTo(x1, y1);\n            }\n            this.quadraticCurveTo(x0, y0, x3, y3, smoothness);\n        }\n\n        return this.closePath();\n    }\n\n    /**\n     * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.\n     * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.\n     * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.\n     * A minimum of 3 points is required.\n     * @param radius - The default radius for the corners.\n     * This radius is applied to all corners unless overridden in `points`.\n     * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve\n     *  method instead of an arc method. Defaults to false.\n     * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.\n     * Higher values make the curve smoother.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundShape(points: RoundedPoint[], radius: number, useQuadratic = false, smoothness?: number): this\n    {\n        if (points.length < 3)\n        {\n            return this;\n        }\n\n        if (useQuadratic)\n        {\n            roundedShapeQuadraticCurve(this, points, radius, smoothness);\n        }\n        else\n        {\n            roundedShapeArc(this, points, radius);\n        }\n\n        return this.closePath();\n    }\n\n    /**\n     * Draw Rectangle with fillet corners. This is much like rounded rectangle\n     * however it support negative numbers as well for the corner radius.\n     * @param x - Upper left corner of rect\n     * @param y - Upper right corner of rect\n     * @param width - Width of rect\n     * @param height - Height of rect\n     * @param fillet - accept negative or positive values\n     */\n    public filletRect(x: number, y: number, width: number, height: number, fillet: number): this\n    {\n        if (fillet === 0)\n        {\n            return this.rect(x, y, width, height);\n        }\n\n        const maxFillet = Math.min(width, height) / 2;\n        const inset = Math.min(maxFillet, Math.max(-maxFillet, fillet));\n        const right = x + width;\n        const bottom = y + height;\n        const dir = inset < 0 ? -inset : 0;\n        const size = Math.abs(inset);\n\n        return this\n            .moveTo(x, y + size)\n            .arcTo(x + dir, y + dir, x + size, y, size)\n            .lineTo(right - size, y)\n            .arcTo(right - dir, y + dir, right, y + size, size)\n            .lineTo(right, bottom - size)\n            .arcTo(right - dir, bottom - dir, x + width - size, bottom, size)\n            .lineTo(x + size, bottom)\n            .arcTo(x + dir, bottom - dir, x, bottom - size, size)\n            .closePath();\n    }\n\n    /**\n     * Draw Rectangle with chamfer corners. These are angled corners.\n     * @param x - Upper left corner of rect\n     * @param y - Upper right corner of rect\n     * @param width - Width of rect\n     * @param height - Height of rect\n     * @param chamfer - non-zero real number, size of corner cutout\n     * @param transform\n     */\n    public chamferRect(x: number, y: number, width: number, height: number, chamfer: number, transform?: Matrix): this\n    {\n        if (chamfer <= 0)\n        {\n            return this.rect(x, y, width, height);\n        }\n\n        const inset = Math.min(chamfer, Math.min(width, height) / 2);\n        const right = x + width;\n        const bottom = y + height;\n        const points = [\n            x + inset, y,\n            right - inset, y,\n            right, y + inset,\n            right, bottom - inset,\n            right - inset, bottom,\n            x + inset, bottom,\n            x, bottom - inset,\n            x, y + inset,\n        ];\n\n        // Remove overlapping points\n        for (let i = points.length - 1; i >= 2; i -= 2)\n        {\n            if (points[i] === points[i - 2] && points[i - 1] === points[i - 3])\n            {\n                points.splice(i - 1, 2);\n            }\n        }\n\n        return this.poly(points, true, transform);\n    }\n\n    /**\n     * Draws an ellipse at the specified location and with the given x and y radii.\n     * An optional transformation can be applied, allowing for rotation, scaling, and translation.\n     * @param x - The x-coordinate of the center of the ellipse.\n     * @param y - The y-coordinate of the center of the ellipse.\n     * @param radiusX - The horizontal radius of the ellipse.\n     * @param radiusY - The vertical radius of the ellipse.\n     * @param transform - An optional `Matrix` object to apply a transformation to the ellipse. This can include rotations.\n     * @returns The instance of the current object for chaining.\n     */\n    public ellipse(x: number, y: number, radiusX: number, radiusY: number, transform?: Matrix): this\n    {\n        // TODO apply rotation to transform...\n\n        this.drawShape(new Ellipse(x, y, radiusX, radiusY), transform);\n\n        return this;\n    }\n\n    /**\n     * Draws a rectangle with rounded corners.\n     * The corner radius can be specified to determine how rounded the corners should be.\n     * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.\n     * @param x - The x-coordinate of the top-left corner of the rectangle.\n     * @param y - The y-coordinate of the top-left corner of the rectangle.\n     * @param w - The width of the rectangle.\n     * @param h - The height of the rectangle.\n     * @param radius - The radius of the rectangle's corners. If not specified, corners will be sharp.\n     * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundRect(x: number, y: number, w: number, h: number, radius?: number, transform?: Matrix): this\n    {\n        this.drawShape(new RoundedRectangle(x, y, w, h, radius), transform);\n\n        return this;\n    }\n\n    /**\n     * Draws a given shape on the canvas.\n     * This is a generic method that can draw any type of shape specified by the `ShapePrimitive` parameter.\n     * An optional transformation matrix can be applied to the shape, allowing for complex transformations.\n     * @param shape - The shape to draw, defined as a `ShapePrimitive` object.\n     * @param matrix - An optional `Matrix` for transforming the shape. This can include rotations,\n     * scaling, and translations.\n     * @returns The instance of the current object for chaining.\n     */\n    public drawShape(shape: ShapePrimitive, matrix?: Matrix): this\n    {\n        this.endPoly();\n\n        this.shapePrimitives.push({ shape, transform: matrix });\n\n        return this;\n    }\n\n    /**\n     * Starts a new polygon path from the specified starting point.\n     * This method initializes a new polygon or ends the current one if it exists.\n     * @param x - The x-coordinate of the starting point of the new polygon.\n     * @param y - The y-coordinate of the starting point of the new polygon.\n     * @returns The instance of the current object for chaining.\n     */\n    public startPoly(x: number, y: number): this\n    {\n        let currentPoly = this._currentPoly;\n\n        if (currentPoly)\n        {\n            this.endPoly();\n        }\n\n        currentPoly = new Polygon();\n\n        currentPoly.points.push(x, y);\n\n        this._currentPoly = currentPoly;\n\n        return this;\n    }\n\n    /**\n     * Ends the current polygon path. If `closePath` is set to true,\n     * the path is closed by connecting the last point to the first one.\n     * This method finalizes the current polygon and prepares it for drawing or adding to the shape primitives.\n     * @param closePath - A boolean indicating whether to close the polygon by connecting the last point\n     *  back to the starting point. False by default.\n     * @returns The instance of the current object for chaining.\n     */\n    public endPoly(closePath = false): this\n    {\n        const shape = this._currentPoly;\n\n        if (shape && shape.points.length > 2)\n        {\n            shape.closePath = closePath;\n\n            this.shapePrimitives.push({ shape });\n        }\n\n        this._currentPoly = null;\n\n        return this;\n    }\n\n    private _ensurePoly(start = true): void\n    {\n        if (this._currentPoly) return;\n\n        this._currentPoly = new Polygon();\n\n        if (start)\n        {\n            // get last points..\n            const lastShape = this.shapePrimitives[this.shapePrimitives.length - 1];\n\n            if (lastShape)\n            {\n                // i KNOW its a rect..\n                let lx = lastShape.shape.x;\n                let ly = lastShape.shape.y;\n\n                if (lastShape.transform && !lastShape.transform.isIdentity())\n                {\n                    const t = lastShape.transform;\n\n                    const tempX = lx;\n\n                    lx = (t.a * lx) + (t.c * ly) + t.tx;\n                    ly = (t.b * tempX) + (t.d * ly) + t.ty;\n                }\n\n                this._currentPoly.points.push(lx, ly);\n            }\n            else\n            {\n                this._currentPoly.points.push(0, 0);\n            }\n        }\n    }\n\n    /** Builds the path. */\n    public buildPath()\n    {\n        const path = this._graphicsPath2D;\n\n        this.shapePrimitives.length = 0;\n        this._currentPoly = null;\n\n        for (let i = 0; i < path.instructions.length; i++)\n        {\n            const instruction = path.instructions[i];\n\n            // Sorry TS! this is the best we could do...\n            this[instruction.action](...(instruction.data as [never, never, never, never, never, never, never]));\n        }\n\n        this.finish();\n    }\n\n    /** Gets the bounds of the path. */\n    get bounds(): Bounds\n    {\n        const bounds = this._bounds;\n\n        bounds.clear();\n\n        const shapePrimitives = this.shapePrimitives;\n\n        for (let i = 0; i < shapePrimitives.length; i++)\n        {\n            const shapePrimitive = shapePrimitives[i];\n\n            const boundsRect = shapePrimitive.shape.getBounds(tempRectangle);\n\n            if (shapePrimitive.transform)\n            {\n                bounds.addRect(boundsRect, shapePrimitive.transform);\n            }\n            else\n            {\n                bounds.addRect(boundsRect);\n            }\n        }\n\n        return bounds;\n    }\n}\n"],"names":[],"mappings":"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"}
{"version":3,"file":"buildLine.js","sources":["../../../../../src/scene/graphics/shared/buildCommands/buildLine.ts"],"sourcesContent":["import { Point } from '../../../../maths/point/Point';\nimport { closePointEps, curveEps } from '../const';\nimport { getOrientationOfPoints } from '../utils/getOrientationOfPoints';\n\nimport type { StrokeAttributes } from '../FillTypes';\n\n/**\n * Buffers vertices to draw a square cap.\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n * @param {number} x - X-coord of end point\n * @param {number} y - Y-coord of end point\n * @param {number} nx - X-coord of line normal pointing inside\n * @param {number} ny - Y-coord of line normal pointing inside\n * @param {number} innerWeight - Weight of inner points\n * @param {number} outerWeight - Weight of outer points\n * @param {boolean} clockwise - Whether the cap is drawn clockwise\n * @param {Array<number>} verts - vertex buffer\n * @returns {number} - no. of vertices pushed\n */\nfunction square(\n    x: number,\n    y: number,\n    nx: number,\n    ny: number,\n    innerWeight: number,\n    outerWeight: number,\n    clockwise: boolean, /* rotation for square (true at left end, false at right end) */\n    verts: Array<number>\n): number\n{\n    const ix = x - (nx * innerWeight);\n    const iy = y - (ny * innerWeight);\n    const ox = x + (nx * outerWeight);\n    const oy = y + (ny * outerWeight);\n\n    /* Rotate nx,ny for extension vector */\n    let exx; let\n        eyy;\n\n    if (clockwise)\n    {\n        exx = ny;\n        eyy = -nx;\n    }\n    else\n    {\n        exx = -ny;\n        eyy = nx;\n    }\n\n    /* [i|0]x,y extended at cap */\n    const eix = ix + exx;\n    const eiy = iy + eyy;\n    const eox = ox + exx;\n    const eoy = oy + eyy;\n\n    /* Square itself must be inserted clockwise*/\n    verts.push(eix, eiy);\n    verts.push(eox, eoy);\n\n    return 2;\n}\n\n/**\n * Buffers vertices to draw an arc at the line joint or cap.\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n * @param {number} cx - X-coord of center\n * @param {number} cy - Y-coord of center\n * @param {number} sx - X-coord of arc start\n * @param {number} sy - Y-coord of arc start\n * @param {number} ex - X-coord of arc end\n * @param {number} ey - Y-coord of arc end\n * @param {Array[]} verts - buffer of vertices\n * @param {boolean} clockwise - orientation of vertices\n * @returns {number} - no. of vertices pushed\n */\nfunction round(\n    cx: number,\n    cy: number,\n    sx: number,\n    sy: number,\n    ex: number,\n    ey: number,\n    verts: number[],\n    clockwise: boolean, /* if not cap, then clockwise is turn of joint, otherwise rotation from angle0 to angle1 */\n): number\n{\n    const cx2p0x = sx - cx;\n    const cy2p0y = sy - cy;\n\n    let angle0 = Math.atan2(cx2p0x, cy2p0y);\n    let angle1 = Math.atan2(ex - cx, ey - cy);\n\n    if (clockwise && angle0 < angle1)\n    {\n        angle0 += Math.PI * 2;\n    }\n    else if (!clockwise && angle0 > angle1)\n    {\n        angle1 += Math.PI * 2;\n    }\n\n    let startAngle = angle0;\n    const angleDiff = angle1 - angle0;\n    const absAngleDiff = Math.abs(angleDiff);\n\n    const radius = Math.sqrt((cx2p0x * cx2p0x) + (cy2p0y * cy2p0y));\n    const segCount = ((15 * absAngleDiff * Math.sqrt(radius) / Math.PI) >> 0) + 1;\n    const angleInc = angleDiff / segCount;\n\n    startAngle += angleInc;\n\n    if (clockwise)\n    {\n        verts.push(cx, cy);\n        verts.push(sx, sy);\n\n        for (let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc)\n        {\n            verts.push(cx, cy);\n            verts.push(cx + ((Math.sin(angle) * radius)),\n                cy + ((Math.cos(angle) * radius)));\n        }\n\n        verts.push(cx, cy);\n        verts.push(ex, ey);\n    }\n    else\n    {\n        verts.push(sx, sy);\n        verts.push(cx, cy);\n\n        for (let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc)\n        {\n            verts.push(cx + ((Math.sin(angle) * radius)),\n                cy + ((Math.cos(angle) * radius)));\n            verts.push(cx, cy);\n        }\n\n        verts.push(ex, ey);\n        verts.push(cx, cy);\n    }\n\n    return segCount * 2;\n}\n\n/**\n * Builds a line to draw using the polygon method.\n * @param points\n * @param lineStyle\n * @param flipAlignment\n * @param closed\n * @param vertices\n * @param indices\n * @internal\n */\nexport function buildLine(\n    points: number[],\n    lineStyle: StrokeAttributes,\n    flipAlignment: boolean,\n    closed: boolean,\n    vertices: number[],\n    indices: number[],\n): void\n{\n    // const shape = graphicsData.shape as Polygon;\n    //   let points = graphicsData.points || shape.points.slice();\n    const eps = closePointEps;\n\n    if (points.length === 0)\n    {\n        return;\n    }\n\n    const style = lineStyle;\n\n    let alignment = style.alignment;\n\n    if (lineStyle.alignment !== 0.5)\n    {\n        // rotate the points!\n        let orientation = getOrientationOfPoints(points);\n\n        if (flipAlignment)orientation *= -1;\n\n        alignment = ((alignment - 0.5) * orientation) + 0.5;\n    }\n\n    // get first and last point.. figure out the middle!\n    const firstPoint = new Point(points[0], points[1]);\n    const lastPoint = new Point(points[points.length - 2], points[points.length - 1]);\n    const closedShape = closed;\n    const closedPath = Math.abs(firstPoint.x - lastPoint.x) < eps\n        && Math.abs(firstPoint.y - lastPoint.y) < eps;\n\n    // if the first point is the last point - gonna have issues :)\n    if (closedShape)\n    {\n        // need to clone as we are going to slightly modify the shape..\n        points = points.slice();\n\n        if (closedPath)\n        {\n            points.pop();\n            points.pop();\n            lastPoint.set(points[points.length - 2], points[points.length - 1]);\n        }\n\n        const midPointX = (firstPoint.x + lastPoint.x) * 0.5;\n        const midPointY = (lastPoint.y + firstPoint.y) * 0.5;\n\n        points.unshift(midPointX, midPointY);\n        points.push(midPointX, midPointY);\n    }\n\n    const verts = vertices;\n\n    const length = points.length / 2;\n    let indexCount = points.length;\n    const indexStart = verts.length / 2;\n\n    // Max. inner and outer width\n    const width = style.width / 2;\n    const widthSquared = width * width;\n    const miterLimitSquared = style.miterLimit * style.miterLimit;\n\n    /* Line segments of interest where (x1,y1) forms the corner. */\n    let x0 = points[0];\n    let y0 = points[1];\n    let x1 = points[2];\n    let y1 = points[3];\n    let x2 = 0;\n    let y2 = 0;\n\n    /* perp[?](x|y) = the line normal with magnitude lineWidth. */\n    let perpX = -(y0 - y1);\n    let perpY = x0 - x1;\n    let perp1x = 0;\n    let perp1y = 0;\n\n    let dist = Math.sqrt((perpX * perpX) + (perpY * perpY));\n\n    perpX /= dist;\n    perpY /= dist;\n    perpX *= width;\n    perpY *= width;\n\n    const ratio = alignment;// 0.5;\n    const innerWeight = (1 - ratio) * 2;\n    const outerWeight = ratio * 2;\n\n    if (!closedShape)\n    {\n        if (style.cap === 'round')\n        {\n            indexCount += round(\n                x0 - (perpX * (innerWeight - outerWeight) * 0.5),\n                y0 - (perpY * (innerWeight - outerWeight) * 0.5),\n                x0 - (perpX * innerWeight),\n                y0 - (perpY * innerWeight),\n                x0 + (perpX * outerWeight),\n                y0 + (perpY * outerWeight),\n                verts,\n                true,\n            ) + 2;\n        }\n        else if (style.cap === 'square')\n        {\n            indexCount += square(x0, y0, perpX, perpY, innerWeight, outerWeight, true, verts);\n        }\n    }\n\n    // Push first point (below & above vertices)\n    verts.push(\n        x0 - (perpX * innerWeight),\n        y0 - (perpY * innerWeight));\n    verts.push(\n        x0 + (perpX * outerWeight),\n        y0 + (perpY * outerWeight));\n\n    for (let i = 1; i < length - 1; ++i)\n    {\n        x0 = points[(i - 1) * 2];\n        y0 = points[((i - 1) * 2) + 1];\n\n        x1 = points[i * 2];\n        y1 = points[(i * 2) + 1];\n\n        x2 = points[(i + 1) * 2];\n        y2 = points[((i + 1) * 2) + 1];\n\n        perpX = -(y0 - y1);\n        perpY = x0 - x1;\n\n        dist = Math.sqrt((perpX * perpX) + (perpY * perpY));\n        perpX /= dist;\n        perpY /= dist;\n        perpX *= width;\n        perpY *= width;\n\n        perp1x = -(y1 - y2);\n        perp1y = x1 - x2;\n\n        dist = Math.sqrt((perp1x * perp1x) + (perp1y * perp1y));\n        perp1x /= dist;\n        perp1y /= dist;\n        perp1x *= width;\n        perp1y *= width;\n\n        /* d[x|y](0|1) = the component displacement between points p(0,1|1,2) */\n        const dx0 = x1 - x0;\n        const dy0 = y0 - y1;\n        const dx1 = x1 - x2;\n        const dy1 = y2 - y1;\n\n        /* +ve if internal angle < 90 degree, -ve if internal angle > 90 degree. */\n        const dot = (dx0 * dx1) + (dy0 * dy1);\n        /* +ve if internal angle counterclockwise, -ve if internal angle clockwise. */\n        const cross = (dy0 * dx1) - (dy1 * dx0);\n        const clockwise = (cross < 0);\n\n        /* Going nearly parallel? */\n        /* atan(0.001) ~= 0.001 rad ~= 0.057 degree */\n        if (Math.abs(cross) < 0.001 * Math.abs(dot))\n        {\n            verts.push(\n                x1 - (perpX * innerWeight),\n                y1 - (perpY * innerWeight));\n            verts.push(\n                x1 + (perpX * outerWeight),\n                y1 + (perpY * outerWeight));\n\n            /* 180 degree corner? */\n            if (dot >= 0)\n            {\n                if (style.join === 'round')\n                {\n                    indexCount += round(\n                        x1, y1,\n                        x1 - (perpX * innerWeight), y1 - (perpY * innerWeight),\n                        x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight),\n                        verts, false) + 4;\n                }\n                else\n                {\n                    indexCount += 2;\n                }\n\n                verts.push(\n                    x1 - (perp1x * outerWeight),\n                    y1 - (perp1y * outerWeight));\n                verts.push(\n                    x1 + (perp1x * innerWeight),\n                    y1 + (perp1y * innerWeight));\n            }\n\n            continue;\n        }\n\n        /* p[x|y] is the miter point. pDist is the distance between miter point and p1. */\n        const c1 = ((-perpX + x0) * (-perpY + y1)) - ((-perpX + x1) * (-perpY + y0));\n        const c2 = ((-perp1x + x2) * (-perp1y + y1)) - ((-perp1x + x1) * (-perp1y + y2));\n        const px = ((dx0 * c2) - (dx1 * c1)) / cross;\n        const py = ((dy1 * c1) - (dy0 * c2)) / cross;\n        const pDist = ((px - x1) * (px - x1)) + ((py - y1) * (py - y1));\n\n        /* Inner miter point */\n        const imx = x1 + ((px - x1) * innerWeight);\n        const imy = y1 + ((py - y1) * innerWeight);\n        /* Outer miter point */\n        const omx = x1 - ((px - x1) * outerWeight);\n        const omy = y1 - ((py - y1) * outerWeight);\n\n        /* Is the inside miter point too far away, creating a spike? */\n        const smallerInsideSegmentSq = Math.min((dx0 * dx0) + (dy0 * dy0), (dx1 * dx1) + (dy1 * dy1));\n        const insideWeight = clockwise ? innerWeight : outerWeight;\n        const smallerInsideDiagonalSq = smallerInsideSegmentSq + (insideWeight * insideWeight * widthSquared);\n        const insideMiterOk = pDist <= smallerInsideDiagonalSq;\n\n        if (insideMiterOk)\n        {\n            if (style.join === 'bevel' || pDist / widthSquared > miterLimitSquared)\n            {\n                if (clockwise) /* rotating at inner angle */\n                {\n                    verts.push(imx, imy); // inner miter point\n                    verts.push(x1 + (perpX * outerWeight), y1 + (perpY * outerWeight)); // first segment's outer vertex\n                    verts.push(imx, imy); // inner miter point\n                    verts.push(x1 + (perp1x * outerWeight), y1 + (perp1y * outerWeight)); // second segment's outer vertex\n                }\n                else /* rotating at outer angle */\n                {\n                    verts.push(x1 - (perpX * innerWeight), y1 - (perpY * innerWeight)); // first segment's inner vertex\n                    verts.push(omx, omy); // outer miter point\n                    verts.push(x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight)); // second segment's outer vertex\n                    verts.push(omx, omy); // outer miter point\n                }\n\n                indexCount += 2;\n            }\n            else if (style.join === 'round')\n            {\n                if (clockwise) /* arc is outside */\n                {\n                    verts.push(imx, imy);\n                    verts.push(x1 + (perpX * outerWeight), y1 + (perpY * outerWeight));\n\n                    indexCount += round(\n                        x1, y1,\n                        x1 + (perpX * outerWeight), y1 + (perpY * outerWeight),\n                        x1 + (perp1x * outerWeight), y1 + (perp1y * outerWeight),\n                        verts, true\n                    ) + 4;\n\n                    verts.push(imx, imy);\n                    verts.push(x1 + (perp1x * outerWeight), y1 + (perp1y * outerWeight));\n                }\n                else /* arc is inside */\n                {\n                    verts.push(x1 - (perpX * innerWeight), y1 - (perpY * innerWeight));\n                    verts.push(omx, omy);\n\n                    indexCount += round(\n                        x1, y1,\n                        x1 - (perpX * innerWeight), y1 - (perpY * innerWeight),\n                        x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight),\n                        verts, false\n                    ) + 4;\n\n                    verts.push(x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight));\n                    verts.push(omx, omy);\n                }\n            }\n            else\n            {\n                verts.push(imx, imy);\n                verts.push(omx, omy);\n            }\n        }\n        else // inside miter is NOT ok\n        {\n            verts.push(x1 - (perpX * innerWeight), y1 - (perpY * innerWeight)); // first segment's inner vertex\n            verts.push(x1 + (perpX * outerWeight), y1 + (perpY * outerWeight)); // first segment's outer vertex\n            if (style.join === 'round')\n            {\n                if (clockwise) /* arc is outside */\n                {\n                    indexCount += round(\n                        x1, y1,\n                        x1 + (perpX * outerWeight), y1 + (perpY * outerWeight),\n                        x1 + (perp1x * outerWeight), y1 + (perp1y * outerWeight),\n                        verts, true\n                    ) + 2;\n                }\n                else /* arc is inside */\n                {\n                    indexCount += round(\n                        x1, y1,\n                        x1 - (perpX * innerWeight), y1 - (perpY * innerWeight),\n                        x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight),\n                        verts, false\n                    ) + 2;\n                }\n            }\n            else if (style.join === 'miter' && pDist / widthSquared <= miterLimitSquared)\n            {\n                if (clockwise)\n                {\n                    verts.push(omx, omy); // inner miter point\n                    verts.push(omx, omy); // inner miter point\n                }\n                else\n                {\n                    verts.push(imx, imy); // outer miter point\n                    verts.push(imx, imy); // outer miter point\n                }\n                indexCount += 2;\n            }\n            verts.push(x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight)); // second segment's inner vertex\n            verts.push(x1 + (perp1x * outerWeight), y1 + (perp1y * outerWeight)); // second segment's outer vertex\n            indexCount += 2;\n        }\n    }\n\n    x0 = points[(length - 2) * 2];\n    y0 = points[((length - 2) * 2) + 1];\n\n    x1 = points[(length - 1) * 2];\n    y1 = points[((length - 1) * 2) + 1];\n\n    perpX = -(y0 - y1);\n    perpY = x0 - x1;\n\n    dist = Math.sqrt((perpX * perpX) + (perpY * perpY));\n    perpX /= dist;\n    perpY /= dist;\n    perpX *= width;\n    perpY *= width;\n\n    verts.push(x1 - (perpX * innerWeight), y1 - (perpY * innerWeight));\n    verts.push(x1 + (perpX * outerWeight), y1 + (perpY * outerWeight));\n\n    if (!closedShape)\n    {\n        if (style.cap === 'round')\n        {\n            indexCount += round(\n                x1 - (perpX * (innerWeight - outerWeight) * 0.5),\n                y1 - (perpY * (innerWeight - outerWeight) * 0.5),\n                x1 - (perpX * innerWeight),\n                y1 - (perpY * innerWeight),\n                x1 + (perpX * outerWeight),\n                y1 + (perpY * outerWeight),\n                verts,\n                false\n            ) + 2;\n        }\n        else if (style.cap === 'square')\n        {\n            indexCount += square(x1, y1, perpX, perpY, innerWeight, outerWeight, false, verts);\n        }\n    }\n\n    // const indices = graphicsGeometry.indices;\n    const eps2 = curveEps * curveEps;\n\n    // indices.push(indexStart);\n    for (let i = indexStart; i < indexCount + indexStart - 2; ++i)\n    {\n        x0 = verts[(i * 2)];\n        y0 = verts[(i * 2) + 1];\n\n        x1 = verts[(i + 1) * 2];\n        y1 = verts[((i + 1) * 2) + 1];\n\n        x2 = verts[(i + 2) * 2];\n        y2 = verts[((i + 2) * 2) + 1];\n\n        /* Skip zero area triangles */\n        if (Math.abs((x0 * (y1 - y2)) + (x1 * (y2 - y0)) + (x2 * (y0 - y1))) < eps2)\n        {\n            continue;\n        }\n\n        indices.push(i, i + 1, i + 2);\n    }\n}\n\n"],"names":["closePointEps","getOrientationOfPoints","Point","curveEps"],"mappings":"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"}
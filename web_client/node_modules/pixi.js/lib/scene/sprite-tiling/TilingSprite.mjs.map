{"version":3,"file":"TilingSprite.mjs","sources":["../../../src/scene/sprite-tiling/TilingSprite.ts"],"sourcesContent":["import { Cache } from '../../assets/cache/Cache';\nimport { ObservablePoint } from '../../maths/point/ObservablePoint';\nimport { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation';\nimport { Transform } from '../../utils/misc/Transform';\nimport { ViewContainer, type ViewContainerOptions } from '../view/ViewContainer';\nimport { type TilingSpriteGpuData } from './TilingSpritePipe';\nimport './init';\n\nimport type { Size } from '../../maths/misc/Size';\nimport type { PointData } from '../../maths/point/PointData';\nimport type { Instruction } from '../../rendering/renderers/shared/instructions/Instruction';\nimport type { View } from '../../rendering/renderers/shared/view/View';\nimport type { Optional } from '../container/container-mixins/measureMixin';\nimport type { DestroyOptions } from '../container/destroyTypes';\n\n/**\n * Constructor options used for creating a TilingSprite instance.\n * Defines the texture, tiling behavior, and rendering properties of the sprite.\n * @example\n * ```ts\n * // Create a basic tiling sprite with repeating texture\n * const tilingSprite = new TilingSprite({\n *     texture: Texture.from('pattern.png'),\n *     width: 800,     // Width of the tiling area\n *     height: 600     // Height of the tiling area\n * });\n *\n * const background = new TilingSprite({\n *     texture: Texture.from('background.png'),\n *     width: app.screen.width,\n *     height: app.screen.height,\n *     tilePosition: { x: 0, y: 0 },\n *     tileScale: { x: 1.5, y: 1.5 }  // Scale up the texture\n *     anchor: 0.5,                    // Center anchor point\n *     roundPixels: true,              // Crisp pixel rendering\n * });\n * ```\n * @see {@link TilingSprite} For the main sprite class\n * @see {@link Texture} For texture management\n * @category scene\n * @standard\n * @noInheritDoc\n */\nexport interface TilingSpriteOptions extends PixiMixins.TilingSpriteOptions, ViewContainerOptions\n{\n    /**\n     * The anchor point of the TilingSprite (0-1 range)\n     *\n     * Controls the origin point for rotation, scaling, and positioning.\n     * Can be a number for uniform anchor or a PointData for separate x/y values.\n     * @example\n     * ```ts\n     * // Centered anchor\n     * const sprite = new TilingSprite({ ..., anchor: 0.5 });\n     * sprite.anchor = 0.5;\n     * // Separate x/y anchor\n     * sprite.anchor = { x: 0.5, y: 0.5 };\n     * // Right-aligned anchor\n     * sprite.anchor = { x: 1, y: 0 };\n     * // Update anchor directly\n     * sprite.anchor.set(0.5, 0.5);\n     * ```\n     * @default 0\n     */\n    anchor?: PointData | number;\n    /**\n     * The offset of the tiling texture.\n     * Used to scroll or position the repeated pattern.\n     * @example\n     * ```ts\n     * // Offset the tiling pattern by 100 pixels in both x and y directions\n     * tilingSprite.tilePosition = { x: 100, y: 100 };\n     * ```\n     * @default {x: 0, y: 0}\n     */\n    tilePosition?: PointData\n    /**\n     * Scale of the tiling texture.\n     * Affects the size of each repeated instance of the texture.\n     * @example\n     * ```ts\n     * // Scale the texture by 1.5 in both x and y directions\n     * tilingSprite.tileScale = { x: 1.5, y: 1.5 };\n     * ```\n     * @default {x: 1, y: 1}\n     */\n    tileScale?: PointData\n    /**\n     * Rotation of the tiling texture in radians.\n     * This controls the rotation applied to the texture before tiling.\n     * @example\n     * ```ts\n     * // Rotate the texture by 45 degrees (in radians)\n     * tilingSprite.tileRotation = Math.PI / 4; // 45 degrees\n     * ```\n     * @default 0\n     */\n    tileRotation?: number\n    /**\n     * The texture to use for tiling.\n     * This is the image that will be repeated across the sprite.\n     * @example\n     * ```ts\n     * // Use a texture from the asset cache\n     * tilingSprite.texture = Texture.from('assets/pattern.png');\n     * ```\n     * @default Texture.WHITE\n     */\n    texture?: Texture\n    /**\n     * The width of the tiling area.\n     * This defines how wide the tiling sprite will be.\n     * @example\n     * ```ts\n     * // Set the width of the tiling sprite to 800 pixels\n     * tilingSprite.width = 800;\n     * ```\n     * @default 256\n     */\n    width?: number\n    /**\n     * The height of the tiling area.\n     * This defines how tall the tiling sprite will be.\n     * @example\n     * ```ts\n     * // Set the height of the tiling sprite to 600 pixels\n     * tilingSprite.height = 600;\n     * ```\n     * @default 256\n     */\n    height?: number\n    /**\n     * Whether the tiling pattern should originate from the anchor point.\n     * When true, tiling starts from the origin instead of top-left.\n     *\n     * This will make the texture coordinates assigned to each vertex dependent on the value of the anchor. Without\n     * this, the top-left corner always gets the (0, 0) texture coordinate.\n     * @example\n     * ```ts\n     * // Enable anchor-based tiling\n     * tilingSprite.applyAnchorToTexture = true;\n     * ```\n     * @default false\n     */\n    applyAnchorToTexture?: boolean\n    /**\n     * Whether to round the sprite's position to whole pixels.\n     * This can help with crisp rendering, especially for pixel art.\n     * When true, the sprite's position will be rounded to the nearest pixel.\n     * @example\n     * ```ts\n     * // Enable pixel rounding for crisp rendering\n     * tilingSprite.roundPixels = true;\n     * ```\n     * @default false\n     */\n    roundPixels?: boolean;\n}\n// eslint-disable-next-line requireExport/require-export-jsdoc, requireMemberAPI/require-member-api-doc\nexport interface TilingSprite extends PixiMixins.TilingSprite, ViewContainer<TilingSpriteGpuData> {}\n\n/**\n * A TilingSprite is a fast and efficient way to render a repeating texture across a given area.\n * The texture can be scrolled, scaled, and rotated independently of the sprite itself.\n * @example\n * ```ts\n * // Create a simple tiling background\n * const background = new TilingSprite({\n *     texture: Texture.from('background.png'),\n *     width: app.screen.width,\n *     height: app.screen.height,\n * });\n * app.stage.addChild(background);\n *\n * // Create a scrolling parallax background\n * const parallax = new TilingSprite({\n *     texture: Texture.from('clouds.png'),\n *     width: app.screen.width,\n *     height: app.screen.height,\n *     tileScale: { x: 0.5, y: 0.5 }\n * });\n *\n * // Animate the tiling position\n * app.ticker.add(() => {\n *     parallax.tilePosition.x -= 1; // Scroll left\n *     parallax.tilePosition.y -= 0.5; // Scroll up slowly\n * });\n *\n * // Create a repeating pattern with rotation\n * const pattern = new TilingSprite({\n *     texture: Texture.from('pattern.png'),\n *     width: 300,\n *     height: 200,\n *     tileRotation: Math.PI / 4, // 45 degree rotation\n *     anchor: 0.5 // Center anchor point\n * });\n * ```\n * @category scene\n * @standard\n * @see {@link TilingSpriteOptions} For configuration options\n * @see {@link Texture} For texture management\n * @see {@link Assets} For asset loading\n */\nexport class TilingSprite extends ViewContainer<TilingSpriteGpuData> implements View, Instruction\n{\n    /**\n     * Creates a new tiling sprite based on a source texture or image path.\n     * This is a convenience method that automatically creates and manages textures.\n     * @example\n     * ```ts\n     * // Create a new tiling sprite from an image path\n     * const pattern = TilingSprite.from('pattern.png');\n     * pattern.width = 300; // Set the width of the tiling area\n     * pattern.height = 200; // Set the height of the tiling area\n     *\n     * // Create from options\n     * const texture = Texture.from('pattern.png');\n     * const pattern = TilingSprite.from(texture, {\n     *     width: 300,\n     *     height: 200,\n     *     tileScale: { x: 0.5, y: 0.5 }\n     * });\n     * ```\n     * @param source - The source to create the sprite from. Can be a path to an image or a texture\n     * @param options - Additional options for the tiling sprite\n     * @returns A new tiling sprite based on the source\n     * @see {@link Texture.from} For texture creation details\n     * @see {@link Assets} For asset loading and management\n     */\n    public static from(source: Texture | string, options: TilingSpriteOptions = {})\n    {\n        if (typeof source === 'string')\n        {\n            return new TilingSprite({\n                texture: Cache.get(source),\n                ...options,\n            });\n        }\n\n        return new TilingSprite({\n            texture: source,\n            ...options,\n        });\n    }\n\n    /**\n     * Default options used when creating a TilingSprite instance.\n     * These values are used as fallbacks when specific options are not provided.\n     * @example\n     * ```ts\n     * // Override default options globally\n     * TilingSprite.defaultOptions.texture = Texture.from('defaultPattern.png');\n     * TilingSprite.defaultOptions.tileScale = { x: 2, y: 2 };\n     *\n     * // Create sprite using default options\n     * const sprite = new TilingSprite();\n     * // Will use defaultPattern.png and scale 2x\n     * ```\n     * @type {TilingSpriteOptions}\n     * @see {@link TilingSpriteOptions} For all available options\n     * @see {@link TilingSprite.from} For creating sprites with custom options\n     * @see {@link Texture.EMPTY} For the default empty texture\n     */\n    public static defaultOptions: TilingSpriteOptions = {\n        /** The texture to use for the sprite. */\n        texture: Texture.EMPTY,\n        /** The anchor point of the sprite */\n        anchor: { x: 0, y: 0 },\n        /** The offset of the image that is being tiled. */\n        tilePosition: { x: 0, y: 0 },\n        /** Scaling of the image that is being tiled. */\n        tileScale: { x: 1, y: 1 },\n        /** The rotation of the image that is being tiled. */\n        tileRotation: 0,\n        /**\n         * Flags whether the tiling pattern should originate from the origin instead of the top-left corner in\n         * local space.\n         *\n         * This will make the texture coordinates assigned to each vertex dependent on the value of the anchor. Without\n         * this, the top-left corner always gets the (0, 0) texture coordinate.\n         * @default false\n         */\n        applyAnchorToTexture: false,\n    };\n\n    /** @internal */\n    public override readonly renderPipeId: string = 'tilingSprite';\n    /** @advanced */\n    public readonly batched = true;\n\n    /**\n     * Flags whether the tiling pattern should originate from the origin instead of the top-left corner in\n     * local space.\n     *\n     * This will make the texture coordinates assigned to each vertex dependent on the value of the anchor. Without\n     * this, the top-left corner always gets the (0, 0) texture coordinate.\n     * @example\n     * ```ts\n     * // Enable anchor-based tiling\n     * tilingSprite.applyAnchorToTexture = true;\n     * ```\n     * @default false\n     */\n    public applyAnchorToTexture: boolean;\n    /**\n     * @see {@link TilingSpriteOptions.applyAnchorToTexture}\n     * @deprecated since 8.0.0\n     * @advanced\n     */\n    public get uvRespectAnchor(): boolean\n    {\n        deprecation(v8_0_0, 'uvRespectAnchor is deprecated, please use applyAnchorToTexture instead');\n\n        return this.applyAnchorToTexture;\n    }\n    /** @advanced */\n    public set uvRespectAnchor(value: boolean)\n    {\n        deprecation(v8_0_0, 'uvRespectAnchor is deprecated, please use applyAnchorToTexture instead');\n        this.applyAnchorToTexture = value;\n    }\n\n    /** @internal */\n    public _anchor: ObservablePoint;\n    /** @internal */\n    public _tileTransform: Transform;\n    /** @internal */\n    public _texture: Texture;\n\n    private _width: number;\n    private _height: number;\n\n    /**\n     * @param {Texture | TilingSpriteOptions} options - The options for creating the tiling sprite.\n     */\n    constructor(options?: Texture | TilingSpriteOptions);\n    /** @deprecated since 8.0.0 */\n    constructor(texture: Texture, width: number, height: number);\n    constructor(...args: [(Texture | TilingSpriteOptions)?] | [Texture, number, number])\n    {\n        let options = args[0] || {};\n\n        if (options instanceof Texture)\n        {\n            options = { texture: options };\n        }\n\n        if (args.length > 1)\n        {\n            // #if _DEBUG\n            deprecation(v8_0_0, 'use new TilingSprite({ texture, width:100, height:100 }) instead');\n            // #endif\n\n            options.width = args[1];\n            options.height = args[2];\n        }\n\n        options = { ...TilingSprite.defaultOptions, ...options };\n\n        const {\n            texture,\n            anchor,\n            tilePosition,\n            tileScale,\n            tileRotation,\n            width,\n            height,\n            applyAnchorToTexture,\n            roundPixels,\n            ...rest\n        } = options ?? {};\n\n        super({\n\n            label: 'TilingSprite',\n            ...rest\n        });\n\n        this.allowChildren = false;\n\n        this._anchor = new ObservablePoint(\n            {\n                _onUpdate: () =>\n                {\n                    this.onViewUpdate();\n                }\n            },\n        );\n\n        this.applyAnchorToTexture = applyAnchorToTexture;\n\n        this.texture = texture;\n        this._width = width ?? texture.width;\n        this._height = height ?? texture.height;\n\n        this._tileTransform = new Transform({\n            observer: {\n                _onUpdate: () => this.onViewUpdate(),\n            }\n        });\n\n        if (anchor) this.anchor = anchor;\n        this.tilePosition = tilePosition;\n        this.tileScale = tileScale;\n        this.tileRotation = tileRotation;\n\n        this.roundPixels = roundPixels ?? false;\n    }\n\n    /**\n     * Changes frame clamping in corresponding textureMatrix\n     * Change to -0.5 to add a pixel to the edge, recommended for transparent trimmed textures in atlas\n     * @default 0.5\n     * @type {number}\n     * @advanced\n     */\n    get clampMargin()\n    {\n        return this._texture.textureMatrix.clampMargin;\n    }\n\n    /** @advanced */\n    set clampMargin(value: number)\n    {\n        this._texture.textureMatrix.clampMargin = value;\n    }\n\n    /**\n     * The anchor sets the origin point of the sprite. The default value is taken from the {@link Texture}\n     * and passed to the constructor.\n     *\n     * - The default is `(0,0)`, this means the sprite's origin is the top left.\n     * - Setting the anchor to `(0.5,0.5)` means the sprite's origin is centered.\n     * - Setting the anchor to `(1,1)` would mean the sprite's origin point will be the bottom right corner.\n     *\n     * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.\n     * @example\n     * ```ts\n     * // Center the anchor point\n     * sprite.anchor = 0.5; // Sets both x and y to 0.5\n     * sprite.position.set(400, 300); // Sprite will be centered at this position\n     *\n     * // Set specific x/y anchor points\n     * sprite.anchor = {\n     *     x: 1, // Right edge\n     *     y: 0  // Top edge\n     * };\n     *\n     * // Using individual coordinates\n     * sprite.anchor.set(0.5, 1); // Center-bottom\n     *\n     * // For rotation around center\n     * sprite.anchor.set(0.5);\n     * sprite.rotation = Math.PI / 4; // 45 degrees around center\n     *\n     * // For scaling from center\n     * sprite.anchor.set(0.5);\n     * sprite.scale.set(2); // Scales from center point\n     * ```\n     */\n    get anchor(): ObservablePoint\n    {\n        return this._anchor;\n    }\n\n    set anchor(value: PointData | number)\n    {\n        typeof value === 'number' ? this._anchor.set(value) : this._anchor.copyFrom(value);\n    }\n\n    /**\n     * The offset of the tiling texture.\n     * Used to scroll or position the repeated pattern.\n     * @example\n     * ```ts\n     * // Offset the tiling pattern by 100 pixels in both x and y directions\n     * tilingSprite.tilePosition = { x: 100, y: 100 };\n     * ```\n     * @default {x: 0, y: 0}\n     */\n    get tilePosition(): ObservablePoint\n    {\n        return this._tileTransform.position;\n    }\n\n    set tilePosition(value: PointData)\n    {\n        this._tileTransform.position.copyFrom(value);\n    }\n\n    /**\n     * Scale of the tiling texture.\n     * Affects the size of each repeated instance of the texture.\n     * @example\n     * ```ts\n     * // Scale the texture by 1.5 in both x and y directions\n     * tilingSprite.tileScale = { x: 1.5, y: 1.5 };\n     * ```\n     * @default {x: 1, y: 1}\n     */\n    get tileScale(): ObservablePoint\n    {\n        return this._tileTransform.scale;\n    }\n\n    set tileScale(value: PointData | number)\n    {\n        typeof value === 'number' ? this._tileTransform.scale.set(value) : this._tileTransform.scale.copyFrom(value);\n    }\n\n    set tileRotation(value)\n    {\n        this._tileTransform.rotation = value;\n    }\n\n    /**\n     * Rotation of the tiling texture in radians.\n     * This controls the rotation applied to the texture before tiling.\n     * @example\n     * ```ts\n     * // Rotate the texture by 45 degrees (in radians)\n     * tilingSprite.tileRotation = Math.PI / 4; // 45 degrees\n     * ```\n     * @default 0\n     */\n    get tileRotation()\n    {\n        return this._tileTransform.rotation;\n    }\n\n    /**\n     * The transform object that controls the tiling texture's position, scale, and rotation.\n     * This transform is independent of the sprite's own transform properties.\n     * @example\n     * ```ts\n     * // Access transform properties directly\n     * sprite.tileTransform.position.set(100, 50);\n     * sprite.tileTransform.scale.set(2);\n     * sprite.tileTransform.rotation = Math.PI / 4;\n     *\n     * // Create smooth scrolling animation\n     * app.ticker.add(() => {\n     *     sprite.tileTransform.position.x += 1;\n     *     sprite.tileTransform.rotation += 0.01;\n     * });\n     *\n     * // Reset transform\n     * sprite.tileTransform.position.set(0);\n     * sprite.tileTransform.scale.set(1);\n     * sprite.tileTransform.rotation = 0;\n     * ```\n     * @returns {Transform} The transform object for the tiling texture\n     * @see {@link Transform} For transform operations\n     * @see {@link TilingSprite#tilePosition} For position control\n     * @see {@link TilingSprite#tileScale} For scale control\n     * @see {@link TilingSprite#tileRotation} For rotation control\n     * @advanced\n     */\n    get tileTransform()\n    {\n        return this._tileTransform;\n    }\n\n    set texture(value: Texture)\n    {\n        value ||= Texture.EMPTY;\n\n        const currentTexture = this._texture;\n\n        if (currentTexture === value) return;\n\n        if (currentTexture && currentTexture.dynamic) currentTexture.off('update', this.onViewUpdate, this);\n        if (value.dynamic) value.on('update', this.onViewUpdate, this);\n\n        this._texture = value;\n\n        this.onViewUpdate();\n    }\n\n    /**\n     * The texture to use for tiling.\n     * This is the image that will be repeated across the sprite.\n     * @example\n     * ```ts\n     * // Use a texture from the asset cache\n     * tilingSprite.texture = Texture.from('assets/pattern.png');\n     * ```\n     * @default Texture.WHITE\n     */\n    get texture()\n    {\n        return this._texture;\n    }\n\n    /**\n     * The width of the tiling area. This defines how wide the area is that the texture will be tiled across.\n     * @example\n     * ```ts\n     * // Create a tiling sprite\n     * const sprite = new TilingSprite({\n     *     texture: Texture.from('pattern.png'),\n     *     width: 500,\n     *     height: 300\n     * });\n     *\n     * // Adjust width dynamically\n     * sprite.width = 800; // Expands tiling area\n     *\n     * // Update on resize\n     * window.addEventListener('resize', () => {\n     *     sprite.width = app.screen.width;\n     * });\n     * ```\n     * @see {@link TilingSprite#setSize} For setting both width and height efficiently\n     * @see {@link TilingSprite#height} For setting height\n     */\n    override set width(value: number)\n    {\n        this._width = value;\n        this.onViewUpdate();\n    }\n\n    override get width()\n    {\n        return this._width;\n    }\n\n    override set height(value: number)\n    {\n        this._height = value;\n        this.onViewUpdate();\n    }\n\n    /**\n     * The height of the tiling area. This defines how tall the area is that the texture will be tiled across.\n     * @example\n     * ```ts\n     * // Create a tiling sprite\n     * const sprite = new TilingSprite({\n     *     texture: Texture.from('pattern.png'),\n     *     width: 500,\n     *     height: 300\n     * });\n     *\n     * // Adjust width dynamically\n     * sprite.height = 800; // Expands tiling area\n     *\n     * // Update on resize\n     * window.addEventListener('resize', () => {\n     *     sprite.height = app.screen.height;\n     * });\n     * ```\n     * @see {@link TilingSprite#setSize} For setting both width and height efficiently\n     * @see {@link TilingSprite#width} For setting width\n     */\n    override get height()\n    {\n        return this._height;\n    }\n\n    /**\n     * Sets the size of the TilingSprite to the specified width and height.\n     * This is faster than setting width and height separately as it only triggers one update.\n     * @example\n     * ```ts\n     * // Set specific dimensions\n     * sprite.setSize(300, 200); // Width: 300, Height: 200\n     *\n     * // Set uniform size (square)\n     * sprite.setSize(400); // Width: 400, Height: 400\n     *\n     * // Set size using object\n     * sprite.setSize({\n     *     width: 500,\n     *     height: 300\n     * });\n     * ```\n     * @param value - This can be either a number for uniform sizing or a Size object with width/height properties\n     * @param height - The height to set. Defaults to the value of `width` if not provided\n     * @see {@link TilingSprite#width} For setting width only\n     * @see {@link TilingSprite#height} For setting height only\n     */\n    public override setSize(value: number | Optional<Size, 'height'>, height?: number): void\n    {\n        if (typeof value === 'object')\n        {\n            height = value.height ?? value.width;\n            value = value.width;\n        }\n\n        this._width = value;\n        this._height = height ?? value;\n\n        this.onViewUpdate();\n    }\n\n    /**\n     * Retrieves the size of the TilingSprite as a {@link Size} object.\n     * This method is more efficient than getting width and height separately as it only allocates one object.\n     * @example\n     * ```ts\n     * // Get basic size\n     * const size = sprite.getSize();\n     * console.log(`Size: ${size.width}x${size.height}`);\n     *\n     * // Reuse existing size object\n     * const reuseSize = { width: 0, height: 0 };\n     * sprite.getSize(reuseSize);\n     * ```\n     * @param out - Optional object to store the size in, to avoid allocating a new object\n     * @returns The size of the TilingSprite\n     * @see {@link TilingSprite#width} For getting just the width\n     * @see {@link TilingSprite#height} For getting just the height\n     * @see {@link TilingSprite#setSize} For setting both width and height efficiently\n     */\n    public override getSize(out?: Size): Size\n    {\n        out ||= {} as Size;\n        out.width = this._width;\n        out.height = this._height;\n\n        return out;\n    }\n\n    /** @private */\n    protected override updateBounds()\n    {\n        const bounds = this._bounds;\n\n        const anchor = this._anchor;\n\n        const width = this._width;\n        const height = this._height;\n\n        bounds.minX = -anchor._x * width;\n        bounds.maxX = bounds.minX + width;\n\n        bounds.minY = -anchor._y * height;\n        bounds.maxY = bounds.minY + height;\n    }\n\n    /**\n     * Checks if the object contains the given point in local coordinates.\n     * Takes into account the anchor offset when determining boundaries.\n     * @example\n     * ```ts\n     * // Create a tiling sprite\n     * const sprite = new TilingSprite({\n     *     texture: Texture.from('pattern.png'),\n     *     width: 200,\n     *     height: 100,\n     *     anchor: 0.5 // Center anchor\n     * });\n     *\n     * // Basic point check\n     * const contains = sprite.containsPoint({ x: 50, y: 25 });\n     * console.log('Point is inside:', contains);\n     *\n     * // Check with different anchors\n     * sprite.anchor.set(0); // Top-left anchor\n     * console.log('Contains point:', sprite.containsPoint({ x: 150, y: 75 }));\n     * ```\n     * @param point - The point to check in local coordinates\n     * @returns True if the point is within the sprite's bounds\n     * @see {@link TilingSprite#toLocal} For converting global coordinates to local\n     * @see {@link TilingSprite#anchor} For understanding boundary calculations\n     */\n    public override containsPoint(point: PointData)\n    {\n        const width = this._width;\n        const height = this._height;\n        const x1 = -width * this._anchor._x;\n        let y1 = 0;\n\n        if (point.x >= x1 && point.x <= x1 + width)\n        {\n            y1 = -height * this._anchor._y;\n\n            if (point.y >= y1 && point.y <= y1 + height) return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Destroys this sprite renderable and optionally its texture.\n     * @param options - Options parameter. A boolean will act as if all options\n     *  have been set to that value\n     * @example\n     * tilingSprite.destroy();\n     * tilingSprite.destroy(true);\n     * tilingSprite.destroy({ texture: true, textureSource: true });\n     */\n    public override destroy(options: DestroyOptions = false)\n    {\n        super.destroy(options);\n\n        this._anchor = null;\n        this._tileTransform = null;\n        this._bounds = null;\n\n        const destroyTexture = typeof options === 'boolean' ? options : options?.texture;\n\n        if (destroyTexture)\n        {\n            const destroyTextureSource = typeof options === 'boolean' ? options : options?.textureSource;\n\n            this._texture.destroy(destroyTextureSource);\n        }\n\n        this._texture = null;\n    }\n}\n\n"],"names":[],"mappings":";;;;;;;;;AA4MO,MAAM,aAAA,GAAN,MAAM,aAAA,SAAqB,aAAA,CAClC;AAAA,EAsII,eAAe,IAAA,EACf;AACI,IAAA,IAAI,OAAA,GAAU,IAAA,CAAK,CAAC,CAAA,IAAK,EAAC;AAE1B,IAAA,IAAI,mBAAmB,OAAA,EACvB;AACI,MAAA,OAAA,GAAU,EAAE,SAAS,OAAA,EAAQ;AAAA,IACjC;AAEA,IAAA,IAAI,IAAA,CAAK,SAAS,CAAA,EAClB;AAEI,MAAA,WAAA,CAAY,QAAQ,kEAAkE,CAAA;AAGtF,MAAA,OAAA,CAAQ,KAAA,GAAQ,KAAK,CAAC,CAAA;AACtB,MAAA,OAAA,CAAQ,MAAA,GAAS,KAAK,CAAC,CAAA;AAAA,IAC3B;AAEA,IAAA,OAAA,GAAU,EAAE,GAAG,aAAA,CAAa,cAAA,EAAgB,GAAG,OAAA,EAAQ;AAEvD,IAAA,MAAM;AAAA,MACF,OAAA;AAAA,MACA,MAAA;AAAA,MACA,YAAA;AAAA,MACA,SAAA;AAAA,MACA,YAAA;AAAA,MACA,KAAA;AAAA,MACA,MAAA;AAAA,MACA,oBAAA;AAAA,MACA,WAAA;AAAA,MACA,GAAG;AAAA,KACP,GAAI,WAAW,EAAC;AAEhB,IAAA,KAAA,CAAM;AAAA,MAEF,KAAA,EAAO,cAAA;AAAA,MACP,GAAG;AAAA,KACN,CAAA;AA1FL;AAAA,IAAA,IAAA,CAAyB,YAAA,GAAuB,cAAA;AAEhD;AAAA,IAAA,IAAA,CAAgB,OAAA,GAAU,IAAA;AA0FtB,IAAA,IAAA,CAAK,aAAA,GAAgB,KAAA;AAErB,IAAA,IAAA,CAAK,UAAU,IAAI,eAAA;AAAA,MACf;AAAA,QACI,WAAW,MACX;AACI,UAAA,IAAA,CAAK,YAAA,EAAa;AAAA,QACtB;AAAA;AACJ,KACJ;AAEA,IAAA,IAAA,CAAK,oBAAA,GAAuB,oBAAA;AAE5B,IAAA,IAAA,CAAK,OAAA,GAAU,OAAA;AACf,IAAA,IAAA,CAAK,MAAA,GAAS,SAAS,OAAA,CAAQ,KAAA;AAC/B,IAAA,IAAA,CAAK,OAAA,GAAU,UAAU,OAAA,CAAQ,MAAA;AAEjC,IAAA,IAAA,CAAK,cAAA,GAAiB,IAAI,SAAA,CAAU;AAAA,MAChC,QAAA,EAAU;AAAA,QACN,SAAA,EAAW,MAAM,IAAA,CAAK,YAAA;AAAa;AACvC,KACH,CAAA;AAED,IAAA,IAAI,MAAA,OAAa,MAAA,GAAS,MAAA;AAC1B,IAAA,IAAA,CAAK,YAAA,GAAe,YAAA;AACpB,IAAA,IAAA,CAAK,SAAA,GAAY,SAAA;AACjB,IAAA,IAAA,CAAK,YAAA,GAAe,YAAA;AAEpB,IAAA,IAAA,CAAK,cAAc,WAAA,IAAe,KAAA;AAAA,EACtC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAlLA,OAAc,IAAA,CAAK,MAAA,EAA0B,OAAA,GAA+B,EAAC,EAC7E;AACI,IAAA,IAAI,OAAO,WAAW,QAAA,EACtB;AACI,MAAA,OAAO,IAAI,aAAA,CAAa;AAAA,QACpB,OAAA,EAAS,KAAA,CAAM,GAAA,CAAI,MAAM,CAAA;AAAA,QACzB,GAAG;AAAA,OACN,CAAA;AAAA,IACL;AAEA,IAAA,OAAO,IAAI,aAAA,CAAa;AAAA,MACpB,OAAA,EAAS,MAAA;AAAA,MACT,GAAG;AAAA,KACN,CAAA;AAAA,EACL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAkEA,IAAW,eAAA,GACX;AACI,IAAA,WAAA,CAAY,QAAQ,wEAAwE,CAAA;AAE5F,IAAA,OAAO,IAAA,CAAK,oBAAA;AAAA,EAChB;AAAA;AAAA,EAEA,IAAW,gBAAgB,KAAA,EAC3B;AACI,IAAA,WAAA,CAAY,QAAQ,wEAAwE,CAAA;AAC5F,IAAA,IAAA,CAAK,oBAAA,GAAuB,KAAA;AAAA,EAChC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAgGA,IAAI,WAAA,GACJ;AACI,IAAA,OAAO,IAAA,CAAK,SAAS,aAAA,CAAc,WAAA;AAAA,EACvC;AAAA;AAAA,EAGA,IAAI,YAAY,KAAA,EAChB;AACI,IAAA,IAAA,CAAK,QAAA,CAAS,cAAc,WAAA,GAAc,KAAA;AAAA,EAC9C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAmCA,IAAI,MAAA,GACJ;AACI,IAAA,OAAO,IAAA,CAAK,OAAA;AAAA,EAChB;AAAA,EAEA,IAAI,OAAO,KAAA,EACX;AACI,IAAA,OAAO,KAAA,KAAU,QAAA,GAAW,IAAA,CAAK,OAAA,CAAQ,GAAA,CAAI,KAAK,CAAA,GAAI,IAAA,CAAK,OAAA,CAAQ,QAAA,CAAS,KAAK,CAAA;AAAA,EACrF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYA,IAAI,YAAA,GACJ;AACI,IAAA,OAAO,KAAK,cAAA,CAAe,QAAA;AAAA,EAC/B;AAAA,EAEA,IAAI,aAAa,KAAA,EACjB;AACI,IAAA,IAAA,CAAK,cAAA,CAAe,QAAA,CAAS,QAAA,CAAS,KAAK,CAAA;AAAA,EAC/C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYA,IAAI,SAAA,GACJ;AACI,IAAA,OAAO,KAAK,cAAA,CAAe,KAAA;AAAA,EAC/B;AAAA,EAEA,IAAI,UAAU,KAAA,EACd;AACI,IAAA,OAAO,KAAA,KAAU,QAAA,GAAW,IAAA,CAAK,cAAA,CAAe,KAAA,CAAM,GAAA,CAAI,KAAK,CAAA,GAAI,IAAA,CAAK,cAAA,CAAe,KAAA,CAAM,QAAA,CAAS,KAAK,CAAA;AAAA,EAC/G;AAAA,EAEA,IAAI,aAAa,KAAA,EACjB;AACI,IAAA,IAAA,CAAK,eAAe,QAAA,GAAW,KAAA;AAAA,EACnC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYA,IAAI,YAAA,GACJ;AACI,IAAA,OAAO,KAAK,cAAA,CAAe,QAAA;AAAA,EAC/B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EA8BA,IAAI,aAAA,GACJ;AACI,IAAA,OAAO,IAAA,CAAK,cAAA;AAAA,EAChB;AAAA,EAEA,IAAI,QAAQ,KAAA,EACZ;AACI,IAAA,KAAA,KAAA,KAAA,GAAU,OAAA,CAAQ,KAAA,CAAA;AAElB,IAAA,MAAM,iBAAiB,IAAA,CAAK,QAAA;AAE5B,IAAA,IAAI,mBAAmB,KAAA,EAAO;AAE9B,IAAA,IAAI,cAAA,IAAkB,eAAe,OAAA,EAAS,cAAA,CAAe,IAAI,QAAA,EAAU,IAAA,CAAK,cAAc,IAAI,CAAA;AAClG,IAAA,IAAI,MAAM,OAAA,EAAS,KAAA,CAAM,GAAG,QAAA,EAAU,IAAA,CAAK,cAAc,IAAI,CAAA;AAE7D,IAAA,IAAA,CAAK,QAAA,GAAW,KAAA;AAEhB,IAAA,IAAA,CAAK,YAAA,EAAa;AAAA,EACtB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYA,IAAI,OAAA,GACJ;AACI,IAAA,OAAO,IAAA,CAAK,QAAA;AAAA,EAChB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAwBA,IAAa,MAAM,KAAA,EACnB;AACI,IAAA,IAAA,CAAK,MAAA,GAAS,KAAA;AACd,IAAA,IAAA,CAAK,YAAA,EAAa;AAAA,EACtB;AAAA,EAEA,IAAa,KAAA,GACb;AACI,IAAA,OAAO,IAAA,CAAK,MAAA;AAAA,EAChB;AAAA,EAEA,IAAa,OAAO,KAAA,EACpB;AACI,IAAA,IAAA,CAAK,OAAA,GAAU,KAAA;AACf,IAAA,IAAA,CAAK,YAAA,EAAa;AAAA,EACtB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAwBA,IAAa,MAAA,GACb;AACI,IAAA,OAAO,IAAA,CAAK,OAAA;AAAA,EAChB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAwBgB,OAAA,CAAQ,OAA0C,MAAA,EAClE;AACI,IAAA,IAAI,OAAO,UAAU,QAAA,EACrB;AACI,MAAA,MAAA,GAAS,KAAA,CAAM,UAAU,KAAA,CAAM,KAAA;AAC/B,MAAA,KAAA,GAAQ,KAAA,CAAM,KAAA;AAAA,IAClB;AAEA,IAAA,IAAA,CAAK,MAAA,GAAS,KAAA;AACd,IAAA,IAAA,CAAK,UAAU,MAAA,IAAU,KAAA;AAEzB,IAAA,IAAA,CAAK,YAAA,EAAa;AAAA,EACtB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAqBgB,QAAQ,GAAA,EACxB;AACI,IAAA,GAAA,KAAA,GAAA,GAAQ,EAAC,CAAA;AACT,IAAA,GAAA,CAAI,QAAQ,IAAA,CAAK,MAAA;AACjB,IAAA,GAAA,CAAI,SAAS,IAAA,CAAK,OAAA;AAElB,IAAA,OAAO,GAAA;AAAA,EACX;AAAA;AAAA,EAGmB,YAAA,GACnB;AACI,IAAA,MAAM,SAAS,IAAA,CAAK,OAAA;AAEpB,IAAA,MAAM,SAAS,IAAA,CAAK,OAAA;AAEpB,IAAA,MAAM,QAAQ,IAAA,CAAK,MAAA;AACnB,IAAA,MAAM,SAAS,IAAA,CAAK,OAAA;AAEpB,IAAA,MAAA,CAAO,IAAA,GAAO,CAAC,MAAA,CAAO,EAAA,GAAK,KAAA;AAC3B,IAAA,MAAA,CAAO,IAAA,GAAO,OAAO,IAAA,GAAO,KAAA;AAE5B,IAAA,MAAA,CAAO,IAAA,GAAO,CAAC,MAAA,CAAO,EAAA,GAAK,MAAA;AAC3B,IAAA,MAAA,CAAO,IAAA,GAAO,OAAO,IAAA,GAAO,MAAA;AAAA,EAChC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EA4BgB,cAAc,KAAA,EAC9B;AACI,IAAA,MAAM,QAAQ,IAAA,CAAK,MAAA;AACnB,IAAA,MAAM,SAAS,IAAA,CAAK,OAAA;AACpB,IAAA,MAAM,EAAA,GAAK,CAAC,KAAA,GAAQ,IAAA,CAAK,OAAA,CAAQ,EAAA;AACjC,IAAA,IAAI,EAAA,GAAK,CAAA;AAET,IAAA,IAAI,MAAM,CAAA,IAAK,EAAA,IAAM,KAAA,CAAM,CAAA,IAAK,KAAK,KAAA,EACrC;AACI,MAAA,EAAA,GAAK,CAAC,MAAA,GAAS,IAAA,CAAK,OAAA,CAAQ,EAAA;AAE5B,MAAA,IAAI,MAAM,CAAA,IAAK,EAAA,IAAM,MAAM,CAAA,IAAK,EAAA,GAAK,QAAQ,OAAO,IAAA;AAAA,IACxD;AAEA,IAAA,OAAO,KAAA;AAAA,EACX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWgB,OAAA,CAAQ,UAA0B,KAAA,EAClD;AACI,IAAA,KAAA,CAAM,QAAQ,OAAO,CAAA;AAErB,IAAA,IAAA,CAAK,OAAA,GAAU,IAAA;AACf,IAAA,IAAA,CAAK,cAAA,GAAiB,IAAA;AACtB,IAAA,IAAA,CAAK,OAAA,GAAU,IAAA;AAEf,IAAA,MAAM,cAAA,GAAiB,OAAO,OAAA,KAAY,SAAA,GAAY,UAAU,OAAA,EAAS,OAAA;AAEzE,IAAA,IAAI,cAAA,EACJ;AACI,MAAA,MAAM,oBAAA,GAAuB,OAAO,OAAA,KAAY,SAAA,GAAY,UAAU,OAAA,EAAS,aAAA;AAE/E,MAAA,IAAA,CAAK,QAAA,CAAS,QAAQ,oBAAoB,CAAA;AAAA,IAC9C;AAEA,IAAA,IAAA,CAAK,QAAA,GAAW,IAAA;AAAA,EACpB;AACJ,CAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAjmBa,aAAA,CA4DK,cAAA,GAAsC;AAAA;AAAA,EAEhD,SAAS,OAAA,CAAQ,KAAA;AAAA;AAAA,EAEjB,MAAA,EAAQ,EAAE,CAAA,EAAG,CAAA,EAAG,GAAG,CAAA,EAAE;AAAA;AAAA,EAErB,YAAA,EAAc,EAAE,CAAA,EAAG,CAAA,EAAG,GAAG,CAAA,EAAE;AAAA;AAAA,EAE3B,SAAA,EAAW,EAAE,CAAA,EAAG,CAAA,EAAG,GAAG,CAAA,EAAE;AAAA;AAAA,EAExB,YAAA,EAAc,CAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASd,oBAAA,EAAsB;AAC1B,CAAA;AAhFG,IAAM,YAAA,GAAN;;;;"}
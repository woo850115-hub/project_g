{"version":3,"file":"AbstractBitmapTextPipe.mjs","sources":["../../../src/scene/text-bitmap/AbstractBitmapTextPipe.ts"],"sourcesContent":["import { Cache } from '../../assets/cache/Cache';\nimport { type Renderer } from '../../rendering/renderers/types';\nimport { GCManagedHash } from '../../utils/data/GCManagedHash';\nimport { Graphics } from '../graphics/shared/Graphics';\nimport { CanvasTextMetrics } from '../text/canvas/CanvasTextMetrics';\nimport { type SdfShader } from '../text/sdfShader/SdfShader';\nimport { type GPUData } from '../view/ViewContainer';\nimport { BitmapFontManager } from './BitmapFontManager';\nimport { getBitmapTextLayout } from './utils/getBitmapTextLayout';\n\nimport type { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderable } from '../../rendering/renderers/shared/Renderable';\nimport type { BitmapText } from './BitmapText';\n\n/** @internal */\nexport class BitmapTextGraphics extends Graphics implements GPUData\n{\n    public destroy()\n    {\n        if (this.context.customShader)\n        {\n            this.context.customShader.destroy();\n        }\n\n        super.destroy();\n    }\n}\n\n/** @internal */\nexport abstract class AbstractBitmapTextPipe implements RenderPipe<BitmapText>\n{\n    protected _renderer: Renderer;\n    private readonly _managedBitmapTexts: GCManagedHash<BitmapText>;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n        this._managedBitmapTexts = new GCManagedHash({ renderer, type: 'renderable', priority: -2, name: 'bitmapText' });\n    }\n\n    public validateRenderable(bitmapText: BitmapText): boolean\n    {\n        const graphicsRenderable = this._getGpuBitmapText(bitmapText);\n\n        return this._renderer.renderPipes.graphics.validateRenderable(graphicsRenderable);\n\n        // TODO - need to shift all the verts in the graphicsData to the new anchor\n\n        // update the anchor...\n    }\n\n    public addRenderable(bitmapText: BitmapText, instructionSet: InstructionSet)\n    {\n        const graphicsRenderable = this._getGpuBitmapText(bitmapText);\n\n        // sync..\n        syncWithProxy(bitmapText, graphicsRenderable);\n\n        if (bitmapText._didTextUpdate)\n        {\n            bitmapText._didTextUpdate = false;\n\n            this._updateContext(bitmapText, graphicsRenderable);\n        }\n\n        this._renderer.renderPipes.graphics.addRenderable(graphicsRenderable, instructionSet);\n\n        if (graphicsRenderable.context.customShader)\n        {\n            this._updateDistanceField(bitmapText);\n        }\n    }\n\n    public updateRenderable(bitmapText: BitmapText)\n    {\n        const graphicsRenderable = this._getGpuBitmapText(bitmapText);\n\n        // sync..\n        syncWithProxy(bitmapText, graphicsRenderable);\n\n        this._renderer.renderPipes.graphics.updateRenderable(graphicsRenderable);\n\n        if (graphicsRenderable.context.customShader)\n        {\n            this._updateDistanceField(bitmapText);\n        }\n    }\n\n    protected abstract getSdfShader(): SdfShader | null;\n\n    private _updateContext(bitmapText: BitmapText, proxyGraphics: Graphics)\n    {\n        const { context } = proxyGraphics;\n\n        const bitmapFont = BitmapFontManager.getFont(bitmapText.text, bitmapText._style);\n\n        context.clear();\n\n        if (bitmapFont.distanceField.type !== 'none')\n        {\n            // Only use custom shader for WebGL/WebGPU renderers\n            // Canvas renderer cannot properly handle MSDF distance field math\n            const sdfShader = this.getSdfShader();\n\n            if (sdfShader)\n            {\n                if (!context.customShader)\n                {\n                    context.customShader = sdfShader;\n                }\n            }\n        }\n\n        const chars = CanvasTextMetrics.graphemeSegmenter(bitmapText.text);\n        const style = bitmapText._style;\n\n        let currentY = bitmapFont.baseLineOffset;\n\n        // measure our text...\n        const bitmapTextLayout = getBitmapTextLayout(chars, style, bitmapFont, true);\n\n        const padding = style.padding;\n        const scale = bitmapTextLayout.scale;\n\n        let tx = bitmapTextLayout.width;\n        let ty = bitmapTextLayout.height + bitmapTextLayout.offsetY;\n\n        if (style._stroke)\n        {\n            tx += style._stroke.width / scale;\n            ty += style._stroke.width / scale;\n        }\n\n        context\n            .translate((-bitmapText._anchor._x * tx) - padding, (-bitmapText._anchor._y * ty) - padding)\n            .scale(scale, scale);\n\n        const tint = bitmapFont.applyFillAsTint ? style._fill.color : 0xFFFFFF;\n\n        let fontSize = bitmapFont.fontMetrics.fontSize;\n        let lineHeight = bitmapFont.lineHeight;\n\n        if (style.lineHeight)\n        {\n            fontSize = style.fontSize / scale;\n            lineHeight = style.lineHeight / scale;\n        }\n\n        let linePositionYShift = (lineHeight - fontSize) / 2;\n\n        // if `currentY` is no longer starts from `baseLineOffset`\n        // the `baseLineOffset` below may also need to be removed\n        if (linePositionYShift - bitmapFont.baseLineOffset < 0)\n        {\n            linePositionYShift = 0;\n        }\n\n        for (let i = 0; i < bitmapTextLayout.lines.length; i++)\n        {\n            const line = bitmapTextLayout.lines[i];\n\n            for (let j = 0; j < line.charPositions.length; j++)\n            {\n                const char = line.chars[j];\n                const charData = bitmapFont.chars[char];\n\n                if (charData?.texture)\n                {\n                    const texture = charData.texture;\n\n                    context.texture(\n                        texture,\n                        tint,\n                        Math.round(line.charPositions[j] + charData.xOffset),\n                        Math.round(currentY + charData.yOffset + linePositionYShift),\n                        texture.orig.width,\n                        texture.orig.height,\n                    );\n                }\n            }\n\n            currentY += lineHeight;\n        }\n    }\n\n    private _getGpuBitmapText(bitmapText: BitmapText)\n    {\n        return bitmapText._gpuData[this._renderer.uid] || this.initGpuText(bitmapText);\n    }\n\n    public initGpuText(bitmapText: BitmapText)\n    {\n        // TODO we could keep a bunch of contexts around and reuse one that has the same style!\n        const proxyRenderable = new BitmapTextGraphics();\n\n        bitmapText._gpuData[this._renderer.uid] = proxyRenderable;\n\n        this._updateContext(bitmapText, proxyRenderable);\n\n        this._managedBitmapTexts.add(bitmapText);\n\n        return proxyRenderable;\n    }\n\n    private _updateDistanceField(bitmapText: BitmapText)\n    {\n        const context = this._getGpuBitmapText(bitmapText).context;\n\n        const fontFamily = bitmapText._style.fontFamily as string;\n        const dynamicFont = Cache.get(`${fontFamily as string}-bitmap`);\n\n        // Inject the shader code with the correct value\n        const { a, b, c, d } = bitmapText.groupTransform;\n\n        const dx = Math.sqrt((a * a) + (b * b));\n        const dy = Math.sqrt((c * c) + (d * d));\n        const worldScale = (Math.abs(dx) + Math.abs(dy)) / 2;\n\n        const fontScale = dynamicFont.baseRenderedFontSize / bitmapText._style.fontSize;\n\n        const distance = worldScale * dynamicFont.distanceField.range * (1 / fontScale);\n\n        context.customShader.resources.localUniforms.uniforms.uDistance = distance;\n    }\n\n    public destroy()\n    {\n        this._managedBitmapTexts.destroy();\n        this._renderer = null;\n        (this._managedBitmapTexts as null) = null;\n    }\n}\n\nfunction syncWithProxy(container: Renderable, proxy: Renderable)\n{\n    proxy.groupTransform = container.groupTransform;\n    proxy.groupColorAlpha = container.groupColorAlpha;\n    proxy.groupColor = container.groupColor;\n    proxy.groupBlendMode = container.groupBlendMode;\n    proxy.globalDisplayStatus = container.globalDisplayStatus;\n    proxy.groupTransform = container.groupTransform;\n    proxy.localDisplayStatus = container.localDisplayStatus;\n    proxy.groupAlpha = container.groupAlpha;\n    proxy._roundPixels = container._roundPixels;\n}\n"],"names":[],"mappings":"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"}
{"version":3,"file":"HTMLTextPipe.mjs","sources":["../../../src/scene/text-html/HTMLTextPipe.ts"],"sourcesContent":["import { ExtensionType } from '../../extensions/Extensions';\nimport { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport { GCManagedHash } from '../../utils/data/GCManagedHash';\nimport { updateTextBounds } from '../text/utils/updateTextBounds';\nimport { BatchableHTMLText } from './BatchableHTMLText';\n\nimport type { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../../rendering/renderers/types';\nimport type { HTMLText } from './HTMLText';\n\n/**\n * The HTMLTextPipe class is responsible for rendering HTML text.\n * @internal\n */\nexport class HTMLTextPipe implements RenderPipe<HTMLText>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'htmlText',\n    } as const;\n\n    private _renderer: Renderer;\n    private readonly _managedTexts: GCManagedHash<HTMLText>;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n        renderer.runners.resolutionChange.add(this);\n        this._managedTexts = new GCManagedHash({\n            renderer,\n            type: 'renderable',\n            onUnload: this.onTextUnload.bind(this),\n            name: 'htmlText'\n        });\n    }\n\n    protected resolutionChange()\n    {\n        for (const key in this._managedTexts.items)\n        {\n            const text = this._managedTexts.items[key];\n\n            if (text?._autoResolution)\n            {\n                text.onViewUpdate();\n            }\n        }\n    }\n\n    public validateRenderable(htmlText: HTMLText): boolean\n    {\n        const gpuText = this._getGpuText(htmlText);\n\n        const newKey = htmlText.styleKey;\n\n        if (gpuText.currentKey !== newKey)\n        {\n            return true;\n        }\n\n        return false;\n    }\n\n    public addRenderable(htmlText: HTMLText, instructionSet: InstructionSet)\n    {\n        const batchableHTMLText = this._getGpuText(htmlText);\n\n        if (htmlText._didTextUpdate)\n        {\n            const resolution = htmlText._autoResolution ? this._renderer.resolution : htmlText.resolution;\n\n            if (batchableHTMLText.currentKey !== htmlText.styleKey || htmlText.resolution !== resolution)\n            {\n                // If the text has changed, we need to update the GPU text\n                this._updateGpuText(htmlText).catch((e) =>\n                {\n                    console.error(e);\n                });\n            }\n\n            htmlText._didTextUpdate = false;\n\n            updateTextBounds(batchableHTMLText, htmlText);\n        }\n\n        this._renderer.renderPipes.batch.addToBatch(batchableHTMLText, instructionSet);\n    }\n\n    public updateRenderable(htmlText: HTMLText)\n    {\n        const batchableHTMLText = this._getGpuText(htmlText);\n\n        batchableHTMLText._batcher.updateElement(batchableHTMLText);\n    }\n\n    private async _updateGpuText(htmlText: HTMLText)\n    {\n        htmlText._didTextUpdate = false;\n        const batchableHTMLText = this._getGpuText(htmlText);\n\n        if (batchableHTMLText.generatingTexture) return;\n\n        // We need to preserve the current texture and don't release it until the new texture is generated.\n        // It's necessary to ensure that the texture won't be captured by another field and overwritten with their\n        // content, while our texture is still in progress.\n        const oldTexturePromise = batchableHTMLText.texturePromise;\n\n        batchableHTMLText.texturePromise = null;\n\n        batchableHTMLText.generatingTexture = true;\n\n        htmlText._resolution = htmlText._autoResolution ? this._renderer.resolution : htmlText.resolution;\n\n        let texturePromise = this._renderer.htmlText.getTexturePromise(htmlText);\n\n        if (oldTexturePromise)\n        {\n            // Release old texture after new one is generated.\n            texturePromise = texturePromise.finally(() =>\n            {\n                this._renderer.htmlText.decreaseReferenceCount(batchableHTMLText.currentKey);\n                this._renderer.htmlText.returnTexturePromise(oldTexturePromise);\n            });\n        }\n\n        batchableHTMLText.texturePromise = texturePromise;\n        batchableHTMLText.currentKey = htmlText.styleKey;\n\n        batchableHTMLText.texture = await texturePromise;\n\n        // need a rerender...\n        const renderGroup = htmlText.renderGroup || htmlText.parentRenderGroup;\n\n        if (renderGroup)\n        {\n            // need a rebuild of the render group\n            renderGroup.structureDidChange = true;\n        }\n\n        batchableHTMLText.generatingTexture = false;\n\n        updateTextBounds(batchableHTMLText, htmlText);\n    }\n\n    private _getGpuText(htmlText: HTMLText)\n    {\n        return htmlText._gpuData[this._renderer.uid] || this.initGpuText(htmlText);\n    }\n\n    public initGpuText(htmlText: HTMLText)\n    {\n        const batchableHTMLText = new BatchableHTMLText();\n\n        batchableHTMLText.renderable = htmlText;\n        batchableHTMLText.transform = htmlText.groupTransform;\n        batchableHTMLText.texture = Texture.EMPTY;\n        batchableHTMLText.bounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 };\n        batchableHTMLText.roundPixels = (this._renderer._roundPixels | htmlText._roundPixels) as 0 | 1;\n\n        htmlText._resolution = htmlText._autoResolution ? this._renderer.resolution : htmlText.resolution;\n        htmlText._gpuData[this._renderer.uid] = batchableHTMLText;\n\n        this._managedTexts.add(htmlText);\n\n        return batchableHTMLText;\n    }\n\n    protected onTextUnload(text: HTMLText)\n    {\n        const gpuData = text._gpuData[this._renderer.uid];\n\n        if (!gpuData) return;\n\n        const { htmlText } = this._renderer;\n\n        htmlText.getReferenceCount(gpuData.currentKey) === null\n            ? htmlText.returnTexturePromise(gpuData.texturePromise)\n            : htmlText.decreaseReferenceCount(gpuData.currentKey);\n    }\n\n    public destroy()\n    {\n        this._managedTexts.destroy();\n        this._renderer = null;\n    }\n}\n\n"],"names":[],"mappings":"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"}
{"version":3,"file":"localUniformMSDFBit.mjs","sources":["../../../../../src/scene/text/sdfShader/shader-bits/localUniformMSDFBit.ts"],"sourcesContent":["// TODO eventually we should not use this bit, but instead use the localUniformBit\n// have the MSDF bit be merged in with the localUniformBit\n\n/** @internal */\nexport const localUniformMSDFBit = {\n    name: 'local-uniform-msdf-bit',\n    vertex: {\n        header: /* wgsl */`\n            struct LocalUniforms {\n                uColor:vec4<f32>,\n                uTransformMatrix:mat3x3<f32>,\n                uDistance: f32,\n                uRound:f32,\n            }\n\n            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;\n        `,\n        main: /* wgsl */`\n            vColor *= localUniforms.uColor;\n            modelMatrix *= localUniforms.uTransformMatrix;\n        `,\n        end: /* wgsl */`\n            if(localUniforms.uRound == 1)\n            {\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n            }\n        `\n    },\n    fragment: {\n        header: /* wgsl */`\n            struct LocalUniforms {\n                uColor:vec4<f32>,\n                uTransformMatrix:mat3x3<f32>,\n                uDistance: f32\n            }\n\n            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;\n         `,\n        main: /* wgsl */`\n            outColor = vec4<f32>(calculateMSDFAlpha(outColor, vColor, localUniforms.uDistance));\n        `\n\n    }\n};\n\n/** @internal */\nexport const localUniformMSDFBitGl = {\n    name: 'local-uniform-msdf-bit',\n    vertex: {\n        header: /* glsl */`\n            uniform mat3 uTransformMatrix;\n            uniform vec4 uColor;\n            uniform float uRound;\n        `,\n        main: /* glsl */`\n            vColor *= uColor;\n            modelMatrix *= uTransformMatrix;\n        `,\n        end: /* glsl */`\n            if(uRound == 1.)\n            {\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n            }\n        `\n    },\n    fragment: {\n        header: /* glsl */`\n            uniform float uDistance;\n         `,\n        main: /* glsl */`\n            outColor = vec4(calculateMSDFAlpha(outColor, vColor, uDistance));\n        `\n\n    }\n};\n"],"names":[],"mappings":";AAIO,MAAM,mBAAA,GAAsB;AAAA,EAC/B,IAAA,EAAM,wBAAA;AAAA,EACN,MAAA,EAAQ;AAAA,IACJ,MAAA;AAAA;AAAA,MAAkB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA,QAAA;AAAA,KAAA;AAAA,IAUlB,IAAA;AAAA;AAAA,MAAgB;AAAA;AAAA;AAAA,QAAA;AAAA,KAAA;AAAA,IAIhB,GAAA;AAAA;AAAA,MAAe;AAAA;AAAA;AAAA;AAAA;AAAA,QAAA;AAAA;AAAA,GAMnB;AAAA,EACA,QAAA,EAAU;AAAA,IACN,MAAA;AAAA;AAAA,MAAkB;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA,SAAA;AAAA,KAAA;AAAA,IASlB,IAAA;AAAA;AAAA,MAAgB;AAAA;AAAA,QAAA;AAAA;AAAA;AAKxB;AAGO,MAAM,qBAAA,GAAwB;AAAA,EACjC,IAAA,EAAM,wBAAA;AAAA,EACN,MAAA,EAAQ;AAAA,IACJ,MAAA;AAAA;AAAA,MAAkB;AAAA;AAAA;AAAA;AAAA,QAAA;AAAA,KAAA;AAAA,IAKlB,IAAA;AAAA;AAAA,MAAgB;AAAA;AAAA;AAAA,QAAA;AAAA,KAAA;AAAA,IAIhB,GAAA;AAAA;AAAA,MAAe;AAAA;AAAA;AAAA;AAAA;AAAA,QAAA;AAAA;AAAA,GAMnB;AAAA,EACA,QAAA,EAAU;AAAA,IACN,MAAA;AAAA;AAAA,MAAkB;AAAA;AAAA,SAAA;AAAA,KAAA;AAAA,IAGlB,IAAA;AAAA;AAAA,MAAgB;AAAA;AAAA,QAAA;AAAA;AAAA;AAKxB;;;;"}
{"version":3,"file":"getPo2TextureFromSource.js","sources":["../../../../src/scene/text/utils/getPo2TextureFromSource.ts"],"sourcesContent":["import { type ImageLike } from '../../../environment/ImageLike';\nimport { TexturePool } from '../../../rendering/renderers/shared/texture/TexturePool';\nimport { Bounds } from '../../container/bounds/Bounds';\n\nimport type { ICanvas } from '../../../environment/canvas/ICanvas';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\n\nconst tempBounds = new Bounds();\n\n/**\n * Takes an image and creates a texture from it, using a power of 2 texture from the texture pool.\n * Remember to return the texture when you don't need it any more!\n * @param image - The image to create a texture from\n * @param width - the frame width of the texture\n * @param height - the frame height of the texture\n * @param resolution - The resolution of the texture\n * @returns - The texture\n * @internal\n */\nexport function getPo2TextureFromSource(\n    image: ImageLike | HTMLCanvasElement | ICanvas,\n    width: number,\n    height: number,\n    resolution: number\n): Texture\n{\n    const bounds = tempBounds;\n\n    bounds.minX = 0;\n    bounds.minY = 0;\n\n    bounds.maxX = (image.width / resolution) | 0;\n    bounds.maxY = (image.height / resolution) | 0;\n\n    const texture = TexturePool.getOptimalTexture(\n        bounds.width,\n        bounds.height,\n        resolution,\n        false\n    );\n\n    texture.source.uploadMethodId = 'image';\n    texture.source.resource = image;\n    texture.source.alphaMode = 'premultiply-alpha-on-upload';\n\n    texture.frame.width = width / resolution;\n    texture.frame.height = height / resolution;\n\n    // We want to update the resource on the GPU,\n    // but we do not want to resize the texture.\n    // calling `texture.source.update` will fit the resource to the texture\n    // causing a resize of the texture on the GPU.\n    // which is not what we want!\n    texture.source.emit('update', texture.source);\n\n    texture.updateUvs();\n\n    return texture;\n}\n"],"names":["Bounds","TexturePool"],"mappings":";;;;;;AAOA,MAAM,UAAA,GAAa,IAAIA,aAAA,EAAO;AAYvB,SAAS,uBAAA,CACZ,KAAA,EACA,KAAA,EACA,MAAA,EACA,UAAA,EAEJ;AACI,EAAA,MAAM,MAAA,GAAS,UAAA;AAEf,EAAA,MAAA,CAAO,IAAA,GAAO,CAAA;AACd,EAAA,MAAA,CAAO,IAAA,GAAO,CAAA;AAEd,EAAA,MAAA,CAAO,IAAA,GAAQ,KAAA,CAAM,KAAA,GAAQ,UAAA,GAAc,CAAA;AAC3C,EAAA,MAAA,CAAO,IAAA,GAAQ,KAAA,CAAM,MAAA,GAAS,UAAA,GAAc,CAAA;AAE5C,EAAA,MAAM,UAAUC,uBAAA,CAAY,iBAAA;AAAA,IACxB,MAAA,CAAO,KAAA;AAAA,IACP,MAAA,CAAO,MAAA;AAAA,IACP,UAAA;AAAA,IACA;AAAA,GACJ;AAEA,EAAA,OAAA,CAAQ,OAAO,cAAA,GAAiB,OAAA;AAChC,EAAA,OAAA,CAAQ,OAAO,QAAA,GAAW,KAAA;AAC1B,EAAA,OAAA,CAAQ,OAAO,SAAA,GAAY,6BAAA;AAE3B,EAAA,OAAA,CAAQ,KAAA,CAAM,QAAQ,KAAA,GAAQ,UAAA;AAC9B,EAAA,OAAA,CAAQ,KAAA,CAAM,SAAS,MAAA,GAAS,UAAA;AAOhC,EAAA,OAAA,CAAQ,MAAA,CAAO,IAAA,CAAK,QAAA,EAAU,OAAA,CAAQ,MAAM,CAAA;AAE5C,EAAA,OAAA,CAAQ,SAAA,EAAU;AAElB,EAAA,OAAO,OAAA;AACX;;;;"}
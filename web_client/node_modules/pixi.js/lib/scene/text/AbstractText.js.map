{"version":3,"file":"AbstractText.js","sources":["../../../src/scene/text/AbstractText.ts"],"sourcesContent":["import { ObservablePoint } from '../../maths/point/ObservablePoint';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation';\nimport { ViewContainer, type ViewContainerOptions } from '../view/ViewContainer';\n\nimport type { Size } from '../../maths/misc/Size';\nimport type { PointData } from '../../maths/point/PointData';\nimport type { View } from '../../rendering/renderers/shared/view/View';\nimport type { Optional } from '../container/container-mixins/measureMixin';\nimport type { DestroyOptions } from '../container/destroyTypes';\nimport type { HTMLTextStyle, HTMLTextStyleOptions } from '../text-html/HTMLTextStyle';\nimport type { TextStyle, TextStyleOptions } from './TextStyle';\n\n/**\n * A string or number that can be used as text.\n * @example\n * ```ts\n * const text: TextString = 'Hello Pixi!';\n * const text2: TextString = 12345;\n * const text3: TextString = { toString: () => 'Hello Pixi!' };\n * ```\n * @category text\n * @standard\n */\nexport type TextString = string | number | { toString: () => string };\n/**\n * A union of all text styles, including HTML, Bitmap and Canvas text styles.\n * This is used to allow for any text style to be passed to a text object.\n * @example\n * ```ts\n * import { TextStyle, HTMLTextStyle } from 'pixi.js';\n * const style: AnyTextStyle = new TextStyle({ fontSize: 24 });\n * const htmlStyle: AnyTextStyle = new HTMLTextStyle({ fontSize: '24px' });\n * ```\n * @category text\n * @standard\n * @see TextStyle\n * @see HTMLTextStyle\n */\nexport type AnyTextStyle = TextStyle | HTMLTextStyle;\n/**\n * A union of all text style options, including HTML, Bitmap and Canvas text style options.\n * This is used to allow for any text style options to be passed to a text object.\n * @example\n * ```ts\n * import { TextStyleOptions, HTMLTextStyleOptions } from 'pixi.js';\n * const styleOptions: AnyTextStyleOptions = { fontSize: 24 } as TextStyleOptions;\n * const htmlStyleOptions: AnyTextStyleOptions = { fontSize: '24px' } as HTMLTextStyleOptions;\n * ```\n * @category text\n * @standard\n * @see TextStyleOptions\n * @see HTMLTextStyleOptions\n */\nexport type AnyTextStyleOptions = TextStyleOptions | HTMLTextStyleOptions;\n\n/**\n * Options for creating text objects in PixiJS. This interface defines the common properties\n * used across different text rendering implementations (Canvas, HTML, and Bitmap).\n * @example\n * ```ts\n * // Create basic text with minimal options\n * const basicText = new Text({\n *     text: 'Hello Pixi!',\n *     style: {\n *         fontSize: 24,\n *         fill: 0xff1010\n *     }\n * });\n *\n * // Create text with advanced styling\n * const styledText = new Text({\n *     text: 'Styled Text',\n *     style: {\n *         fontFamily: 'Arial',\n *         fontSize: 32,\n *         fill: new FillGradient({\n *             end: { x: 1, y: 1 },\n *             stops: [\n *                 { color: 0xff0000, offset: 0 }, // Red at start\n *                 { color: 0x0000ff, offset: 1 }, // Blue at end\n *             ]\n *         }),\n *         stroke: { color: '#4a1850', width: 5 },\n *         dropShadow: {\n *             color: '#000000',\n *             blur: 4,\n *             distance: 6\n *         },\n *         align: 'center'\n *     },\n *     anchor: 0.5,\n *     resolution: window.devicePixelRatio\n * });\n *\n * // Create multiline text with word wrap\n * const wrappedText = new Text({\n *     text: 'This is a long piece of text that will wrap onto multiple lines',\n *     style: {\n *         fontSize: 20,\n *         wordWrap: true,\n *         wordWrapWidth: 200,\n *         lineHeight: 30\n *     },\n *     resolution: 2,\n *     roundPixels: true\n * });\n * ```\n * @category text\n * @standard\n * @noInheritDoc\n */\nexport interface TextOptions<\n    TEXT_STYLE extends TextStyle = TextStyle,\n    TEXT_STYLE_OPTIONS extends TextStyleOptions = TextStyleOptions,\n> extends PixiMixins.TextOptions, ViewContainerOptions\n{\n    /**\n     * The anchor point of the text that controls the origin point for positioning and rotation.\n     * Can be a number (same value for x/y) or a PointData object.\n     * - (0,0) is top-left\n     * - (0.5,0.5) is center\n     * - (1,1) is bottom-right\n     * ```ts\n     * // Set anchor to center\n     * const text = new Text({\n     *     text: 'Hello Pixi!',\n     *     anchor: 0.5 // Same as { x: 0.5, y: 0.5 }\n     * });\n     * // Set anchor to top-left\n     * const text2 = new Text({\n     *     text: 'Hello Pixi!',\n     *     anchor: { x: 0, y: 0 } // Top-left corner\n     * });\n     * // Set anchor to bottom-right\n     * const text3 = new Text({\n     *     text: 'Hello Pixi!',\n     *     anchor: { x: 1, y: 1 } // Bottom-right corner\n     * });\n     * ```\n     * @default { x: 0, y: 0 }\n     */\n    anchor?: PointData | number;\n    /**\n     * The text content to display. Use '\\n' for line breaks.\n     * Accepts strings, numbers, or objects with toString() method.\n     * @example\n     * ```ts\n     * const text = new Text({\n     *     text: 'Hello Pixi!',\n     * });\n     * const multilineText = new Text({\n     *     text: 'Line 1\\nLine 2\\nLine 3',\n     * });\n     * const numberText = new Text({\n     *     text: 12345, // Will be converted to '12345'\n     * });\n     * const objectText = new Text({\n     *     text: { toString: () => 'Object Text' }, // Custom toString\n     * });\n     * ```\n     * @default ''\n     */\n    text?: TextString;\n    /**\n     * The resolution/device pixel ratio for rendering.\n     * Higher values result in sharper text at the cost of performance.\n     * Set to null for auto-resolution based on device.\n     * @example\n     * ```ts\n     * const text = new Text({\n     *     text: 'Hello Pixi!',\n     *     resolution: 2 // High DPI for sharper text\n     * });\n     * const autoResText = new Text({\n     *     text: 'Auto Resolution',\n     *     resolution: null // Use device's pixel ratio\n     * });\n     * ```\n     * @default null\n     */\n    resolution?: number;\n    /**\n     * The style configuration for the text.\n     * Can be a TextStyle instance or a configuration object.\n     * Supports canvas text styles, HTML text styles, and bitmap text styles.\n     * @example\n     * ```ts\n     * const text = new Text({\n     *     text: 'Styled Text',\n     *     style: {\n     *         fontSize: 24,\n     *         fill: 0xff1010, // Red color\n     *         fontFamily: 'Arial',\n     *         align: 'center', // Center alignment\n     *         stroke: { color: '#4a1850', width: 5 }, // Purple stroke\n     *         dropShadow: {\n     *             color: '#000000', // Black shadow\n     *             blur: 4, // Shadow blur\n     *             distance: 6 // Shadow distance\n     *         }\n     *     }\n     * });\n     * const htmlText = new HTMLText({\n     *     text: 'HTML Styled Text',\n     *     style: {\n     *         fontSize: '20px',\n     *         fill: 'blue',\n     *         fontFamily: 'Verdana',\n     *     }\n     * });\n     * const bitmapText = new BitmapText({\n     *     text: 'Bitmap Styled Text',\n     *     style: {\n     *         fontName: 'Arial',\n     *         fontSize: 32,\n     *     }\n     * })\n     */\n    style?: TEXT_STYLE | TEXT_STYLE_OPTIONS;\n    /**\n     * Whether to round the x/y position to whole pixels.\n     * Enabling can prevent anti-aliasing of text edges but may cause slight position shifting.\n     * @example\n     * ```ts\n     * const text = new Text({\n     *     text: 'Rounded Text',\n     *     roundPixels: true // Rounds position to whole pixels\n     * });\n     * @default false\n     */\n    roundPixels?: boolean;\n}\n\n/**\n * An abstract Text class, used by all text type in Pixi. This includes Canvas, HTML, and Bitmap Text.\n * @see Text\n * @see BitmapText\n * @see HTMLText\n * @category text\n * @advanced\n */\nexport abstract class AbstractText<\n    TEXT_STYLE extends TextStyle = TextStyle,\n    TEXT_STYLE_OPTIONS extends TextStyleOptions = TextStyleOptions,\n    TEXT_OPTIONS extends TextOptions<TEXT_STYLE, TEXT_STYLE_OPTIONS> = TextOptions<TEXT_STYLE, TEXT_STYLE_OPTIONS>,\n    GPU_DATA extends { destroy: () => void } = any\n> extends ViewContainer<GPU_DATA> implements View\n{\n    /** @internal */\n    public batched = true;\n    /** @internal */\n    public _anchor: ObservablePoint;\n\n    /** @internal */\n    public _resolution: number = null;\n    /** @internal */\n    public _autoResolution: boolean = true;\n\n    /** @internal */\n    public _style: TEXT_STYLE;\n    /** @internal */\n    public _didTextUpdate = true;\n\n    protected _text: string;\n    private readonly _styleClass: new (options: TEXT_STYLE_OPTIONS) => TEXT_STYLE;\n\n    constructor(\n        options: TEXT_OPTIONS,\n        styleClass: new (options: TEXT_STYLE_OPTIONS) => TEXT_STYLE\n    )\n    {\n        const { text, resolution, style, anchor, width, height, roundPixels, ...rest } = options;\n\n        super({\n            ...rest\n        });\n\n        this._styleClass = styleClass;\n\n        this.text = text ?? '';\n\n        this.style = style;\n\n        this.resolution = resolution ?? null;\n\n        this.allowChildren = false;\n\n        this._anchor = new ObservablePoint(\n            {\n                _onUpdate: () =>\n                {\n                    this.onViewUpdate();\n                },\n            },\n        );\n\n        if (anchor) this.anchor = anchor;\n        this.roundPixels = roundPixels ?? false;\n\n        // needs to be set after the container has initiated\n        if (width !== undefined) this.width = width;\n        if (height !== undefined) this.height = height;\n    }\n\n    /**\n     * The anchor point of the text that controls the origin point for positioning and rotation.\n     * Can be a number (same value for x/y) or a PointData object.\n     * - (0,0) is top-left\n     * - (0.5,0.5) is center\n     * - (1,1) is bottom-right\n     * ```ts\n     * // Set anchor to center\n     * const text = new Text({\n     *     text: 'Hello Pixi!',\n     *     anchor: 0.5 // Same as { x: 0.5, y: 0.5 }\n     * });\n     * // Set anchor to top-left\n     * const text2 = new Text({\n     *     text: 'Hello Pixi!',\n     *     anchor: { x: 0, y: 0 } // Top-left corner\n     * });\n     * // Set anchor to bottom-right\n     * const text3 = new Text({\n     *     text: 'Hello Pixi!',\n     *     anchor: { x: 1, y: 1 } // Bottom-right corner\n     * });\n     * ```\n     * @default { x: 0, y: 0 }\n     */\n    get anchor(): ObservablePoint\n    {\n        return this._anchor;\n    }\n\n    set anchor(value: PointData | number)\n    {\n        typeof value === 'number' ? this._anchor.set(value) : this._anchor.copyFrom(value);\n    }\n\n    /**\n     * The text content to display. Use '\\n' for line breaks.\n     * Accepts strings, numbers, or objects with toString() method.\n     * @example\n     * ```ts\n     * const text = new Text({\n     *     text: 'Hello Pixi!',\n     * });\n     * const multilineText = new Text({\n     *     text: 'Line 1\\nLine 2\\nLine 3',\n     * });\n     * const numberText = new Text({\n     *     text: 12345, // Will be converted to '12345'\n     * });\n     * const objectText = new Text({\n     *     text: { toString: () => 'Object Text' }, // Custom toString\n     * });\n     *\n     * // Update text dynamically\n     * text.text = 'Updated Text'; // Re-renders with new text\n     * text.text = 67890; // Updates to '67890'\n     * text.text = { toString: () => 'Dynamic Text' }; // Uses custom toString method\n     * // Clear text\n     * text.text = ''; // Clears the text\n     * ```\n     * @default ''\n     */\n    set text(value: TextString)\n    {\n        // check its a string\n        value = value.toString();\n\n        if (this._text === value) return;\n\n        this._text = value as string;\n        this.onViewUpdate();\n    }\n\n    get text(): string\n    {\n        return this._text;\n    }\n\n    /**\n     * The resolution/device pixel ratio for rendering.\n     * Higher values result in sharper text at the cost of performance.\n     * Set to null for auto-resolution based on device.\n     * @example\n     * ```ts\n     * const text = new Text({\n     *     text: 'Hello Pixi!',\n     *     resolution: 2 // High DPI for sharper text\n     * });\n     * const autoResText = new Text({\n     *     text: 'Auto Resolution',\n     *     resolution: null // Use device's pixel ratio\n     * });\n     * ```\n     * @default null\n     */\n    set resolution(value: number)\n    {\n        this._autoResolution = value === null;\n        this._resolution = value;\n        this.onViewUpdate();\n    }\n\n    get resolution(): number\n    {\n        return this._resolution;\n    }\n\n    get style(): TEXT_STYLE\n    {\n        return this._style;\n    }\n\n    /**\n     * The style configuration for the text.\n     * Can be a TextStyle instance or a configuration object.\n     * Supports canvas text styles, HTML text styles, and bitmap text styles.\n     * @example\n     * ```ts\n     * const text = new Text({\n     *     text: 'Styled Text',\n     *     style: {\n     *         fontSize: 24,\n     *         fill: 0xff1010, // Red color\n     *         fontFamily: 'Arial',\n     *         align: 'center', // Center alignment\n     *         stroke: { color: '#4a1850', width: 5 }, // Purple stroke\n     *         dropShadow: {\n     *             color: '#000000', // Black shadow\n     *             blur: 4, // Shadow blur\n     *             distance: 6 // Shadow distance\n     *         }\n     *     }\n     * });\n     * const htmlText = new HTMLText({\n     *     text: 'HTML Styled Text',\n     *     style: {\n     *         fontSize: '20px',\n     *         fill: 'blue',\n     *         fontFamily: 'Verdana',\n     *     }\n     * });\n     * const bitmapText = new BitmapText({\n     *     text: 'Bitmap Styled Text',\n     *     style: {\n     *         fontName: 'Arial',\n     *         fontSize: 32,\n     *     }\n     * })\n     *\n     * // Update style dynamically\n     * text.style = {\n     *     fontSize: 30, // Change font size\n     *     fill: 0x00ff00, // Change color to green\n     *     align: 'right', // Change alignment to right\n     *     stroke: { color: '#000000', width: 2 }, // Add black stroke\n     * }\n     */\n    set style(style: TEXT_STYLE | Partial<TEXT_STYLE> | TEXT_STYLE_OPTIONS)\n    {\n        style ||= {};\n\n        this._style?.off('update', this.onViewUpdate, this);\n\n        if (style instanceof this._styleClass)\n        {\n            this._style = style as TEXT_STYLE;\n        }\n        else\n        {\n            this._style = new this._styleClass(style as TEXT_STYLE_OPTIONS);\n        }\n\n        this._style.on('update', this.onViewUpdate, this);\n        this.onViewUpdate();\n    }\n\n    /**\n     * The width of the sprite, setting this will actually modify the scale to achieve the value set.\n     * @example\n     * ```ts\n     * // Set width directly\n     * texture.width = 200;\n     * console.log(texture.scale.x); // Scale adjusted to match width\n     *\n     * // For better performance when setting both width and height\n     * texture.setSize(300, 400); // Avoids recalculating bounds twice\n     * ```\n     */\n    override get width(): number\n    {\n        return Math.abs(this.scale.x) * this.bounds.width;\n    }\n\n    override set width(value: number)\n    {\n        this._setWidth(value, this.bounds.width);\n    }\n\n    /**\n     * The height of the sprite, setting this will actually modify the scale to achieve the value set.\n     * @example\n     * ```ts\n     * // Set height directly\n     * texture.height = 200;\n     * console.log(texture.scale.y); // Scale adjusted to match height\n     *\n     * // For better performance when setting both width and height\n     * texture.setSize(300, 400); // Avoids recalculating bounds twice\n     * ```\n     */\n    override get height(): number\n    {\n        return Math.abs(this.scale.y) * this.bounds.height;\n    }\n\n    override set height(value: number)\n    {\n        this._setHeight(value, this.bounds.height);\n    }\n\n    /**\n     * Retrieves the size of the Text as a [Size]{@link Size} object based on the texture dimensions and scale.\n     * This is faster than getting width and height separately as it only calculates the bounds once.\n     * @example\n     * ```ts\n     * // Basic size retrieval\n     * const text = new Text({\n     *     text: 'Hello Pixi!',\n     *     style: { fontSize: 24 }\n     * });\n     * const size = text.getSize();\n     * console.log(`Size: ${size.width}x${size.height}`);\n     *\n     * // Reuse existing size object\n     * const reuseSize = { width: 0, height: 0 };\n     * text.getSize(reuseSize);\n     * ```\n     * @param out - Optional object to store the size in, to avoid allocating a new object\n     * @returns The size of the Sprite\n     * @see {@link Text#width} For getting just the width\n     * @see {@link Text#height} For getting just the height\n     * @see {@link Text#setSize} For setting both width and height\n     */\n    public override getSize(out?: Size): Size\n    {\n        out ||= {} as Size;\n        out.width = Math.abs(this.scale.x) * this.bounds.width;\n        out.height = Math.abs(this.scale.y) * this.bounds.height;\n\n        return out;\n    }\n\n    /**\n     * Sets the size of the Text to the specified width and height.\n     * This is faster than setting width and height separately as it only recalculates bounds once.\n     * @example\n     * ```ts\n     * // Basic size setting\n     * const text = new Text({\n     *    text: 'Hello Pixi!',\n     *    style: { fontSize: 24 }\n     * });\n     * text.setSize(100, 200); // Width: 100, Height: 200\n     *\n     * // Set uniform size\n     * text.setSize(100); // Sets both width and height to 100\n     *\n     * // Set size with object\n     * text.setSize({\n     *     width: 200,\n     *     height: 300\n     * });\n     * ```\n     * @param value - This can be either a number or a {@link Size} object\n     * @param height - The height to set. Defaults to the value of `width` if not provided\n     * @see {@link Text#width} For setting width only\n     * @see {@link Text#height} For setting height only\n     */\n    public override setSize(value: number | Optional<Size, 'height'>, height?: number)\n    {\n        if (typeof value === 'object')\n        {\n            height = value.height ?? value.width;\n            value = value.width;\n        }\n        else\n        {\n            height ??= value;\n        }\n\n        value !== undefined && this._setWidth(value, this.bounds.width);\n        height !== undefined && this._setHeight(height, this.bounds.height);\n    }\n\n    /**\n     * Checks if the object contains the given point in local coordinates.\n     * Uses the text's bounds for hit testing.\n     * @example\n     * ```ts\n     * // Basic point check\n     * const localPoint = { x: 50, y: 25 };\n     * const contains = text.containsPoint(localPoint);\n     * console.log('Point is inside:', contains);\n     * ```\n     * @param point - The point to check in local coordinates\n     * @returns True if the point is within the text's bounds\n     * @see {@link Container#toLocal} For converting global coordinates to local\n     */\n    public override containsPoint(point: PointData)\n    {\n        const width = this.bounds.width;\n        const height = this.bounds.height;\n\n        const x1 = -width * this.anchor.x;\n        let y1 = 0;\n\n        if (point.x >= x1 && point.x <= x1 + width)\n        {\n            y1 = -height * this.anchor.y;\n\n            if (point.y >= y1 && point.y <= y1 + height) return true;\n        }\n\n        return false;\n    }\n\n    /** @internal */\n    public override onViewUpdate()\n    {\n        if (!this.didViewUpdate) this._didTextUpdate = true;\n        super.onViewUpdate();\n    }\n\n    /**\n     * Destroys this text renderable and optionally its style texture.\n     * @param options - Options parameter. A boolean will act as if all options\n     *  have been set to that value\n     * @example\n     * // Destroys the text and its style\n     * text.destroy({ style: true, texture: true, textureSource: true });\n     * text.destroy(true);\n     * text.destroy() // Destroys the text, but not its style\n     */\n    public override destroy(options: DestroyOptions = false): void\n    {\n        super.destroy(options);\n\n        (this as any).owner = null;\n        this._bounds = null;\n        this._anchor = null;\n\n        if (typeof options === 'boolean' ? options : options?.style)\n        {\n            this._style.destroy(options);\n        }\n\n        this._style = null;\n        this._text = null;\n    }\n\n    /**\n     * Returns a unique key for this instance.\n     * This key is used for caching.\n     * @returns {string} Unique key for the instance\n     */\n    public get styleKey(): string\n    {\n        return `${this._text}:${this._style.styleKey}:${this._resolution}`;\n    }\n}\n\n/**\n * Helper function to ensure consistent handling of text options across different text classes.\n * This function handles both the new options object format and the deprecated parameter format.\n * @example\n * // New recommended way:\n * const options = ensureTextOptions([{\n *     text: \"Hello\",\n *     style: { fontSize: 20 }\n * }], \"Text\");\n *\n * // Deprecated way (will show warning in debug):\n * const options = ensureTextOptions([\"Hello\", { fontSize: 20 }], \"Text\");\n * @param args - Arguments passed to text constructor\n * @param name - Name of the text class (used in deprecation warning)\n * @returns Normalized text options object\n * @template TEXT_OPTIONS - The type of the text options\n * @internal\n */\nexport function ensureTextOptions<\n    TEXT_OPTIONS extends TextOptions\n>(\n    args: any[],\n    name: string\n): TEXT_OPTIONS\n{\n    let options = (args[0] ?? {}) as TEXT_OPTIONS;\n\n    // @deprecated\n    if (typeof options === 'string' || args[1])\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, `use new ${name}({ text: \"hi!\", style }) instead`);\n        // #endif\n\n        options = {\n            text: options,\n            style: args[1],\n        } as unknown as TEXT_OPTIONS;\n    }\n\n    return options;\n}\n"],"names":["ViewContainer","ObservablePoint","deprecation","v8_0_0"],"mappings":"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"}
{"version":3,"file":"generateUniformsSyncPolyfill.mjs","sources":["../../../src/unsafe-eval/uniforms/generateUniformsSyncPolyfill.ts"],"sourcesContent":["import { uniformParsers } from '../../rendering/renderers/shared/shader/utils/uniformParsers';\nimport { uniformArrayParserFunctions, uniformParserFunctions, uniformSingleParserFunctions } from './uniformSyncFunctions';\n\nimport type { GlUniformData } from '../../rendering/renderers/gl/shader/GlProgram';\nimport type { WebGLRenderer } from '../../rendering/renderers/gl/WebGLRenderer';\nimport type { UniformsSyncCallback } from '../../rendering/renderers/shared/shader/types';\nimport type { UniformGroup } from '../../rendering/renderers/shared/shader/UniformGroup';\nimport type { UniformUploadFunction } from './uniformSyncFunctions';\n\n/**\n * @param group\n * @param uniformData\n * @internal\n */\nexport function generateUniformsSyncPolyfill(\n    group: UniformGroup,\n    uniformData: Record<string, GlUniformData>\n): UniformsSyncCallback\n{\n    // loop through all the uniforms..\n    const functionMap: Record<string, UniformUploadFunction> = {};\n\n    for (const i in group.uniformStructures)\n    {\n        if (!uniformData[i]) continue;\n\n        const uniform = group.uniformStructures[i];\n\n        let parsed = false;\n\n        for (let j = 0; j < uniformParsers.length; j++)\n        {\n            const parser = uniformParsers[j];\n\n            if (uniform.type === parser.type && parser.test(uniform))\n            {\n                functionMap[i] = uniformParserFunctions[j];\n\n                parsed = true;\n\n                break;\n            }\n        }\n\n        // if not parsed...\n\n        if (!parsed)\n        {\n            const templateType = uniform.size === 1 ? uniformSingleParserFunctions : uniformArrayParserFunctions;\n\n            functionMap[i] = templateType[uniform.type];\n        }\n    }\n\n    return (\n        ud: Record<string, any>,\n        uv: Record<string, any>,\n        renderer: WebGLRenderer) =>\n    {\n        const gl = renderer.gl;\n\n        for (const i in functionMap)\n        {\n            const v = uv[i];\n            const cu = ud[i];\n            const cv = ud[i].value;\n\n            functionMap[i](i, cu, cv, v, ud, uv, gl);\n        }\n    };\n}\n"],"names":[],"mappings":";;;;AAcO,SAAS,4BAAA,CACZ,OACA,WAAA,EAEJ;AAEI,EAAA,MAAM,cAAqD,EAAC;AAE5D,EAAA,KAAA,MAAW,CAAA,IAAK,MAAM,iBAAA,EACtB;AACI,IAAA,IAAI,CAAC,WAAA,CAAY,CAAC,CAAA,EAAG;AAErB,IAAA,MAAM,OAAA,GAAU,KAAA,CAAM,iBAAA,CAAkB,CAAC,CAAA;AAEzC,IAAA,IAAI,MAAA,GAAS,KAAA;AAEb,IAAA,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,cAAA,CAAe,QAAQ,CAAA,EAAA,EAC3C;AACI,MAAA,MAAM,MAAA,GAAS,eAAe,CAAC,CAAA;AAE/B,MAAA,IAAI,QAAQ,IAAA,KAAS,MAAA,CAAO,QAAQ,MAAA,CAAO,IAAA,CAAK,OAAO,CAAA,EACvD;AACI,QAAA,WAAA,CAAY,CAAC,CAAA,GAAI,sBAAA,CAAuB,CAAC,CAAA;AAEzC,QAAA,MAAA,GAAS,IAAA;AAET,QAAA;AAAA,MACJ;AAAA,IACJ;AAIA,IAAA,IAAI,CAAC,MAAA,EACL;AACI,MAAA,MAAM,YAAA,GAAe,OAAA,CAAQ,IAAA,KAAS,CAAA,GAAI,4BAAA,GAA+B,2BAAA;AAEzE,MAAA,WAAA,CAAY,CAAC,CAAA,GAAI,YAAA,CAAa,OAAA,CAAQ,IAAI,CAAA;AAAA,IAC9C;AAAA,EACJ;AAEA,EAAA,OAAO,CACH,EAAA,EACA,EAAA,EACA,QAAA,KACJ;AACI,IAAA,MAAM,KAAK,QAAA,CAAS,EAAA;AAEpB,IAAA,KAAA,MAAW,KAAK,WAAA,EAChB;AACI,MAAA,MAAM,CAAA,GAAI,GAAG,CAAC,CAAA;AACd,MAAA,MAAM,EAAA,GAAK,GAAG,CAAC,CAAA;AACf,MAAA,MAAM,EAAA,GAAK,EAAA,CAAG,CAAC,CAAA,CAAE,KAAA;AAEjB,MAAA,WAAA,CAAY,CAAC,EAAE,CAAA,EAAG,EAAA,EAAI,IAAI,CAAA,EAAG,EAAA,EAAI,IAAI,EAAE,CAAA;AAAA,IAC3C;AAAA,EACJ,CAAA;AACJ;;;;"}
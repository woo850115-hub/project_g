{"version":3,"file":"generateUboSyncPolyfill.mjs","sources":["../../../src/unsafe-eval/ubo/generateUboSyncPolyfill.ts"],"sourcesContent":["import { WGSL_TO_STD40_SIZE } from '../../rendering/renderers/gl/shader/utils/createUboElementsSTD40';\nimport { WGSL_ALIGN_SIZE_DATA } from '../../rendering/renderers/gpu/shader/utils/createUboElementsWGSL';\nimport { uniformParsers } from '../../rendering/renderers/shared/shader/utils/uniformParsers';\nimport { uboParserFunctions, uboSingleFunctionsSTD40, uboSingleFunctionsWGSL } from './uboSyncFunctions';\n\nimport type { UboElement, UniformsSyncCallback } from '../../rendering/renderers/shared/shader/types';\nimport type { UniformGroup } from '../../rendering/renderers/shared/shader/UniformGroup';\nimport type { UboUploadFunction } from './uboSyncFunctions';\n\n/**\n * @param uboElements\n * @internal\n */\nexport function generateUboSyncPolyfillSTD40(uboElements: UboElement[]): UniformsSyncCallback\n{\n    return generateUboSyncPolyfill(\n        uboElements,\n        uboSingleFunctionsSTD40,\n        (uboElement: UboElement) =>\n        {\n            const rowSize = Math.max(WGSL_TO_STD40_SIZE[uboElement.data.type] / 16, 1);\n            const elementSize = (uboElement.data.value as Array<number>).length / uboElement.data.size;// size / rowSize;\n            const remainder = (4 - (elementSize % 4)) % 4;\n\n            return (_name: string, data: Float32Array, offset: number, _uv: any, v: any) =>\n            {\n                let t = 0;\n\n                for (let i = 0; i < (uboElement.data.size * rowSize); i++)\n                {\n                    for (let j = 0; j < elementSize; j++)\n                    {\n                        data[offset++] = v[t++];\n                    }\n\n                    offset += remainder;\n                }\n            };\n        }\n\n    );\n}\n\n/**\n * @param uboElements\n * @internal\n */\nexport function generateUboSyncPolyfillWGSL(uboElements: UboElement[]): UniformsSyncCallback\n{\n    return generateUboSyncPolyfill(\n        uboElements,\n        uboSingleFunctionsWGSL,\n        (uboElement: UboElement) =>\n        {\n            const { size, align } = WGSL_ALIGN_SIZE_DATA[uboElement.data.type];\n\n            const remainder = (size - align) / 4;\n\n            return (_name: string, data: Float32Array, offset: number, _uv: any, v: any) =>\n            {\n                let t = 0;\n\n                for (let i = 0; i < uboElement.data.size * (size / 4); i++)\n                {\n                    for (let j = 0; j < (size / 4); j++)\n                    {\n                        data[offset++] = v[t++];\n                    }\n                    offset += remainder;\n                }\n            };\n        }\n    );\n}\n\nfunction generateUboSyncPolyfill(\n    uboElements: UboElement[],\n    uboFunctions: Record<string, UboUploadFunction>,\n    arrayUploadFunction: (uboElement: UboElement) => UboUploadFunction\n): UniformsSyncCallback\n{\n    // loop through all the uniforms..\n    const functionMap: Record<string, {offset: number, func: UboUploadFunction}> = {};\n\n    for (const i in uboElements)\n    {\n        const uboElement = uboElements[i];\n        const uniform = uboElement.data;\n\n        let parsed = false;\n\n        functionMap[uniform.name] = {\n            offset: uboElement.offset / 4,\n            func: null\n        };\n\n        for (let j = 0; j < uniformParsers.length; j++)\n        {\n            const parser = uniformParsers[j];\n\n            if (uniform.type === parser.type && parser.test(uniform))\n            {\n                functionMap[uniform.name].func = uboParserFunctions[j];\n\n                parsed = true;\n\n                break;\n            }\n        }\n\n        // if not parsed...\n\n        if (!parsed)\n        {\n            if (uniform.size === 1)\n            {\n                functionMap[uniform.name].func = uboFunctions[uniform.type];\n            }\n            else\n            {\n                functionMap[uniform.name].func = arrayUploadFunction(uboElement);\n            }\n        }\n    }\n\n    return (\n        uniforms: UniformGroup,\n        data: Float32Array,\n        offset: number\n    ) =>\n    {\n        for (const i in functionMap)\n        {\n            functionMap[i].func(i, data, offset + functionMap[i].offset, uniforms, uniforms[i as keyof typeof uniforms]);\n        }\n    };\n}\n"],"names":[],"mappings":"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"}